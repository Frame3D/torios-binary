// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "flfm.h"
#include "../include/toolbar_icons.h"
#define NANOSVG_ALL_COLOR_KEYWORDS
#define NANOSVG_IMPLEMENTATION
#include "../include/nanosvg.h"
#define NANOSVGRAST_IMPLEMENTATION
#include "../include/nanosvgrast.h"
std::vector<std::string> m_themesVector; 
static std::string m_gtk_theme; 
std::vector<std::string> m_ICON_PATHS; 

void Icon::changeWidgetIcon(std::string icon_file, bool save) {
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetIcon::Icon file is empty");
    return;
  }
  bool folder=false;
  if(icon_file.compare("folder")==0)
  {
    folder=true;
    if( (default_folder.compare("")!=0) && test_file(default_folder) )
    {
      icon_file=default_folder;
    }
  }
  
  if(save)
  {
    if(OLD_ICON==icon_file)
      return;
    OLD_ICON=icon_file;
  }
  int h = this->w();
  int w = this->h();
  if(w>h)
    h=w;
  int iconW=24;
  align(FL_ALIGN_CENTER);
  copy_label("");
  image(NULL);
  redraw();
  label(0L);
  if(m_ICON_PATHS.empty())
    m_ICON_PATHS=IconPaths(iconW);
  std::cout<<"changeWidgetIcon:: w="<<w<<" h="<<h<<std::endl;
  if(!test_file(icon_file))
  {
    std::string tmp=icon_file;
    unsigned int ext=icon_file.rfind(".");
    if(ext>icon_file.length())
    {
      tmp=icon_file+".svg";
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")==0)
      {
        tmp=icon_file+".png";
        tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
        if(tmp.compare("")!=0)
        {
          trace("changeWidgetIcon::RESULT="+tmp);
          icon_file=tmp;
        }
      }
      else
      {
        trace("changeWidgetIcon::RESULT="+tmp);
        icon_file=tmp;
      }
    }
    else
    {
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")==0)
      {
        trace("changeWidgetIcon::looking for icon file");
        tmp=look_for_icon_file(icon_file);
        
      }
      if(tmp.compare("")!=0)
      {
        icon_file=tmp;
        trace("changeWidgetIcon::RESULT="+tmp);
      }
    }
  }
  else
  {
    trace("changeWidgetIcon::"+icon_file+" is a file!");
  }
  
  if(folder)
  {
    if (default_folder.compare("")==0)
    {
       if( test_file(icon_file) )
         default_folder = icon_file;
    }
  }
  
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetIcon::Icon file is empty");
    return;
  }
  
  Fl_Image* image2=image();//new Fl_Image(w,h,4);
  
  if(has_file_extention_at_end(icon_file,".png"))
  {
    Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xpm"))
  {
    Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xbm"))
  {
    Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".svg"))
  {
    NSVGimage *svg_image = NULL;
    NSVGrasterizer *rast = NULL;
    unsigned char* img_data = NULL;
    int width;
    int height;
    const int depth = 4;
    svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
    if (svg_image == NULL)
    {
      trace("changeWidgetIcon::Could not open SVG image:"+icon_file);
      return;
    }
    width = (int)svg_image->width;
    height = (int)svg_image->height;
    rast = nsvgCreateRasterizer();
    if (rast == NULL)
    {
      trace("changeWidgetIcon::Could not init rasterizer.");
      return;
    }
    img_data = (unsigned char*)malloc(width * height * depth);
    if (img_data == NULL)
    {
      trace("changeWidgetIcon::Could not alloc image buffer.\n");
      return;
    }
    nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
    Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
    image2 = image->copy();
    delete(image);
    nsvgDeleteRasterizer(rast);
    nsvgDelete(svg_image);
  }
  else if((has_file_extention_at_end(icon_file,".jpg"))||
  (has_file_extention_at_end(icon_file,".jpeg"))||
  (has_file_extention_at_end(icon_file,".face")))
  {
    Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".gif"))
  {
    Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else{return;}
  
  image(image2);
  show();
}

Icon::Icon(std::string icon_file,int X,int Y,int W,int H,const char *l):Fl_Button(X,Y,W,H,l) {
  //changeWidgetIcon(icon_file,true);
}

std::vector<std::string> Icon::comma_vector(std::string LINE,std::vector<std::string> Vector) {
  std::string original,preComma,postComma;
  original=LINE;
  unsigned int found,finder;
  finder=original.length();
  for(found=original.find(",");found<finder;found=original.find(",")){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

std::string Icon::convert_num_to_string(int num) {
  std::string number;
  std::stringstream out;
  out << num;
  number = out.str();
  return number;
}

unsigned int Icon::convert_string_to_number(std::string num) {
  if(num.compare("")==0){return 0;}
  std::stringstream out;
  out << num;
  unsigned int integer;
  out >> integer;
  return integer;
}

std::string Icon::current_path(int whichPath) {
  unsigned int lastPath = 0;
  std::string result;
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  const char* path =getenv("PATH");
  std::string stringPATH;
  if(path == NULL){stringPATH = "/usr/bin";}
  else{stringPATH = path;}
  std::string::size_type firstPosition = stringPATH.find(':');
  if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
  std::string::size_type position = firstPosition;
  for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
  result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
  return result;
}

std::vector<std::string> Icon::delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter) {
  std::vector<std::string> Vector;
  std::string original,preComma,postComma;
  original=string_to_become_vector;
  unsigned int found,finder;
  finder=original.length();
  if(original.find(delimiter)>original.length()){
    Vector.push_back(original);
    return Vector;
  }
  for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

std::vector<std::string> Icon::desktop_dirs() {
  std::string envVar ="XDG_DATA_DIRS";
  std::string incasenothingexists="/usr/local/share/:/usr/share/";
  std::vector<std::string> thisPath;
  std::vector<std::string>::iterator it;
  std::string thisXDG;
  const char* datadirs=getenv(envVar.c_str());
  if (datadirs == NULL)
  {
    thisXDG=incasenothingexists;
  }
  else
  {
    thisXDG=datadirs;
  }
  unsigned int numberOfPaths;
  std::string tempXDG = thisXDG;
  unsigned int tryer=0;
  unsigned int xdgLen=0;
  xdgLen=thisXDG.length();
  for (numberOfPaths=0;tryer<xdgLen;)
  {
    tryer = tempXDG.find(":");
    tempXDG=tempXDG.erase(0,tryer+1);
    xdgLen=tempXDG.length();
    numberOfPaths++;
  }
  unsigned int lastPath = 0;
  std::string result;
  for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
  {
    if (whichPath >=1){lastPath = whichPath - 1;}
    else {lastPath = 0;}
    std::string::size_type firstPosition = thisXDG.find_first_of(':');
    std::string::size_type position = thisXDG.find(':');
    for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
    for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
    result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
    thisPath.push_back(result);    
  }
  std::sort (thisPath.begin(), thisPath.end());
  it = std::unique (thisPath.begin(), thisPath.end());
  thisPath.resize( std::distance(thisPath.begin(),it) );
  return thisPath;
}

std::string Icon::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename)){trace("No file sent in: "+filename);}
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

std::string Icon::find_xdg_data_dir_subdir(std::string subdir) {
  std::vector<std::string> xdgDataDirs = desktop_dirs();
  std::string dirToOpen;
  for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
  it!=xdgDataDirs.end();
  ++it)
  {
    dirToOpen=*it;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
    else
    {
      dirToOpen+="/";
      dirToOpen+=subdir;
    }
    if(test_dir(dirToOpen))
    {
      if(finder+1==dirToOpen.length()){return dirToOpen;}
      else
      {
        dirToOpen+="/";
        return dirToOpen;
      }
    }
    else{trace(dirToOpen+" does not exist");}
  }
  return "";
}

std::string Icon::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string Icon::get_equal_value(std::string INTERNAL_LINE) {
  std::string subString;
  unsigned int found =INTERNAL_LINE.find("=");
  if(found < INTERNAL_LINE.length())
  {
   subString=INTERNAL_LINE.substr(found+1,std::string::npos);
   return subString;
  }
  return "";
}

std::vector<std::string> Icon::get_file_vector(std::string DIRECTORY,std::string file) {
  std::vector<std::string> myVector;
  if(!test_dir(DIRECTORY)){return myVector;}
  if(DIRECTORY.compare("")==0){return myVector;}
  if(file.compare("")==0){return myVector;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(DIRECTORY.c_str());
  if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        unsigned int findIT = fullpath.find(file);
        if(findIT<=fullpath.length()){myVector.push_back(fullpath);}
  
      }
      if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
        std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          std::string temp=fullpath+file;
          myVector.push_back(temp);
        }
      }
    }
  }
  myVector=sort_array(myVector);
  return myVector;
}

std::string Icon::get_gtk_icon_theme() {
  if(m_gtk_theme.compare("")!=0)
    return m_gtk_theme;
  std::string itemToGet="icon";
  std::string defaultTheme="hicolor";
  std::string gtkrc2_result, gtkrc3_result,gtk2;
  if((itemToGet.compare("icon")!=0)&&(itemToGet.compare("")!=0))
  {
    itemToGet="";
  }
  std::string item=itemToGet;
  std::string GSETTINGS=term_out("which gsettings");
  std::string GCONF2=term_out("which gconftool-2");
  if(GSETTINGS.find("gsettings")<GSETTINGS.length())
  {
    std::string temp=item;
    if(item.compare("")==0)temp="gtk";
    gtkrc3_result=term_out(GSETTINGS+" get org.gnome.desktop.interface "+temp+"-theme");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\'");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\'");
    m_gtk_theme = gtkrc3_result;
    return gtkrc3_result;
  }
  if(GCONF2.find("gconftool-2")<GCONF2.length())
  {
    std::string temp="gtk";
    if(item.compare("")!=0)temp=item;
    gtk2=term_out(GCONF2+" --get /desktop/gnome/interface/"+temp+"_theme");
    m_gtk_theme = gtk2;
    return gtk2;
  }
  const char* home = getenv("HOME");
  if(home==NULL){return defaultTheme;}
  std::string HOME=home;
  //CHECK/SET GTKRC FILES
  std::string GTKRC2=HOME + "/.gtkrc-2.0";
  const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
  std::string XDG_CONFIG_HOME;
  if (xdg_config_home!=NULL)
  {
    XDG_CONFIG_HOME=xdg_config_home;
  }
  else
  {
    XDG_CONFIG_HOME=HOME +"/.config";
  }
  std::string GTKRC3=XDG_CONFIG_HOME + "/gtk-3.0/settings.ini";
  if(test_file(GTKRC3.c_str()))
  {
    std::string temp;
    if(item.compare("")!=0)temp=item+"-";
    temp="gtk"+temp+"-theme-name=";
    gtkrc3_result=get_line_with_equal(GTKRC3,temp);
    gtkrc3_result=remove_cruft(gtkrc3_result,temp);
    gtkrc3_result=remove_cruft(gtkrc3_result,"\"");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\"");
    m_gtk_theme = gtkrc3_result;
    return gtkrc3_result;
  }
  if(test_file(GTKRC2.c_str()))
  {
    std::string temp;
    if(item.compare("")!=0)temp=item+"-";
    temp="gtk"+temp+"-theme-name=";
    gtkrc2_result=get_line_with_equal(GTKRC2,temp);
    gtkrc2_result=remove_cruft(gtkrc2_result,"\"");
    gtkrc2_result=remove_cruft(gtkrc2_result,"\"");
    m_gtk_theme = gtkrc2_result;
    return gtkrc2_result;
  }
  return defaultTheme;
}

std::string Icon::get_line_with_delim(std::string filename, std::string line,std::string delim) {
  if(line.compare("")==0){return "";}
  if(filename.compare("")==0){return "";}
  if(!test_file(filename)){trace("get_line_with_delim::No file sent in\n"+filename+","+line);}
  std::string thisLine;
  std::string subString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  std::string hash="#";
  std::string itemToFind=line+delim;
  unsigned int len=itemToFind.length();
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(thisLine.find(hash)<=1){}
      else
      {
        unsigned int found=thisLine.find(itemToFind);
        if(found<thisLine.length())
        {
          found+=len;
          subString=thisLine.substr(found,std::string::npos);
          return subString;
        }
      }
    }
  }
  return "";
}

std::string Icon::get_line_with_equal(std::string filename, std::string line) {
  return get_line_with_delim(filename,line,"=");
}

std::string Icon::get_shell_for_C() {
  std::string shell=term_out("which bash");
  if(shell.compare("")==0){
    if(!test_exec(shell)){
    shell=term_out("which sh");
    if(!test_exec(shell)){return "";}
    //TODO make this work for others
    }
  }
  shell=shell+" -c '";
  return shell;
}

std::string Icon::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

bool Icon::has_file_extention_at_end(std::string filename,std::string extention) {
  std::string extention_check;
  std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
  std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
  unsigned int found=filename.find(extention);
  unsigned int ext_len=extention.length();
  unsigned int file_len=filename.length();
  if(found<file_len)
  {
    if(found==(file_len-ext_len))
    {
      return true;
    }
  }
  return false;
}

unsigned int Icon::items_in_path() {
  const char* path =getenv("PATH");
  std::string::size_type pathPosition =0;
  if(path==NULL){return 1;}
  std::string stringPATH = path;
  unsigned int howmany;
  for(howmany=1;(pathPosition!=std::string::npos);howmany++)
  {
    pathPosition=stringPATH.find(':', pathPosition+1);
  }
  return howmany;
}

std::vector<std::string> Icon::IconPaths(int size_to_use) {
  std::vector<std::string> ret;
  if(m_themesVector.empty())
    m_themesVector=icon_themefiles_vector();
  
  std::string gtk_theme=get_gtk_icon_theme();
  gtk_theme=sed_i(gtk_theme,"-"," ");
  
  trace("IconPaths::Look for this="+gtk_theme);
  if(m_themesVector.empty())
  {
    trace("IconPaths::Didn't find any Icon themes");
    return ret;
  }
  return IconPathsForTheme(gtk_theme,size_to_use);
}

std::vector<std::string> Icon::IconPathsForTheme(std::string theme,int size_to_use) {
  std::vector<std::string> ret;
  std::string themefile;
  for( std::vector<std::string>::iterator it = m_themesVector.begin();
  it!=m_themesVector.end();
  ++it)
  {
    std::string THEME=*it;
    std::string theme_name=get_line_with_equal(THEME,"Name");
    if(theme_name.compare(theme)==0)
    {
      trace("IconPathsForTheme::File="+THEME);
      ret=join_string_vectors(ret,list_icon_dirs_in_themefile(THEME,size_to_use));
      //std::reverse(ret.begin(),ret.end());
      std::string inherits=get_line_with_equal(THEME,"Inherits");
      std::vector<std::string> inheritsVec = delimiter_vector_from_string(inherits,",");
  
      for( std::vector<std::string>::iterator iter = inheritsVec.begin();
        iter!=inheritsVec.end();
        ++iter)
      {
        std::string item = *iter;
        ret=join_string_vectors(ret,IconPathsForTheme(item,size_to_use));
      }
    }
  }
  //std::reverse(ret.begin(),ret.end());
  return ret;
}

std::vector<std::string> Icon::icon_themefiles_vector() {
  std::string DIRECTORY=find_xdg_data_dir_subdir("icons");
  std::vector<std::string> thisISmyVector;
  if(DIRECTORY.compare("")==0){trace("Icon directory NOT found");}
  else{thisISmyVector=get_file_vector(DIRECTORY,"index.theme");}
  if(thisISmyVector.empty()){trace("Didn't find and Icon themes");}
  return thisISmyVector;
}

std::vector<std::string> Icon::join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB) {
  std::vector<std::string> bothVectors;
  bothVectors.reserve(vectorA.size()+vectorB.size());
  bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
  bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
  return bothVectors;
}

std::vector<std::string> Icon::list_icon_dirs_in_themefile(std::string themefile,int size_to_use) {
  std::vector<std::string> ListOfIconDirs;
  std::string SIZE_TO_USE=convert_num_to_string(size_to_use);
  std::string INTERNAL_LINE;
  std::string subString;
  std::string basedir=get_directory_from_filename(themefile);
  std::string THEME_DIR=basedir;
  if(!test_file(themefile))
       return ListOfIconDirs;
  std::ifstream inputFileStrem (themefile.c_str(), std::ifstream::in);
  std::string INHERITS;
  std::string tmpDIRi="/usr/share/pixmaps/";
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  
  tmpDIRi="/usr/share/icons/hicolor/48x48/apps/";
  
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  
  tmpDIRi="/usr/share/icons/hicolor/scalable/apps/";
  
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  if(inputFileStrem.is_open())
  {
    std::string DIRS,MIN,MAX,SIZE,TYPE,THRESH,CONTEXT,HEADER;
    int size=0;
    int tresh=0;
    int max=0;
    int min=0;
    std::string LINE=get_equal_value(INTERNAL_LINE);
    while (getline(inputFileStrem,INTERNAL_LINE))
    {
         if(INTERNAL_LINE.find('[')<INTERNAL_LINE.length())
         {
           HEADER=INTERNAL_LINE;
           HEADER=remove_cruft(HEADER,"[");
           HEADER=remove_cruft(HEADER,"]");
           HEADER="/"+HEADER;
         }
         else if(INTERNAL_LINE.find("Inherits=")<INTERNAL_LINE.length())
         {
           INHERITS=LINE;
         }
         else if(INTERNAL_LINE.find("Directories=")<INTERNAL_LINE.length())
         {
           DIRS=LINE;
         }
         else if(INTERNAL_LINE.find("MinSize=")<INTERNAL_LINE.length())
         {
           MIN=LINE;
           min=convert_string_to_number(MIN);
         }
         else if(INTERNAL_LINE.find("MaxSize=")<INTERNAL_LINE.length())
         {
           MAX=LINE;
           max=convert_string_to_number(MAX);
         }
         else if(INTERNAL_LINE.find("Size=")<INTERNAL_LINE.length())
         {
           SIZE=LINE;
           size=convert_string_to_number(SIZE);
         }
         else if(INTERNAL_LINE.find("Type=")<INTERNAL_LINE.length())
         {
           TYPE=LINE;
         }
         else if(INTERNAL_LINE.find("Threshold=")<INTERNAL_LINE.length())
         {
           THRESH=LINE;
           tresh=convert_string_to_number(THRESH);
         }
         else if(INTERNAL_LINE.find("Context=")<INTERNAL_LINE.length())
         {
           CONTEXT=LINE;
         }
         if((CONTEXT.compare("Animations")!=0)
         &&(CONTEXT.compare("Stock")!=0)
         &&(CONTEXT.compare("Status")!=0)
         &&(CONTEXT.compare("Emblems")!=0)
         &&(CONTEXT.compare("Emotes")!=0)
         &&(CONTEXT.compare("International")!=0) )
         {
           if((SIZE.compare(SIZE_TO_USE))||
           ((tresh-size)==(size_to_use))||
           ((tresh+size)==(size_to_use)) )
           {
              if(HEADER.find(SIZE)<HEADER.length())
              {
                std::string testDIR=THEME_DIR+HEADER;
                if(test_dir(testDIR))
                {
                  if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                    ListOfIconDirs.push_back(testDIR);
                }
              }
         }
         else{
              if(TYPE.compare("Scalable")==0)
              {
                if((max>=size)&&(min<=size))
                {
                  std::string testDIR=THEME_DIR+HEADER;
                  if(test_dir(testDIR))
                  {
                       if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                         ListOfIconDirs.push_back(testDIR);
                  }
                }
              }
         }
         }
       }
  }
  trace("list_icon_dirs_in_themefile::Done parsing themefile "+themefile);
  if(INHERITS.compare("")!=0)
  {
    std::string inheritThemeFileDIR=find_xdg_data_dir_subdir("icons");
    std::string inheritThemeFile=inheritThemeFileDIR;
    if(INHERITS.find(",")<INHERITS.length())
    {
      std::vector<std::string> InheritFileVector=comma_vector(INHERITS,InheritFileVector);
      std::vector<std::string> IconFileVector=list_icon_dirs_in_themefile( themefile, size_to_use);
      for( std::vector<std::string>::iterator it = InheritFileVector.begin();
         it!=InheritFileVector.end();
         ++it)
      {
         std::string thisTheme=*it;
         inheritThemeFile+=thisTheme;
         std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
         if(temp.compare("")==0)
         {
              trace("list_icon_dirs_in_themefile::Couldn't find theme file in:"+inheritThemeFile);
         }
         else{
              std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
              if(!ListOfInheritIconDirs.empty())
              {
                ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
              }
         }
         }
       }
       else
       {
         inheritThemeFile+=INHERITS;
         std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
         if(temp.compare("")==0)
         {
           trace("list_icon_dirs_in_themefileCouldn't find theme file in:"+inheritThemeFile);
         }
         else{
           std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
           if(!ListOfInheritIconDirs.empty())
           {
              ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
           }
         }
       }
  }
  return ListOfIconDirs;
}

std::string Icon::look_for_icon_file(std::string fileWITHOUTpath) {
  std::string dir=find_xdg_data_dir_subdir("icons");
  trace("std::string look_for_icon_file(std::string "+fileWITHOUTpath+")");
  std::string gtktheme=get_gtk_icon_theme();
  
  if(dir.rfind('/')!=dir.length()-1){dir+="/";}
  
  std::string testingDIR=dir+gtktheme;
  
  if(testingDIR.rfind('/')!=testingDIR.length()-1){testingDIR+="/";}
  if(test_dir(testingDIR)){dir=testingDIR;}
  
  if(fileWITHOUTpath.compare("")==0)
  {
    trace("look_for_icon_file::(std::string "+fileWITHOUTpath+") requires non empty variables to work\nMUST EXIT");
    return "";
  }
  trace("look_for_icon_file::GTKtheme="+gtktheme+"\nDir="+dir);
  if(!test_dir(dir))
  {
    trace("look_for_icon_file::"+dir+" is not a directory\nTrying to look in icons directories");
    dir=find_xdg_data_dir_subdir("icons");
    if(!test_dir(dir))
    {
      trace("look_for_icon_file::"+dir+" is not a directory\nMUST EXIT");
      return "";
    }
    return look_for_first_file_in_subdirs(fileWITHOUTpath,dir);
  }
  
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  std::string finalAnswer;
  
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string fullpath=entryPointer->d_name;
  
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
  
      fullpath=dir+fullpath;
  
      if((entryPointer->d_type == DT_REG)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string tempFINDER="/"+fileWITHOUTpath;
        unsigned int findIT = fullpath.find(tempFINDER);
        if(findIT<=fullpath.length())
        {
          closedir(mydir);
          finalAnswer=fullpath;
          return fullpath;
        }
      }
  
      if((entryPointer->d_type==DT_DIR)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(test_file(thisAnswer))
          {
            closedir(mydir);
            finalAnswer=thisAnswer;
            return thisAnswer;
          }
        }
      }
    }
    closedir(mydir);
  }
  else
  {
    trace("look_for_icon_file::"+dir+" cannot be opened\nMUST EXIT");
  }
  
  if(finalAnswer.compare("")!=0)
    trace("look_for_icon_file::Final Answer="+finalAnswer);
  
  return finalAnswer;
}

std::string Icon::look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
    return "";
  
  /** if it is not a directory return empty */
  if(!test_dir(dir))
    return "";
  
  /** remove the preceding path*/
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  
  /** open the directory */
  if(mydir!=NULL){
    while ((entryPointer=readdir(mydir))!=NULL)
    {
    /** find out if it is a symlink or regular file that is not hidden*/
      if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        unsigned int findIT = fullpath.find(fileWITHOUTpath);
        if(findIT<=fullpath.length())
        {
      /** add a comma at the end if there isn't one already*/
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
          ANSWERS+=fullpath;
        }
      }
      /** find out if it is a directory that is not hidden*/
      if((entryPointer->d_type==DT_DIR)
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
          {
            ANSWERS+=",";
          }
          ANSWERS+=thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
  if(ANSWERS.compare("")!=0)
  {
    return ANSWERS;
  }
  return "";
}

std::string Icon::look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
  {
    trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\nMUST EXIT");
    return "";
  }
  if(!test_dir(dir))
  {
    trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\nMUST EXIT");
    return "";
  }
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  std::string finalAnswer;
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
    /** if it is a symlink or file check it */
      if(((entryPointer->d_type == DT_LNK)
        ||(entryPointer->d_type == DT_REG))
        &&(entryPointer->d_name[0]!='.'))
      {
        std::string tempFINDER="/"+fileWITHOUTpath;
        trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\nfullpath="+fullpath);
        unsigned int findIT = fullpath.find(tempFINDER);
        if(findIT<=fullpath.length())
        {
          if(entryPointer->d_type == DT_LNK)
          {
      /** if it is a symlink get the actual file */
            std::string temporary=get_symlinkpath(fullpath);
            trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\nFile="+temporary);
            if(temporary.compare("")!=0)
            {
              closedir(mydir);
              if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
              trace("look_for_first_file_in_subdirs::Symlink="+temporary);
              finalAnswer=temporary;
              return temporary;
            }
          }
          else
          {
            closedir(mydir);
            finalAnswer=fullpath;
            return fullpath;
          }
        }
      }
    /** if it is a directory look inside recursively */
      if((entryPointer->d_type==DT_DIR)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(test_file(thisAnswer))
          {
            closedir(mydir);
            finalAnswer=thisAnswer;
            return thisAnswer;
          }
        }
      }
    }
    closedir(mydir);
  }
  else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\nMUST EXIT");}
  trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
  return finalAnswer;
}

bool Icon::look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find) {
  for( std::vector<std::string>::iterator it = vector_to_check.begin();
  it!=vector_to_check.end();
  ++it){
    std::string tmp=*it;
    if(tmp.compare(item_to_find)==0){return true;}
  }
  return false;
}

std::string Icon::remove_cruft(std::string StringInput, std::string CruftToRemove) {
  if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
  unsigned int found=0;
  unsigned int cruftLength=CruftToRemove.length();
  found=StringInput.find(CruftToRemove);
  if(found>StringInput.length()){return StringInput;}
  std::string temp=StringInput;
  temp=temp.erase(0,found+cruftLength);
  if(temp.compare("")!=0){return temp;}
  std::string temp2=StringInput;
  temp2=temp2.erase(found,std::string::npos);
  if(temp2.compare("")!=0){return temp2;}
  trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
  return StringInput;
}

std::vector<std::string> Icon::sort_array(std::vector<std::string> vector_to_sort) {
  std::vector<std::string>::iterator it;
  std::sort (vector_to_sort.begin(), vector_to_sort.end());
  it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
  vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
  return vector_to_sort;
}

bool Icon::test_dir(std::string dirToTest) {
  if(dirToTest.compare("")==0){return false;}
  DIR *dir = NULL;
  dir = opendir(dirToTest.c_str());
  if (dir!=NULL)
  {
    closedir(dir);
    return true;
  }
  return false;
}

bool Icon::test_exec(std::string execToTest) {
  if(execToTest.compare("")==0){return false;}
  /** the list of directories it might check*/
  /** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
  std::string stringEXEC;
  std:: string testPATH, testExec;
  bool result = false;
  unsigned int numofpaths = items_in_path();
  for (unsigned int i = 1; i <= numofpaths; i++)
  {
    stringEXEC = execToTest;
    testPATH = current_path(i);
    stringEXEC = testPATH + "/" + stringEXEC;
    if(test_file(stringEXEC.c_str())){return true;}
  }
  return result;
}

bool Icon::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

std::string Icon::test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check) {
  if(fileWithNOPATH.compare("")==0){return "";}
  std::string filePathRemoved=fileWithNOPATH;
  unsigned int found=filePathRemoved.rfind('/');
  trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
  if(found<filePathRemoved.length())
  {
    unsigned int len=filePathRemoved.length()-found;
    filePathRemoved=filePathRemoved.erase(0,len);
  }
  for( std::vector<std::string>::iterator it = directories_to_check.begin();
    it!=directories_to_check.end();
    ++it)
  {
    std::string dirToOpen=*it;
    std::string result=dirToOpen;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
    else
    {
      result+="/";
      result+=filePathRemoved;
    }
    if(test_file(result))
    {
      trace("test_file_in_vector_path::FOUND="+result);
      return result;
    }
    else
    {
      std::string tmp=result;
      tmp=get_symlinkpath(tmp);
      if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
    }
  }
  return "";
}

std::string Icon::term_out(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  std::string result="";
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
    pclose(command_p);
  }
  else{ return "";}
  if (result.compare("")==0){return "";}
  int end = result.length();
  if((end-1) == 0){return "";}
  if((end) == 0){return "";}
  return result.erase(end-1,1);
}

std::string Icon::sed_i(std::string input, std::string remove, std::string replace) {
  unsigned int xmlfix=0;
  unsigned int oldFind=0;
  unsigned int length=input.length();
  unsigned int removeLength=remove.length();
  std::string modinput=input;
  while(modinput.find(remove,oldFind)<length)
  {
    xmlfix = modinput.find(remove,oldFind);
    oldFind=xmlfix+replace.length();
    std::string tempPRE,tempPOST,temp;
    if(xmlfix<length)
    {
      temp=modinput;
      tempPOST=modinput;
      tempPRE = temp.erase(xmlfix,std::string::npos);
      tempPOST = modinput.erase(0,xmlfix+removeLength);
      modinput = tempPRE + replace + tempPOST;
      length=modinput.length();
    }
  }
  return modinput;
}

Item::Item(std::string filename, int X, int Y, int W, int H, const char *L,std::string icon) : Icon ("",X,Y,W,H,L) {
  box(FL_NO_BOX);
  align(FL_ALIGN_INSIDE);
  if(icon.compare("")==0)
    default_folder=icon;
  Filename = filename;
  copy_label(L);
  int Wx= 0, Hx=0;
  measure_label(Wx,Hx);
  size(Wx,h());
  tooltip(Filename.c_str());
  
  if(stat(Filename.c_str(), &statbuf) == -1)
    process_errno();
  
  if(fl_filename_isdir (Filename.c_str()))
  {
    //changeWidgetIcon("folder",true);
    image(color_folder_image);
  }
  else
  {
    const char* ext = fl_filename_ext(Filename.c_str());
    std::string EXT;
    if(ext!=NULL)
      EXT=ext;
    std::transform(EXT.begin(), EXT.end(), EXT.begin(), ::tolower);
  //TODO MIME
  /*
    const char *mime
    magic_t magic;
    magic = magic_open(MAGIC_MIME_TYPE);
    magic_load(magic, NULL);
    magic_compile(magic, NULL);
    mime = magic_file(magic, Filename.c_str());
    magic_close(magic);
    trace(mime);
  */
    image(color_file_image);
    /*
    if(extension(EXT,"txt"))
      changeWidgetIcon("application-document",true);
    else if(extension(EXT,"tar","gz","gzip","bz","bzip","xz","7zip"))
      changeWidgetIcon("application-archive",true);
    else if(extension(EXT,"gif","bmp","ico","tiff","tga","psd","png","jpg","jpeg","xpm","xbm"))
      changeWidgetIcon("application-images",true);
    else if(extension(EXT,"ogg","mp3","wav","mp2","flac","aac","aiff","m4a","midi","xi"))
      changeWidgetIcon("application-audio",true);
    else if(extension(EXT,"mp4","wmv","ogm","asf","webm","vivo","m4v","vob","divx","flv","avi","ogv","mpeg","mov"))
      changeWidgetIcon("application-video",true);
    else
      changeWidgetIcon("unknown",true);
    */
  }
}

int Item::handle(int e) {
  int ret = Fl_Button::handle(e);
  UserInterface* ui = ((UserInterface*)(this->parent()->user_data()));
  switch ( e )
  {
    case FL_PUSH:
      switch(Fl::event_button())
      {
        case FL_LEFT_MOUSE:
          if(Fl::event_clicks())
          {
          trace("button 1!");
            open();
            return 1;
          }
          else
            break;
        case FL_RIGHT_MOUSE:
          ui->make_popup(this->parent());
          ret = 1;
          break;
      }
      break;
  } 
  return ret;
}

void Item::open() {
  ((Tab *) (user_data()))->change_dir(Filename);
}

std::string Item::properties(int type) {
  std::string res;
  std::stringstream out;
  struct tm *tmt;
  char datestring[256];
  switch(type)
  {
    case 0: // device ID
      out << statbuf.st_dev;
      break;
    case 1: // File serial number
      out << statbuf.st_ino;
      break;
    case 2: // mode
      out << statbuf.st_mode;
      break;
    case 3: // user ID
      out << statbuf.st_uid;
      break;
    case 4: //Group ID
      out << statbuf.st_gid;
      break;
    case 5:  //size
      out << statbuf.st_size;
      break;
    case 6: // Number of blocks allocated for this object.
      out << statbuf.st_blocks;
      break;
    case 7: // Time of last access.
      tmt = localtime(&statbuf.st_atime);
      strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tmt);
      out << datestring;
      break;
    case 8: // Time of last data modification.
      tmt = localtime(&statbuf.st_mtime);
      strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tmt);
      out << datestring;
      break;
    case 9: // Time of last status change.
      tmt = localtime(&statbuf.st_ctime);
      strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tmt);
      out << datestring;
      break;
  }
  res=out.str();
  return res;
}

std::string Item::get_mod_time() {
  return properties(8);
}

Grid::Grid(std::string directory, int X, int Y, int W, int H) : Fl_Scroll (X,Y,W,H) {
  Directory=directory;
  color(FL_BACKGROUND2_COLOR);
  theme_scrollbars(this);
  populate();
}

void Grid::populate() {
  trace("populate:"+Directory);
  int spacer = 5;
  _w = 100;
  _h = 52;
  int W = _w;
  _x = spacer;
  _y = _x;
  clear();
  int lines=0;
  int columns = w();
  columns = (columns / (_w + spacer*2));
  int column=0;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(Directory.c_str());
  begin();
  if(Directory.rfind('/')!=Directory.length()-1){Directory+="/";}
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string name=entryPointer->d_name;
      if( (name.compare(".")==0) || (name.compare("..")==0) )
      {
        //do nothing for this... since it means 'current directory'
      }
      else
      {
        std::string fullpath=Directory+name;
        Item *i = new Item(fullpath,_x,_y,_w,_h,name.c_str(),default_folder);
        i->user_data(this->parent());
        W=i->w();
        i->show();
        if(i->default_folder.compare("")!=0)
        {
          default_folder=i->default_folder;
        }
        if(column<=columns)
        {
          _x+=(spacer+W);
        }
        else
        {
          column=0;
          lines++;
          _y+=(spacer+_h);
          _x=spacer;
        }
        column++;
      }
    }
  }
  else
  {
   trace("Couldn't open: "+Directory);
  }
  end();
  //std::cout<<xposition()<<","<<yposition()<<std::endl;
  scrollbar.scrollvalue(0,scrollbar.slider_size(),0,lines);
  hscrollbar.scrollvalue(0,hscrollbar.slider_size(),0,lines);
  parent()->redraw();
}

void Grid::load(std::string directory) {
  Directory=directory;
  clear();
  populate();
}

void Grid::open() {
  trace("Open");
}

int File_List_Browser::handle(int e) {
  int ret = Fl_File_Browser::handle(e);
  UserInterface * ui = ((UserInterface *)(user_data()));
  switch ( e )
  {
    case FL_PUSH:
      switch(Fl::event_button())
      {
        case FL_LEFT_MOUSE:
          if(Fl::event_clicks())
          {
          trace("button 1!");
            Picker(this);
            return 1;
          }
          else
            break;
        case FL_RIGHT_MOUSE:
          ui->make_popup(this);
          return 1;
      }
      break;
  } 
  return ret;
}

File_List_Browser::File_List_Browser(int X, int Y, int W, int H, const char *L) : Fl_File_Browser (X,Y,W,H,L) {
  /*
  Fl_File_Icon(,Fl_File_Icon::PLAIN);
  Fl_File_Icon(,Fl_File_Icon::DIRECTORY);
  Fl_File_Icon(,Fl_File_Icon::PLAIN);
  Fl_File_Icon(,Fl_File_Icon::DEVICE);
  Fl_File_Icon(,Fl_File_Icon::FIFO);
  Fl_File_Icon(,Fl_File_Icon::ANY);
  */
  scrollbar.slider(FL_FLAT_BOX);
  hscrollbar.slider(FL_FLAT_BOX);
}

void File_List_Browser::open() {
  Picker(this);
}

Tab::Tab(std::string directory, void *v, int X, int Y, int W, int H,const char *l) : Fl_Group (X,Y,W,H,l) {
  trace("Add a TAB");
  begin();
  user_data(v);
  color((Fl_Color)51);
  const char * h = getenv("HOME");
  if(h!=NULL)
  {
    HOME=h;
    HOME+="/";
  }
  else
  {
    HOME="/";
    XDG_CONFIG_HOME="";
  }
  const char * x = getenv("XDG_CONFIG_HOME");
  if(x != NULL)
    XDG_CONFIG_HOME=x;
  else
    XDG_CONFIG_HOME=HOME+=".config";
  
  
  if(h!=NULL)
  {
    if(directory.compare("")==0)
    {
      directory=h;
      directory+="/";
    }
  }
  if(TYPE==0)
  {
    FileBrowser = new File_List_Browser(165, 95, 375, 350);
    FileBrowser->box(FL_FLAT_BOX);
    FileBrowser->selection_color((Fl_Color)80);
    FileBrowser->type(2);
    FileBrowser->Picker=f_cb;
    FileBrowser->user_data(v);
    Fl_Group::current()->resizable(FileBrowser);
  }
  else
  {
    FileGrid = new Grid(directory,165, 95, 375, 350);
    FileGrid->user_data(v);
    Fl_Group::current()->resizable(FileGrid);
  }
  
  Places = new Fl_Browser(10, 95, 150, 90);
  Places->box(FL_FLAT_BOX);
  Places->type(2);
  Places->selection_color((Fl_Color)80);
  Places->callback((Fl_Callback*)p_cb);
  theme_scrollbars(Places);
  
  Bookmarks = new Fl_Browser(10, 190, 150, 250);
  Bookmarks->type(2);
  Bookmarks->box(FL_FLAT_BOX);
  Bookmarks->selection_color((Fl_Color)80);
  Bookmarks->callback((Fl_Callback*)b_cb);
  theme_scrollbars(Bookmarks);
  
  end();
  
  
  change_dir(directory);
  make_bookmarks();
}

void Tab::add_place(std::string Name, std::string URI,int iter) {
  Places->add(Name.c_str());
  browser_icon(iter,URI,Places);
  PLACES.push_back(URI);
}

void Tab::change_type() {
  std::string directory=CurrentDirectory;;
  if(TYPE==0)
    directory=FileGrid->Directory;
    
  
  clear();
  
  begin();
  user_data((void*)(this));
  color((Fl_Color)51);
  const char * h = getenv("HOME");
  if(h!=NULL)
  {
    HOME=h;
    HOME+="/";
  }
  else
  {
    HOME="/";
    XDG_CONFIG_HOME="";
  }
  const char * x = getenv("XDG_CONFIG_HOME");
  if(x != NULL)
    XDG_CONFIG_HOME=x;
  else
    XDG_CONFIG_HOME=HOME+=".config";
  
  
  if(h!=NULL)
  {
    if(directory.compare("")==0)
    {
      directory=h;
      directory+="/";
    }
  }
  if(TYPE==0)
  {
    FileBrowser = new File_List_Browser(165, 95, 375, 350);
    FileBrowser->box(FL_FLAT_BOX);
    FileBrowser->selection_color((Fl_Color)80);
    FileBrowser->type(2);
    FileBrowser->Picker=f_cb;
    Fl_Group::current()->resizable(FileBrowser);
  }
  else
  {
    FileGrid = new Grid(directory,165, 95, 375, 350);
    Fl_Group::current()->resizable(FileGrid);
  }
  
  Places = new Fl_Browser(10, 95, 150, 90);
  Places->box(FL_FLAT_BOX);
  Places->type(2);
  Places->selection_color((Fl_Color)80);
  Places->callback((Fl_Callback*)p_cb);
  theme_scrollbars(Places);
  
  Bookmarks = new Fl_Browser(10, 190, 150, 250);
  Bookmarks->type(2);
  Bookmarks->box(FL_FLAT_BOX);
  Bookmarks->selection_color((Fl_Color)80);
  Bookmarks->callback((Fl_Callback*)b_cb);
  theme_scrollbars(Bookmarks);
  
  end();
  
  
  parent()->redraw();
  change_dir(directory);
  make_bookmarks();
}

void Tab::back() {
  if(HISTORY.empty())
    return;
  std::string ret = HISTORY.at(HISTORY.size()-1);
  HISTORY.pop_back();
  change_dir(ret);
  if(HISTORY.size()>1)
    HISTORY.pop_back();
}

void Tab::bookmark_icon(int line,std::string LINE) {
  browser_icon(line,LINE,Bookmarks);
}

void Tab::browser_icon(int line,std::string LINE, Fl_Browser* o) {
  //TODO eventually..
  std::string HOME_ICON="folder-home";
  std::string DOCUMENTS_ICON="folder-documents";
  std::string DOWNLOADS_ICON="folder-downloads";
  std::string MUSIC_ICON="folder-music";
  std::string PICTURES_ICON="folder-pictures";
  std::string VIDEOS_ICON="folder-video";
  std::string FOLDER_ICON="folder";
  std::string NET_FOLDER_ICON="network";
  
  if(line_contains(LINE,"Documents"))
  {
    o->icon(line,color_docs_image.copy());
  }
  else if(line_contains(LINE,"Videos"))
  {
    o->icon(line,color_videos_image.copy());
  }
  else if(line_contains(LINE,"Music"))
  {
    o->icon(line,color_music_image.copy());
  }
  else if(line_contains(LINE,"Pictures"))
  {
    o->icon(line,color_pictures_image.copy());
  }
  else if(line_contains(LINE,"Downloads"))
  {
    o->icon(line,color_downloads_image.copy());
  }
  else if(line_contains(LINE,HOME+"Desktop"))
  {
    o->icon(line,color_desktop_image.copy());
  }
  else if(line_contains(LINE,HOME+".local/share/Trash/files/"))
  {
    o->icon(line,color_trash_image.copy());
  }
  else if(LINE.compare(HOME)==0)
  {
    o->icon(line,color_home_image.copy());
  }
  else
    o->icon(line,color_folder_image.copy());
}

void Tab::change_dir(std::string dir) {
  trace("Change directory: "+CurrentDirectory);
  if(CurrentDirectory.compare("")!=0)
  {
    if(chdir(CurrentDirectory.c_str())==-1)
    {
      std::string msg=": ";
      switch(errno)
      {
        case EACCES:
          msg+="Search permission is denied for one of the components of path. (See also path_resolution(7).)";
          break;
        case EFAULT:
          msg+="path points outside your accessible address space.";
          break;
        case EIO:
          msg+="An I/O error occurred.";
          break;
        case ELOOP:
          msg+="Too many symbolic links were encountered in resolving path.";
          break;
        case ENAMETOOLONG:
          msg+="path is too long.";
          break;
        case ENOENT:
          msg+="The file does not exist.";
          break;
        case ENOMEM:
          msg+="Insufficient kernel memory was available.";
          break;
        case ENOTDIR:
          msg+="A component of path is not a directory";
          break;
        case EBADF:
          msg+="fd is not a valid file descriptor";
          break;
        default:
          msg=" an unspecified error was returned";
      }
      trace("Failed to change to current directory"+msg);
    }
  }
  
  if(dir.compare("")==0)
    return;
  
  unsigned int finder = dir.find("file://");
  if(finder == 0)
  {
    dir = dir.erase(0,7);
  }
  finder = dir.find("sftp://");
  if(finder == 0)
  {
    dir = dir.erase(0,7);
    //TODO open sftp directory
  }
  
  if(CurrentDirectory.compare(dir)==0)
    return;
  
  char Out[FL_PATH_MAX];
  
  fl_filename_expand(Out, sizeof(Out), dir.c_str());
  dir=Out;
  
  char out[FL_PATH_MAX];
  std::string tmpDIR=dir;
  
  UserInterface * ui = (UserInterface *) user_data();
  
  if(fl_filename_absolute(out, sizeof(out), dir.c_str() ) )
    tmpDIR=out;
  if(fl_filename_isdir(tmpDIR.c_str()))
  {
    trace("change to:"+tmpDIR);
    CurrentDirectory = tmpDIR;
    HISTORY.push_back(CurrentDirectory);
    if(TYPE==0)
      FileBrowser->load(CurrentDirectory.c_str());
    else
      FileGrid->load(CurrentDirectory.c_str());
    copy_label(CurrentDirectory.c_str());
    ui->barinput->value(CurrentDirectory.c_str());
    ui->CURRENT_DIR=CurrentDirectory;
  }
  else
  {
    trace(tmpDIR+" is not a directory");
    char msg[512];
    tmpDIR="file://"+tmpDIR;
    if(!fl_open_uri(tmpDIR.c_str(),msg,sizeof(msg)))
    {
      trace(msg);
      fl_alert("%s",msg);
    }
  }
  ui->TABS->redraw();
}

void Tab::b_cb(Fl_Widget * o, void* v) {
  ((Tab *) (o->parent()))->pick_bookmark();
}

void Tab::f_cb(Fl_Widget * o) {
  ((Tab *) (o->parent()))->pick_selected();
}

void Tab::home() {
  change_dir(HOME);
}

bool Tab::line_contains(std::string line, std::string item) {
  unsigned int homeLength = HOME.length();
  unsigned int length = line.length();
  unsigned int itemLength = item.length();
  std::string tmp = "/"+item+"/";
  if(line.compare(item)==0)
    return true;
  if(line.find(tmp,homeLength)<length)
  {
    return true;
  }
  tmp = "/"+item;
  itemLength = tmp.length();
  if(line.find(tmp,homeLength)==(length-itemLength))
  {
    return true;
  }
  
  return false;
}

void Tab::line_icon(Fl_Browser* o, std::string icon) {
  //todo
  //o->icon(iter,color_folder_image.copy());
}

void Tab::make_bookmarks() {
  trace("Make bookmarks!");
  Bookmarks->clear();
  BOOKMARKS.clear();
  if(XDG_CONFIG_HOME.compare("")!=0)
  {
    std::string bookMarks = XDG_CONFIG_HOME + "/gtk-3.0/bookmarks";
    //test_file(bookMarks)
    std::string thisLine;
    std::ifstream inputFileStream(bookMarks.c_str(), std::ifstream::in);
    int iter=1;
    if(inputFileStream.is_open())
    {
      while (getline(inputFileStream,thisLine))
      {
        std::string URI = thisLine;
        std::string  Name = thisLine;
        unsigned int find = thisLine.find(" ");
        if(find < thisLine.length())
        {
          URI = URI.substr(0,find);
          char *uri = const_cast<char *>(URI.c_str());
          fl_decode_uri(uri);
          if(uri!=NULL)
            URI=uri;
          //trace("URI="+URI);
          Name = Name.substr(find+1, std::string::npos);
          Bookmarks->add(Name.c_str());
          //TODO custom icons for music/video/etc...
          bookmark_icon(iter,URI);
          iter++;
          BOOKMARKS.push_back(URI);
        }
      }
    }
  
  }
  Bookmarks->redraw();
}

void Tab::make_places() {
  trace("make places");
  Places->clear();
  PLACES.clear();
  if(PLACES_LIST.empty())
  {
    PLACES_LIST.push_back("Home");
    PLACES_LIST.push_back("Desktop");
    PLACES_LIST.push_back("Trash");
    PLACES_LIST.push_back("Root");
  }
  int iter = 1;
  for( std::vector<std::string>::iterator it = PLACES_LIST.begin();
      it!=PLACES_LIST.end();
      ++it)
  {
    std::string curr = *it;
    if ( curr == "Home" )
      add_place("Home",HOME,iter);
    else if ( curr == "Desktop" )
      add_place("Desktop",HOME+"Desktop/",iter);
    else if ( curr == "Trash")
      add_place("Trash",HOME+".local/share/Trash/files/",iter);
    else if ( curr == "Root")
      add_place("Root","/",iter);
          
    iter++;
  }
  trace("fin make places");
}

void Tab::p_cb(Fl_Widget * o, void* v) {
  ((Tab *) (o->parent()))->pick_place();
}

void Tab::pick_bookmark() {
  int value = Bookmarks->value();
  if(value<=Bookmarks->size())
  {
    trace(Bookmarks->text(value));
    value--;
    unsigned int v = value;
    if(v<BOOKMARKS.size())
    {
      std::string t = BOOKMARKS.at(v);
      change_dir(t);
    }
  }
}

void Tab::pick_place() {
  int value = Places->value();
  if(value<=Places->size())
  {
    trace(Places->text(value));
    value--;
    unsigned int v = value;
    if(v<PLACES.size())
    {
      std::string t = PLACES.at(v);
      change_dir(t);
    }
  }
}

void Tab::pick_selected() {
  if(FileBrowser->value()<=FileBrowser->size())
  {
    const char* t = FileBrowser->text(FileBrowser->value());
    if(t==NULL)
      return;
    trace(t);
    change_dir(t);
  }
}

void Tab::up() {
  std::string T=CurrentDirectory;
  unsigned int found = T.rfind('/',(T.length()-2));
  T=T.erase(found,std::string::npos);
  change_dir(T);
}

int Tab::change_mode(std::string file, mode_t mode) {
  /*
  example:
  chmod("home/cnd/mod1", S_IRWXU|S_IRWXG|S_IROTH|S_IWOTH);
  S_IRWXU Read, write, execute/search by owner.
   S_IRUSR Read permission, owner.
   S_IWUSR Write permission, owner.
   S_IXUSR Execute/search permission, owner.
  
  S_IRWXG Read, write, execute/search by group.
   S_IRGRP Read permission, group.
   S_IWGRP Write permission, group.
   S_IXGRP Execute/search permission, group.
  
  S_IRWXO Read, write, execute/search by others.
   S_IROTH Read permission, others.
   S_IWOTH Write permission, others.
   S_IXOTH Execute/search permission, others.
  */
  errno=0;
  int ret = 0;
  try
  {
    ret = chmod(file.c_str(),mode);
    if(ret!=0)
    {
      //print errno's error to stdout
      process_errno();
    }
  }
  catch (const std::exception& e){
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...){
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
  return ret;
}

void UserInterface::cb_Close_i(Fl_Button*, void*) {
  about_win->hide();
}
void UserInterface::cb_Close(Fl_Button* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void UserInterface::cb_Exit_i(Fl_Menu_*, void*) {
  exit(0);
}
void UserInterface::cb_Exit(Fl_Menu_* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

void UserInterface::cb_Preferences_i(Fl_Menu_*, void*) {
  pref_window()->show();
}
void UserInterface::cb_Preferences(Fl_Menu_* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_Preferences_i(o,v);
}

void UserInterface::cb_Open_i(Fl_Menu_*, void*) {
  open_in_terminal();
}
void UserInterface::cb_Open(Fl_Menu_* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

void UserInterface::cb_About_i(Fl_Menu_*, void*) {
  about_window()->show();
}
void UserInterface::cb_About(Fl_Menu_* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_About_i(o,v);
}

Fl_Menu_Item UserInterface::menu_menu[] = {
 {"&File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0x4006f,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Exit", 0x40071,  (Fl_Callback*)UserInterface::cb_Exit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Edit", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Preferences", 0,  (Fl_Callback*)UserInterface::cb_Preferences, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Tool", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open in Terminal", 0xffc1,  (Fl_Callback*)UserInterface::cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0xffbe,  (Fl_Callback*)UserInterface::cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void UserInterface::cb_tab_button_i(Fl_Button*, void*) {
  add_tab(CURRENT_DIR);
}
void UserInterface::cb_tab_button(Fl_Button* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_tab_button_i(o,v);
}

void UserInterface::cb_home_button_i(Fl_Button*, void*) {
  Tab *tab = (Tab*)(TABS->value());
tab->home();
}
void UserInterface::cb_home_button(Fl_Button* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_home_button_i(o,v);
}

void UserInterface::cb_previous_button_i(Fl_Button*, void*) {
  Tab *tab = (Tab*)(TABS->value());
tab->back();
}
void UserInterface::cb_previous_button(Fl_Button* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_previous_button_i(o,v);
}

void UserInterface::cb_up_button_i(Fl_Button*, void*) {
  Tab *tab = (Tab*)(TABS->value());
tab->up();
}
void UserInterface::cb_up_button(Fl_Button* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_up_button_i(o,v);
}

void UserInterface::cb_barinput_i(Fl_Input* o, void*) {
  update(o);
}
void UserInterface::cb_barinput(Fl_Input* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_barinput_i(o,v);
}

void UserInterface::cb_TABS_i(Fl_Tabs* o, void*) {
  Tab *tab = (Tab*)(o->value());
std::string C = tab->CurrentDirectory;
barinput->value(C.c_str());
barinput->redraw();
}
void UserInterface::cb_TABS(Fl_Tabs* o, void* v) {
  ((UserInterface*)(o->parent()->user_data()))->cb_TABS_i(o,v);
}

void UserInterface::cb_handle_desktop_i(Fl_Check_Button* o, void*) {
  if(o->value())
{
  desktop_icons->show();
  desktop_image->show();
  desktop_color->show();
}
else
{
  desktop_icons->hide();
  desktop_image->hide();
  desktop_color->hide();
};
}
void UserInterface::cb_handle_desktop(Fl_Check_Button* o, void* v) {
  ((UserInterface*)(o->parent()->parent()->parent()->user_data()))->cb_handle_desktop_i(o,v);
}

UserInterface::UserInterface() {
}

Fl_Double_Window* UserInterface::about_window() {
  { about_win = new Fl_Double_Window(388, 200, "About");
    about_win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(320, 170, 65, 30, "Close");
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Button* o
    { Fl_Box* o = new Fl_Box(4, 4, 380, 160);
      o->box(FL_FLAT_BOX);
      o->color(FL_BACKGROUND2_COLOR);
      o->align(Fl_Align(FL_ALIGN_CLIP));
      Fl_Group::current()->resizable(o);
      about_text(o);
    } // Fl_Box* o
    about_win->end();
  } // Fl_Double_Window* about_win
  return about_win;
}

void UserInterface::about_text(Fl_Widget* o) {
  std::string t="Libre Software Developed for ToriOS\n Copyright 2018 GPL3\nA simple FLTK file manager";
  display_text(t,o);
}

void UserInterface::add_tab(std::string dir) {
  int y = menu->y()+TABS->y()+tab_button->y();
  int h = TABS->h();
  int w = TABS->w();
  int x = TABS->x();
  Tab *t = new Tab(dir,this,x,y,w,h);
  t->PLACES_LIST=PLACES_LIST;
  t->make_places();
  TABS->add(t);
  TABS->redraw();
  TABS->value(t);
  CURRENT_DIR=t->CurrentDirectory;
}

void UserInterface::button_style(int style) {
  if(style==0)
  {
  
  //open_button->image(open_image);
  //save_button->image(save_image);
  //new_button->image(new_image);
  //undo_button->image(undo_image);
  //zoom_in_button->image(zoom_in);
  //zoom_out_button->image(zoom_out);
  //replace_button->image(replace_image);
  //cp_button->image(copy_image);
  tab_button->labelcolor(FL_BLACK);
  home_button->image(home_image);
  previous_button->labelcolor(FL_BLACK);
  up_button->labelcolor(FL_BLACK);
  }
  else
  {
  //open_button->image(color_open_image);
  //save_button->image(color_save_image);
  //new_button->image(color_new_image);
  //undo_button->image(color_undo_image);
  //zoom_in_button->image(color_zoom_in);
  //zoom_out_button->image(color_zoom_out);
  //replace_button->image(color_replace_image);
  //cp_button->image(color_copy_image);
  //p_button->image(color_paste_image);
  //cut_button->image(color_cut_image);
  tab_button->labelcolor(FL_DARK_GREEN);
  home_button->image(color_home_image);
  previous_button->labelcolor((Fl_Color)179);
  up_button->labelcolor((Fl_Color)179);
  }
  
  //open_button->redraw();
  //save_button->redraw();
  //new_button->redraw();
  //undo_button->redraw();
  //zoom_in_button->redraw();
  //zoom_out_button->redraw();
  //replace_button->redraw();
  //cp_button->redraw();
  //p_button->redraw();
  home_button->redraw();
}

void UserInterface::change_dir(std::string dir) {
  Tab *tab = (Tab*)(TABS->value());
  std::string C = tab->CurrentDirectory;
  CURRENT_DIR = C;
  tab->copy_label(dir.c_str());
  tab->change_dir(dir.c_str());
  barinput->value(dir.c_str());
}

void UserInterface::changeWidgetImage(std::string icon_file, Fl_Widget * widget) {
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetImage::Image file is empty");
    return;
  }
  widget->align(FL_ALIGN_CENTER);
  widget->copy_label("");
  widget->image(NULL);
  widget->redraw();
  widget->label(0L);
  if(!test_file(icon_file))
  {
    trace("changeWidgetImage:: "+icon_file+" is not an Image");
    return;
  }
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetImage::Image file is empty");
    return;
  }
  
  Fl_Image* image2=widget->image();//new Fl_Image(w,h,4);
  
  if(has_file_extention_at_end(icon_file,".png"))
  {
    Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xpm"))
  {
    Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xbm"))
  {
    Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".svg"))
  {
    NSVGimage *svg_image = NULL;
    NSVGrasterizer *rast = NULL;
    unsigned char* img_data = NULL;
    int width;
    int height;
    const int depth = 4;
    svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
    if (svg_image == NULL)
    {
      trace("changeWidgetImage::Could not open SVG image:"+icon_file);
      return;
    }
    width = (int)svg_image->width;
    height = (int)svg_image->height;
    rast = nsvgCreateRasterizer();
    if (rast == NULL)
    {
      trace("changeWidgetImage::Could not init rasterizer.");
      return;
    }
    img_data = (unsigned char*)malloc(width * height * depth);
    if (img_data == NULL)
    {
      trace("changeWidgetImage::Could not alloc image buffer.\n");
      return;
    }
    nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
    Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
    image2 = image->copy();
    delete(image);
    nsvgDeleteRasterizer(rast);
    nsvgDelete(svg_image);
  }
  else if((has_file_extention_at_end(icon_file,".jpg"))||
  (has_file_extention_at_end(icon_file,".jpeg"))||
  (has_file_extention_at_end(icon_file,".face")))
  {
    Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".gif"))
  {
    Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else{return;}
  widget->show();
  //double A = (image2->h()*image2->w());
  //double newW = sqrt(A*(win->w()/win->h()));
  //double newH = A/newW;
  int newW2 = image2->w();//(int)(newW+0.5);
  int newH2 = image2->h();// (int)(newH+0.5);
  //std::cout<<"w="<<newW2<<":"<<newW<<"\nH="<<newH2<<"::"<<newH<<std::endl;
  
  widget->size(newW2,newH2);
  widget->image(image2);
  win->redraw();
  //resizeImage(widget);
}

std::vector<std::string> UserInterface::comma_vector(std::string LINE,std::vector<std::string> Vector) {
  std::string original,preComma,postComma;
  original=LINE;
  unsigned int found,finder;
  finder=original.length();
  for(found=original.find(",");found<finder;found=original.find(",")){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

std::string UserInterface::convert_num_to_string(int num) {
  std::string number;
  std::stringstream out;
  out << num;
  number = out.str();
  return number;
}

unsigned int UserInterface::convert_string_to_number(std::string num) {
  if(num.compare("")==0){return 0;}
  std::stringstream out;
  out << num;
  unsigned int integer;
  out >> integer;
  return integer;
}

std::string UserInterface::current_path(int whichPath) {
  unsigned int lastPath = 0;
  std::string result;
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  const char* path =getenv("PATH");
  std::string stringPATH;
  if(path == NULL){stringPATH = "/usr/bin";}
  else{stringPATH = path;}
  std::string::size_type firstPosition = stringPATH.find(':');
  if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
  std::string::size_type position = firstPosition;
  for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
  result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
  return result;
}

std::vector<std::string> UserInterface::delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter) {
  std::vector<std::string> Vector;
  std::string original,preComma,postComma;
  original=string_to_become_vector;
  unsigned int found,finder;
  finder=original.length();
  if(original.find(delimiter)>original.length()){
    Vector.push_back(original);
    return Vector;
  }
  for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

std::vector<std::string> UserInterface::desktop_dirs() {
  std::string envVar ="XDG_DATA_DIRS";
  std::string incasenothingexists="/usr/local/share/:/usr/share/";
  std::vector<std::string> thisPath;
  std::vector<std::string>::iterator it;
  std::string thisXDG;
  const char* datadirs=getenv(envVar.c_str());
  if (datadirs == NULL)
  {
    thisXDG=incasenothingexists;
  }
  else
  {
    thisXDG=datadirs;
  }
  unsigned int numberOfPaths;
  std::string tempXDG = thisXDG;
  unsigned int tryer=0;
  unsigned int xdgLen=0;
  xdgLen=thisXDG.length();
  for (numberOfPaths=0;tryer<xdgLen;)
  {
    tryer = tempXDG.find(":");
    tempXDG=tempXDG.erase(0,tryer+1);
    xdgLen=tempXDG.length();
    numberOfPaths++;
  }
  unsigned int lastPath = 0;
  std::string result;
  for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
  {
    if (whichPath >=1){lastPath = whichPath - 1;}
    else {lastPath = 0;}
    std::string::size_type firstPosition = thisXDG.find_first_of(':');
    std::string::size_type position = thisXDG.find(':');
    for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
    for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
    result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
    thisPath.push_back(result);    
  }
  std::sort (thisPath.begin(), thisPath.end());
  it = std::unique (thisPath.begin(), thisPath.end());
  thisPath.resize( std::distance(thisPath.begin(),it) );
  return thisPath;
}

void UserInterface::display_text(std::string text, Fl_Widget *o) {
  o->copy_label(text.c_str());
  o->redraw();
}

std::string UserInterface::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename)){trace("No file sent in: "+filename);}
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

std::string UserInterface::find_xdg_data_dir_subdir(std::string subdir) {
  std::vector<std::string> xdgDataDirs = desktop_dirs();
  std::string dirToOpen;
  for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
  it!=xdgDataDirs.end();
  ++it)
  {
    dirToOpen=*it;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
    else
    {
      dirToOpen+="/";
      dirToOpen+=subdir;
    }
    if(test_dir(dirToOpen))
    {
      if(finder+1==dirToOpen.length()){return dirToOpen;}
      else
      {
        dirToOpen+="/";
        return dirToOpen;
      }
    }
    else{trace(dirToOpen+" does not exist");}
  }
  return "";
}

std::string UserInterface::get_equal_value(std::string INTERNAL_LINE) {
  std::string subString;
  unsigned int found =INTERNAL_LINE.find("=");
  if(found < INTERNAL_LINE.length())
  {
   subString=INTERNAL_LINE.substr(found+1,std::string::npos);
   return subString;
  }
  return "";
}

std::vector<std::string> UserInterface::get_file_vector(std::string DIRECTORY,std::string file) {
  std::vector<std::string> myVector;
  if(!test_dir(DIRECTORY)){return myVector;}
  if(DIRECTORY.compare("")==0){return myVector;}
  if(file.compare("")==0){return myVector;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(DIRECTORY.c_str());
  if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        unsigned int findIT = fullpath.find(file);
        if(findIT<=fullpath.length()){myVector.push_back(fullpath);}
  
      }
      if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
        std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          std::string temp=fullpath+file;
          myVector.push_back(temp);
        }
      }
    }
  }
  myVector=sort_array(myVector);
  return myVector;
}

unsigned int UserInterface::get_fl_color(XColor *c) {
  int red = (int)c->red>>8;
  int green = (int)c->green>>8;
  int blue = (int)c->blue>>8;
  //std::cout<<"r="<<red<<" g="<<green<<" b="<<blue<<std::endl;
  char tmp[8];
  std::snprintf(tmp, sizeof(tmp), "%02x%02x%02x", red, green, blue);
  std::string output = tmp;
  output="0x"+output+"00";
  return strtoul(output.c_str(),0,16);
}

std::string UserInterface::get_line_with_delim(std::string filename, std::string line,std::string delim) {
  if(line.compare("")==0){return "";}
  if(filename.compare("")==0){return "";}
  if(!test_file(filename)){trace("get_line_with_delim::No file sent in\n"+filename+","+line);}
  std::string thisLine;
  std::string subString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  std::string hash="#";
  std::string itemToFind=line+delim;
  unsigned int len=itemToFind.length();
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(thisLine.find(hash)<=1){}
      else
      {
        unsigned int found=thisLine.find(itemToFind);
        if(found<thisLine.length())
        {
          found+=len;
          subString=thisLine.substr(found,std::string::npos);
          return subString;
        }
      }
    }
  }
  return "";
}

std::string UserInterface::get_line_with_equal(std::string filename, std::string line) {
  return get_line_with_delim(filename,line,"=");
}

int UserInterface::getProcIdByName(std::string procName) {
  int pid = -1;
  if(procName.compare("")==0){return -1;}
  // Open the /proc directory
  DIR *dp = opendir("/proc");
  if (dp != NULL)
  {
    // Enumerate all entries in directory until process found
    struct dirent *dirp;
    while (pid < 0 && (dirp = readdir(dp)))
    {
    // Skip non-numeric entries
      int id = atoi(dirp->d_name);
      if (id > 0)
      {
    // Read contents of virtual /proc/{pid}/cmdline file
        std::string cmdPath = std::string("/proc/") + dirp->d_name + "/cmdline";
        std::ifstream cmdFile(cmdPath.c_str());
        std::string cmdLine;
        getline(cmdFile, cmdLine);
        if (!cmdLine.empty())
        {
      // Keep first cmdline item which contains the program path
          size_t pos = cmdLine.find('\0');
          if (pos != std::string::npos){cmdLine = cmdLine.substr(0, pos);}
      // Keep program name only, removing the path
          pos = cmdLine.rfind('/');
          if (pos != std::string::npos){cmdLine = cmdLine.substr(pos + 1);}
      // Compare against requested process name
          if (procName == cmdLine){pid = id;}
        }
      }
    }
  }
  closedir(dp);
  std::cout<<"Process Name="<<procName<<" pid="<<pid<<std::endl;
  return pid;
}

std::string UserInterface::get_shell_for_C() {
  std::string shell=term_out("which bash");
  if(shell.compare("")==0){
    if(!test_exec(shell)){
    shell=term_out("which sh");
    if(!test_exec(shell)){return "";}
    //TODO make this work for others
    }
  }
  shell=shell+" -c '";
  return shell;
}

std::string UserInterface::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

unsigned int UserInterface::items_in_path() {
  const char* path =getenv("PATH");
  std::string::size_type pathPosition =0;
  if(path==NULL){return 1;}
  std::string stringPATH = path;
  unsigned int howmany;
  for(howmany=1;(pathPosition!=std::string::npos);howmany++)
  {
    pathPosition=stringPATH.find(':', pathPosition+1);
  }
  return howmany;
}

std::vector<std::string> UserInterface::join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB) {
  std::vector<std::string> bothVectors;
  bothVectors.reserve(vectorA.size()+vectorB.size());
  bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
  bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
  return bothVectors;
}

void UserInterface::load_file(std::string filename, Fl_Widget *o) {
  if( (filename.compare("")==0) || (!test_file(filename)) )
    return;
  display_text(file_to_string(filename),o);
}

std::string UserInterface::look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
    return "";
  
  /** if it is not a directory return empty */
  if(!test_dir(dir))
    return "";
  
  /** remove the preceding path*/
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  
  /** open the directory */
  if(mydir!=NULL){
    while ((entryPointer=readdir(mydir))!=NULL)
    {
    /** find out if it is a symlink or regular file that is not hidden*/
      if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        unsigned int findIT = fullpath.find(fileWITHOUTpath);
        if(findIT<=fullpath.length())
        {
      /** add a comma at the end if there isn't one already*/
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
          ANSWERS+=fullpath;
        }
      }
      /** find out if it is a directory that is not hidden*/
      if((entryPointer->d_type==DT_DIR)
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
          {
            ANSWERS+=",";
          }
          ANSWERS+=thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
  if(ANSWERS.compare("")!=0)
  {
    return ANSWERS;
  }
  return "";
}

std::string UserInterface::look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
  {
    trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\nMUST EXIT");
    return "";
  }
  if(!test_dir(dir))
  {
    trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\nMUST EXIT");
    return "";
  }
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  std::string finalAnswer;
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
    /** if it is a symlink or file check it */
      if(((entryPointer->d_type == DT_LNK)
        ||(entryPointer->d_type == DT_REG))
        &&(entryPointer->d_name[0]!='.'))
      {
        std::string tempFINDER="/"+fileWITHOUTpath;
        trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\nfullpath="+fullpath);
        unsigned int findIT = fullpath.find(tempFINDER);
        if(findIT<=fullpath.length())
        {
          if(entryPointer->d_type == DT_LNK)
          {
      /** if it is a symlink get the actual file */
            std::string temporary=get_symlinkpath(fullpath);
            trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\nFile="+temporary);
            if(temporary.compare("")!=0)
            {
              closedir(mydir);
              if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
              trace("look_for_first_file_in_subdirs::Symlink="+temporary);
              finalAnswer=temporary;
              return temporary;
            }
          }
          else
          {
            closedir(mydir);
            finalAnswer=fullpath;
            return fullpath;
          }
        }
      }
    /** if it is a directory look inside recursively */
      if((entryPointer->d_type==DT_DIR)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(test_file(thisAnswer))
          {
            closedir(mydir);
            finalAnswer=thisAnswer;
            return thisAnswer;
          }
        }
      }
    }
    closedir(mydir);
  }
  else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\nMUST EXIT");}
  trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
  return finalAnswer;
}

bool UserInterface::look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find) {
  for( std::vector<std::string>::iterator it = vector_to_check.begin();
  it!=vector_to_check.end();
  ++it){
    std::string tmp=*it;
    if(tmp.compare(item_to_find)==0){return true;}
  }
  return false;
}

void UserInterface::make_icon(Fl_Window *o) {
  Fl_Pixmap f(flfm_xpm);
  const Fl_Pixmap * flpad_xpm_icon = &f;
  const Fl_RGB_Image *img = new Fl_RGB_Image(flpad_xpm_icon,FL_GRAY);
  o->icon(img);
}

Fl_Double_Window* UserInterface::make_window() {
  { Fl_Double_Window* o = win = new Fl_Double_Window(540, 450, "flfm");
    win->user_data((void*)(this));
    win->when(3);
    { menu = new Fl_Menu_Bar(0, 0, 555, 25);
      menu->box(FL_FLAT_BOX);
      menu->color((Fl_Color)38);
      menu->selection_color((Fl_Color)80);
      menu->labelcolor(FL_BACKGROUND2_COLOR);
      menu->textcolor(FL_BACKGROUND2_COLOR);
      menu->menu(menu_menu);
    } // Fl_Menu_Bar* menu
    { tab_button = new Fl_Button(5, 27, 25, 25, "@+");
      tab_button->tooltip("New Tab");
      tab_button->box(FL_NO_BOX);
      tab_button->shortcut(0x2b);
      tab_button->color((Fl_Color)23);
      tab_button->callback((Fl_Callback*)cb_tab_button);
    } // Fl_Button* tab_button
    { Fl_Button* o = home_button = new Fl_Button(35, 27, 25, 25);
      home_button->tooltip("Home");
      home_button->box(FL_NO_BOX);
      home_button->shortcut(0x31);
      home_button->color((Fl_Color)23);
      home_button->callback((Fl_Callback*)cb_home_button);
      o->image(home_image);
    } // Fl_Button* home_button
    { previous_button = new Fl_Button(65, 27, 25, 25, "@<-");
      previous_button->tooltip("Press \',\' to use this");
      previous_button->box(FL_NO_BOX);
      previous_button->shortcut(0xff51);
      previous_button->color((Fl_Color)23);
      previous_button->callback((Fl_Callback*)cb_previous_button);
    } // Fl_Button* previous_button
    { up_button = new Fl_Button(95, 27, 25, 25, "@8->");
      up_button->tooltip("Press \'.\' to use this");
      up_button->box(FL_NO_BOX);
      up_button->shortcut(0xff52);
      up_button->color((Fl_Color)23);
      up_button->callback((Fl_Callback*)cb_up_button);
    } // Fl_Button* up_button
    { barinput = new Fl_Input(140, 30, 385, 30);
      barinput->box(FL_BORDER_BOX);
      barinput->selection_color((Fl_Color)80);
      barinput->callback((Fl_Callback*)cb_barinput);
    } // Fl_Input* barinput
    { TABS = new Fl_Tabs(0, 60, 540, 390);
      TABS->box(FL_BORDER_BOX);
      TABS->color((Fl_Color)46);
      TABS->selection_color((Fl_Color)51);
      TABS->callback((Fl_Callback*)cb_TABS);
      add_tab();
      button_style(1);
      TABS->end();
    } // Fl_Tabs* TABS
    make_icon(o);
    win->xclass("flfm");
    win->end();
    win->resizable(win);
  } // Fl_Double_Window* win
  return win;
}

bool UserInterface::program_is_running(std::string program_line) {
  if(program_line.compare("")==0){return false;}
  int pid=getProcIdByName(program_line);
  if(pid>0){return true;}
  std::string pgrepProg=term_out("which pgrep");
  if(pgrepProg.compare("")==0)
  {
    //TODO: make a way for this to still check...
    return false;
  }
    //std::cout<<"pgrep is "+pgrepProg<<std::endl;
  std::string shell=get_shell_for_C();
  if(shell.compare("")==0)return false;
    //std::cout<<"Using shell command="+shell<<std::endl;
  std::string processline=program_line;
  std::string pgrep = shell + " "+pgrepProg+" "+program_line+ "'";
    //std::cout<<"Total command to run:\n"+pgrep<<std::endl;
  std::string returnVal=term_out(pgrep);
  if(returnVal.compare("")==0){return false;}
  return true;
}

std::string UserInterface::remove_cruft(std::string StringInput, std::string CruftToRemove) {
  if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
  unsigned int found=0;
  unsigned int cruftLength=CruftToRemove.length();
  found=StringInput.find(CruftToRemove);
  if(found>StringInput.length()){return StringInput;}
  std::string temp=StringInput;
  temp=temp.erase(0,found+cruftLength);
  if(temp.compare("")!=0){return temp;}
  std::string temp2=StringInput;
  temp2=temp2.erase(found,std::string::npos);
  if(temp2.compare("")!=0){return temp2;}
  trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
  return StringInput;
}

int UserInterface::run_a_program_in_background(std::string program) {
  std::string shell=get_shell_for_C();
  program += " &disown";
  if(shell.compare("")!=0){
    shell+=program;
    shell+="'";
  }
  else{shell=program;}
  trace("run_program_in_background::"+shell);
  return system(shell.c_str());
}

int UserInterface::run(std::string program) {
  std::string shell=get_shell_for_C();
  if(shell.compare("")!=0)
  {
    shell+=program;
    shell+="'";
  }
  else{shell=program;}
  trace("run_program::"+shell);
  return system(shell.c_str());
}

void* UserInterface::run_in_bg(void *userdata) {
  while(true){
  printf("Hello, World!\n");
  }
}

std::string UserInterface::sed_i(std::string input, std::string remove, std::string replace) {
  unsigned int xmlfix=0;
  unsigned int oldFind=0;
  unsigned int length=input.length();
  unsigned int removeLength=remove.length();
  std::string modinput=input;
  while(modinput.find(remove,oldFind)<length)
  {
    xmlfix = modinput.find(remove,oldFind);
    oldFind=xmlfix+replace.length();
    std::string tempPRE,tempPOST,temp;
    if(xmlfix<length)
    {
      temp=modinput;
      tempPOST=modinput;
      tempPRE = temp.erase(xmlfix,std::string::npos);
      tempPOST = modinput.erase(0,xmlfix+removeLength);
      modinput = tempPRE + replace + tempPOST;
      length=modinput.length();
    }
  }
  return modinput;
}

std::vector<std::string> UserInterface::sort_array(std::vector<std::string> vector_to_sort) {
  std::vector<std::string>::iterator it;
  std::sort (vector_to_sort.begin(), vector_to_sort.end());
  it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
  vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
  return vector_to_sort;
}

bool UserInterface::test_exec(std::string execToTest) {
  if(execToTest.compare("")==0){return false;}
  /** the list of directories it might check*/
  /** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
  std::string stringEXEC;
  std:: string testPATH, testExec;
  bool result = false;
  unsigned int numofpaths = items_in_path();
  for (unsigned int i = 1; i <= numofpaths; i++)
  {
    stringEXEC = execToTest;
    testPATH = current_path(i);
    stringEXEC = testPATH + "/" + stringEXEC;
    if(test_file(stringEXEC.c_str())){return true;}
  }
  return result;
}

std::string UserInterface::test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check) {
  if(fileWithNOPATH.compare("")==0){return "";}
  std::string filePathRemoved=fileWithNOPATH;
  unsigned int found=filePathRemoved.rfind('/');
  trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
  if(found<filePathRemoved.length())
  {
    unsigned int len=filePathRemoved.length()-found;
    filePathRemoved=filePathRemoved.erase(0,len);
  }
  for( std::vector<std::string>::iterator it = directories_to_check.begin();
    it!=directories_to_check.end();
    ++it)
  {
    std::string dirToOpen=*it;
    std::string result=dirToOpen;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
    else
    {
      result+="/";
      result+=filePathRemoved;
    }
    if(test_file(result))
    {
      trace("test_file_in_vector_path::FOUND="+result);
      return result;
    }
    else
    {
      std::string tmp=result;
      tmp=get_symlinkpath(tmp);
      if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
    }
  }
  return "";
}

std::string UserInterface::term_out(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  std::string result="";
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
    pclose(command_p);
  }
  else{ return "";}
  if (result.compare("")==0){return "";}
  int end = result.length();
  if((end-1) == 0){return "";}
  if((end) == 0){return "";}
  return result.erase(end-1,1);
}

void UserInterface::open_cb(Fl_Widget *o, void *) {
}

void UserInterface::update(Fl_Input *o) {
  const char* curr = o->value();
  if(curr==NULL)
    return;
  Tab *tab = (Tab*)(TABS->value());
  std::string C = tab->CurrentDirectory;
  tab->copy_label(curr);
  tab->change_dir(curr);
  barinput->value(curr);
}

bool UserInterface::test_dir(std::string dirToTest) {
  if(dirToTest.compare("")==0){return false;}
  DIR *dir = NULL;
  dir = opendir(dirToTest.c_str());
  if (dir!=NULL)
  {
    closedir(dir);
    return true;
  }
  return false;
}

void UserInterface::open_in_terminal() {
  Tab *tab = (Tab*)(TABS->value());
  const char* path=tab->label();
  if(path==NULL)
    return;
  const char* list[]={"x-terminal-emulator","sakura","lxterm","xterm","roxterm","terminator"};
  for(int i = 0;i<5;i++)
  {
    const char* I = list[i];
    if(test_exec(I))
    {
      std::string tt=I;
      tt+=" ";
      tt+=path;
      run_a_program_in_background(tt);
      return;
    }
  }
}

Fl_Double_Window* UserInterface::pref_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(370, 340);
    w = o;
    o->user_data((void*)(this));
    { Fl_Tabs* o = new Fl_Tabs(-5, 0, 375, 340);
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)46);
      o->selection_color((Fl_Color)51);
      { Fl_Group* o = new Fl_Group(-5, 25, 375, 315, "General");
        o->color((Fl_Color)51);
        o->selection_color((Fl_Color)46);
        o->hide();
        { Fl_Check_Button* o = new Fl_Check_Button(10, 35, 25, 25, "Move deleted files to trash");
          o->tooltip("Store deleted files in user\'s Trash folder, rather than removing them comple\
tely");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color(FL_BACKGROUND2_COLOR);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(10, 59, 220, 25, "Confirm before deleting");
          o->tooltip("Show pop-up to confirm delete");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color(FL_BACKGROUND2_COLOR);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(10, 82, 25, 25, "Show Grid instead of File List");
          o->tooltip("Show a grid of icons, rather than a list");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color(FL_BACKGROUND2_COLOR);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { handle_desktop = new Fl_Check_Button(10, 105, 220, 25, "Handle Desktop");
          handle_desktop->tooltip("Draw the desktop background, and icons");
          handle_desktop->down_box(FL_GTK_DOWN_BOX);
          handle_desktop->color(FL_BACKGROUND2_COLOR);
          handle_desktop->selection_color(FL_GREEN);
          handle_desktop->callback((Fl_Callback*)cb_handle_desktop);
        } // Fl_Check_Button* handle_desktop
        { Fl_Button* o = desktop_image = new Fl_Button(40, 130, 65, 30, "Image");
          desktop_image->tooltip("Background Image");
          desktop_image->box(FL_FLAT_BOX);
          desktop_image->down_box(FL_FLAT_BOX);
          desktop_image->color((Fl_Color)43);
          desktop_image->selection_color((Fl_Color)22);
          desktop_image->labelcolor(FL_BACKGROUND2_COLOR);
          if(!handle_desktop->value())o->hide();
        } // Fl_Button* desktop_image
        { Fl_Button* o = desktop_color = new Fl_Button(40, 165, 65, 30, "Color");
          desktop_color->tooltip("Background Color");
          desktop_color->box(FL_FLAT_BOX);
          desktop_color->down_box(FL_FLAT_BOX);
          desktop_color->color((Fl_Color)43);
          desktop_color->selection_color((Fl_Color)22);
          desktop_color->labelcolor(FL_BACKGROUND2_COLOR);
          if(!handle_desktop->value())o->hide();
        } // Fl_Button* desktop_color
        { Fl_Check_Button* o = desktop_icons = new Fl_Check_Button(40, 200, 165, 25, "Show Desktop Icons");
          desktop_icons->tooltip("Show icons (from Desktop folder) on the desktop");
          desktop_icons->down_box(FL_GTK_DOWN_BOX);
          desktop_icons->color(FL_BACKGROUND2_COLOR);
          desktop_icons->selection_color(FL_GREEN);
          if(!handle_desktop->value())o->hide();
        } // Fl_Check_Button* desktop_icons
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(0, 25, 370, 315, "Places");
        o->color((Fl_Color)51);
        o->selection_color((Fl_Color)46);
        { Fl_Check_Button* o = new Fl_Check_Button(10, 35, 70, 25, "Home");
          o->tooltip("Your personal folder");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color((Fl_Color)55);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(10, 60, 85, 25, "Desktop");
          o->tooltip("Your desktop folder");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color((Fl_Color)55);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(10, 85, 85, 25, "Trash");
          o->tooltip("Your Trash folder");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color((Fl_Color)55);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        { Fl_Check_Button* o = new Fl_Check_Button(10, 110, 65, 25, "Root");
          o->tooltip("The system\'s root filesystem folder \'/\'");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color((Fl_Color)55);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(0, 25, 370, 315, "Removable Media");
        o->color((Fl_Color)51);
        o->selection_color((Fl_Color)46);
        o->hide();
        { Fl_Check_Button* o = new Fl_Check_Button(20, 45, 260, 25, "Automatically show new devices");
          o->tooltip("Automatically mount media");
          o->down_box(FL_GTK_DOWN_BOX);
          o->color((Fl_Color)55);
          o->selection_color(FL_GREEN);
        } // Fl_Check_Button* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Tabs* o
    o->end();
  } // Fl_Double_Window* o
  return w;
}

void UserInterface::make_popup(Fl_Widget *o) {
  Fl_Menu_Item rclick_menu[] = {
    { "&Open",  0, handle_menu, (void*)1 },
    { "Open &With",  0, handle_menu, (void*)2 },
    { "&Copy",  0, handle_menu, (void*)3 },
    { "&Paste",  0, handle_menu, (void*)4 },
    { "Move to &Trash",  0, handle_menu, (void*)5 },
    { "&Rename",  0, handle_menu, (void*)6 },
    { "Properties",  0, handle_menu, (void*)7 },
    { 0 }
  };
  
  UserInterface* ui = ((UserInterface*)o->user_data());
  
  const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, ui->menu);
  if ( m )
  {  
    m->do_callback(o, m->user_data());
  }
  return;
}

void UserInterface::handle_menu(Fl_Widget *w, void *v) {
  if(!w || !v)
    return;
  UserInterface* ui = ((UserInterface*)w->user_data());
  switch(static_cast<int>(reinterpret_cast<long>(v)))
  {
    case 1: //Open
      //ui->open_cb(w);
      break;
    case 2://Open With
      //ui->cut_cb();
      break;
    case 3://Copy
      //ui->copy_cb();
      break;
    case 4: //PASTE
      //ui->copy_cb(out);
      break;
    case 5: //Move to Trash
      //ui->move_cb(in,out);
      break;
    case 6: //Rename
      //ui->move_cb(in,out);
      break;
    case 7: //Properties
      
      break;
  }
}

Desktop::Desktop(std::string BG, int type) {
  Background=BG;
  Type=type;
  set_background(Background,Type);
  make_desktop()->show();
}

Fl_Double_Window* Desktop::make_desktop() {
  { Fl_Double_Window* o = DESKTOP = new Fl_Double_Window(100, 100);
    DESKTOP->user_data((void*)(this));
    o->resize(0,0,Fl::w(),Fl::h());
    configure();
    DESKTOP->end();
  } // Fl_Double_Window* DESKTOP
  return DESKTOP;
}

void Desktop::configure() {
  printf("Hello, World!\n");
}

void Desktop::set_background(std::string icon_file, int type) {
  if(type>0)
    trace("TODO... type...");
  
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetImage::Image file is empty");
    return;
  }
  DESKTOP->align(FL_ALIGN_CENTER);
  DESKTOP->copy_label("");
  DESKTOP->image(NULL);
  DESKTOP->redraw();
  DESKTOP->label(0L);
  if(!test_file(icon_file))
  {
    trace("changeWidgetImage:: "+icon_file+" is not an Image");
    return;
  }
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetImage::Image file is empty");
    return;
  }
  
  Fl_Image* image2=DESKTOP->image();//new Fl_Image(w,h,4);
  
  if(has_file_extention_at_end(icon_file,".png"))
  {
    Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xpm"))
  {
    Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xbm"))
  {
    Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".svg"))
  {
    NSVGimage *svg_image = NULL;
    NSVGrasterizer *rast = NULL;
    unsigned char* img_data = NULL;
    int width;
    int height;
    const int depth = 4;
    svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
    if (svg_image == NULL)
    {
      trace("changeWidgetImage::Could not open SVG image:"+icon_file);
      return;
    }
    width = (int)svg_image->width;
    height = (int)svg_image->height;
    rast = nsvgCreateRasterizer();
    if (rast == NULL)
    {
      trace("changeWidgetImage::Could not init rasterizer.");
      return;
    }
    img_data = (unsigned char*)malloc(width * height * depth);
    if (img_data == NULL)
    {
      trace("changeWidgetImage::Could not alloc image buffer.\n");
      return;
    }
    nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
    Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
    image2 = image->copy();
    delete(image);
    nsvgDeleteRasterizer(rast);
    nsvgDelete(svg_image);
  }
  else if((has_file_extention_at_end(icon_file,".jpg"))||
  (has_file_extention_at_end(icon_file,".jpeg"))||
  (has_file_extention_at_end(icon_file,".face")))
  {
    Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".gif"))
  {
    Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
    image2 = image->copy();
    delete(image);
  }
  else{return;}
  DESKTOP->show();
  
  //widget->size(newW2,newH2);
  DESKTOP->image(image2);
  DESKTOP->redraw();
}

int main(int argc, char *argv[]) {
  Fl::visual(FL_RGB);
  Fl_File_Icon::load_system_icons();
  TYPE=0;
  FOREGROUND_COLOR = (Fl_Color)17;
  BACKGROUND_COLOR = (Fl_Color)38;
  
  UserInterface* ui = new UserInterface;
  try
  {
    ui->make_window()->show();
    if (argc > 1)
    {
      char* charchar1 = argv[1];
      fl_decode_uri(charchar1);
      trace(charchar1);
      std::string fname = charchar1;
      unsigned int URI  = fname.find("file:///");
      if(URI==0)
      {
        fname = fname.substr(URI+7,std::string::npos);
      }
      ui->change_dir(fname);
    }
  
    return Fl::run();
  }
  catch (const std::exception& e){
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...){
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
}

void trace(std::string msg) {
  std::cout<<msg<<std::endl;
}

bool extension(std::string ext,...) {
  va_list args;
  va_start(args,ext);
  const char* list = va_arg(args,const char*);
  while (list!=NULL)
  {
    std::cout << __PRETTY_FUNCTION__ <<":"<<list<<std::endl;
    if(ext.compare(list)==0)
    {
      va_end(args);
      return true;
    }
  }
  va_end(args);
  return false;
}

std::string get_directory_from_filename(std::string input) {
  std::string filename = input;
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder+1,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

bool has_file_extention_at_end(std::string filename,std::string extention) {
  std::string extention_check;
  std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
  std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
  unsigned int found=filename.find(extention);
  unsigned int ext_len=extention.length();
  unsigned int file_len=filename.length();
  if(found<file_len)
  {
    if(found==(file_len-ext_len))
    {
      return true;
    }
  }
  return false;
}

bool test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

void theme_scrollbars(Fl_Browser* o) {
  trace("theme browser scroll bars");
  o->box(FL_BORDER_BOX);
  o->scrollbar.slider(FL_BORDER_BOX);
  o->hscrollbar.slider(FL_BORDER_BOX);
  
  o->hscrollbar.labelcolor(BACKGROUND_COLOR);
  o->hscrollbar.color(BACKGROUND_COLOR);
  o->hscrollbar.selection_color(FOREGROUND_COLOR);
  
  o->scrollbar.labelcolor(BACKGROUND_COLOR);
  o->scrollbar.color(BACKGROUND_COLOR);
  o->scrollbar.selection_color(FOREGROUND_COLOR);
}

void theme_scrollbars(Fl_Scroll* o) {
  trace("theme Scroll scroll bars");
  o->box(FL_BORDER_BOX);
  o->scrollbar.slider(FL_BORDER_BOX);
  o->hscrollbar.slider(FL_BORDER_BOX);
  
  o->hscrollbar.labelcolor(BACKGROUND_COLOR);
  o->hscrollbar.color(BACKGROUND_COLOR);
  o->hscrollbar.selection_color(FOREGROUND_COLOR);
  
  o->scrollbar.labelcolor(BACKGROUND_COLOR);
  o->scrollbar.color(BACKGROUND_COLOR);
  o->scrollbar.selection_color(FOREGROUND_COLOR);
}

void process_errno() {
  switch(errno)
  {
    case EACCES:
      trace("Search permission is denied on a component of the path prefix.");
      break;
    case ELOOP:
      trace("A loop exists in symbolic links encountered during resolution of the path argument./nOR.. More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.");
      break;
    case ENAMETOOLONG:
      trace("The length of the path argument exceeds {PATH_MAX} or a pathname component is longer than {NAME_MAX}.\nOR As a result of encountering a symbolic link in resolution of the path argument, the length of the substituted pathname strings exceeded {PATH_MAX}.");
      break;
    case ENOTDIR:
      trace("A component of the path prefix is not a directory.");
      break;
    case ENOENT:
      trace("A component of path does not name an existing file or path is an empty string.");
      break;
    case EPERM:
      trace("The effective user ID does not match the owner of the file and the process does not have appropriate privileges.");
      break;
    case EROFS:
      trace("The named file resides on a read-only file system.");
      break;
    case EINTR:
      trace("A signal was caught during execution of the function.");
      break;
    case EINVAL:
      trace("The value of the mode argument is invalid.");
      break;
    case EIO:
      trace("An error occurred while reading from the file system.");
      break;
    case EOVERFLOW:
      trace("The file size in bytes or the number of blocks allocated to the file or the file serial number cannot be represented correctly in the structure pointed to by buf.");
      break;
  }
}
