# data file for the Fltk User Interface Designer (fluid)
version 1.0303 
header_name {.h} 
code_name {.cxx}
decl {\#include "../include/toolbar_icons.h"} {private global
} 

decl {\#include <cstdarg>} {public global
} 

decl {//\#include <magic.h>} {public global
} 

decl {\#include <X11/Xlib.h>} {public global
} 

decl {\#include <FL/Fl_Menu_Window.H>} {public global
} 

decl {\#include <FL/filename.H>} {public global
} 

decl {\#include <FL/Fl_File_Chooser.H>} {public global
} 

decl {\#include <FL/Fl_Scroll.H>} {public global
} 

decl {\#include <FL/Fl_Pack.H>} {public global
} 

decl {\#include <FL/Fl_JPEG_Image.H>
\#include <FL/Fl_PNG_Image.H>
\#include <FL/Fl_XBM_Image.H>
\#include <FL/Fl_XPM_Image.H>
\#include <FL/Fl_GIF_Image.H>} {public global
} 

decl {\#include <stdexcept>
\#include <string>
\#include <iostream>
\#include <fstream>
\#include <vector>
\#include <sys/stat.h>
\#include <sys/types.h>
\#include <fcntl.h>
\#include <sys/sendfile.h>  // sendfile
\#include <algorithm>
\#include <float.h>
\#include <sstream>
\#include <float.h>
\#include <dirent.h>
\#include <sys/stat.h>
\#include <langinfo.h>
\#include <stdlib.h>
\#include <stdio.h>
\#include <cstdlib>
\#include <fstream>
\#include <sstream>
\#include <errno.h>
\#include <locale.h>
\#include <unistd.h>
\#include <signal.h>} {public global
} 

decl {\#define NANOSVG_ALL_COLOR_KEYWORDS
\#define NANOSVG_IMPLEMENTATION
\#include "../include/nanosvg.h"
\#define NANOSVGRAST_IMPLEMENTATION
\#include "../include/nanosvgrast.h"} {private local
} 

decl {\#include <string>} {public global
} 

decl {\#include <vector>} {public global
} 

decl {int TYPE;} {public global
} 

decl {unsigned int BACKGROUND_COLOR;} {public global
} 

decl {unsigned int FOREGROUND_COLOR;} {public global
} 

decl {std::vector<std::string> m_themesVector;} {protected local
} 

decl {std::string m_gtk_theme;} {private local
} 

decl {std::vector<std::string> m_ICON_PATHS;} {protected local
} 

class Icon {: {public Fl_Button}
} {
  decl {std::string default_folder;} {public local
  }
  decl {std::string OLD_ICON;} {private local
  }
  Function {changeWidgetIcon(std::string icon_file, bool save=true)} {return_type void
  } {
    code {if(icon_file.compare("")==0)
{
  trace("changeWidgetIcon::Icon file is empty");
  return;
}
bool folder=false;
if(icon_file.compare("folder")==0)
{
  folder=true;
  if( (default_folder.compare("")!=0) && test_file(default_folder) )
  {
    icon_file=default_folder;
  }
}

if(save)
{
  if(OLD_ICON==icon_file)
    return;
  OLD_ICON=icon_file;
}
int h = this->w();
int w = this->h();
if(w>h)
  h=w;
int iconW=24;
align(FL_ALIGN_CENTER);
copy_label("");
image(NULL);
redraw();
label(0L);
if(m_ICON_PATHS.empty())
  m_ICON_PATHS=IconPaths(iconW);
std::cout<<"changeWidgetIcon:: w="<<w<<" h="<<h<<std::endl;
if(!test_file(icon_file))
{
  std::string tmp=icon_file;
  unsigned int ext=icon_file.rfind(".");
  if(ext>icon_file.length())
  {
    tmp=icon_file+".svg";
    tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
    if(tmp.compare("")==0)
    {
      tmp=icon_file+".png";
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")!=0)
      {
        trace("changeWidgetIcon::RESULT="+tmp);
        icon_file=tmp;
      }
    }
    else
    {
      trace("changeWidgetIcon::RESULT="+tmp);
      icon_file=tmp;
    }
  }
  else
  {
    tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
    if(tmp.compare("")==0)
    {
      trace("changeWidgetIcon::looking for icon file");
      tmp=look_for_icon_file(icon_file);
      
    }
    if(tmp.compare("")!=0)
    {
      icon_file=tmp;
      trace("changeWidgetIcon::RESULT="+tmp);
    }
  }
}
else
{
  trace("changeWidgetIcon::"+icon_file+" is a file!");
}

if(folder)
{
  if (default_folder.compare("")==0)
  {
     if( test_file(icon_file) )
       default_folder = icon_file;
  }
}

if(icon_file.compare("")==0)
{
  trace("changeWidgetIcon::Icon file is empty");
  return;
}

Fl_Image* image2=image();//new Fl_Image(w,h,4);

if(has_file_extention_at_end(icon_file,".png"))
{
  Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xpm"))
{
  Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xbm"))
{
  Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".svg"))
{
  NSVGimage *svg_image = NULL;
  NSVGrasterizer *rast = NULL;
  unsigned char* img_data = NULL;
  int width;
  int height;
  const int depth = 4;
  svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
  if (svg_image == NULL)
  {
    trace("changeWidgetIcon::Could not open SVG image:"+icon_file);
    return;
  }
  width = (int)svg_image->width;
  height = (int)svg_image->height;
  rast = nsvgCreateRasterizer();
  if (rast == NULL)
  {
    trace("changeWidgetIcon::Could not init rasterizer.");
    return;
  }
  img_data = (unsigned char*)malloc(width * height * depth);
  if (img_data == NULL)
  {
    trace("changeWidgetIcon::Could not alloc image buffer.\\n");
    return;
  }
  nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
  Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
  image2 = image->copy();
  delete(image);
  nsvgDeleteRasterizer(rast);
  nsvgDelete(svg_image);
}
else if((has_file_extention_at_end(icon_file,".jpg"))||
(has_file_extention_at_end(icon_file,".jpeg"))||
(has_file_extention_at_end(icon_file,".face")))
{
  Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".gif"))
{
  Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else{return;}

image(image2);
show();} {}
  }
  Function {Icon(std::string icon_file,int X,int Y,int W,int H,const char *l=0):Fl_Button(X,Y,W,H,l)} {open
  } {
    code {//changeWidgetIcon(icon_file,true);} {}
  }
  Function {comma_vector(std::string LINE,std::vector<std::string> Vector)} {return_type {std::vector<std::string>}
  } {
    code {std::string original,preComma,postComma;
original=LINE;
unsigned int found,finder;
finder=original.length();
for(found=original.find(",");found<finder;found=original.find(",")){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {convert_num_to_string(int num)} {return_type {std::string}
  } {
    code {std::string number;
std::stringstream out;
out << num;
number = out.str();
return number;} {}
  }
  Function {convert_string_to_number(std::string num)} {return_type {unsigned int}
  } {
    code {if(num.compare("")==0){return 0;}
std::stringstream out;
out << num;
unsigned int integer;
out >> integer;
return integer;} {}
  }
  Function {current_path(int whichPath)} {return_type {std::string}
  } {
    code {unsigned int lastPath = 0;
std::string result;
if (whichPath >=1){lastPath = whichPath - 1;}
else {lastPath = 0;}
const char* path =getenv("PATH");
std::string stringPATH;
if(path == NULL){stringPATH = "/usr/bin";}
else{stringPATH = path;}
std::string::size_type firstPosition = stringPATH.find(':');
if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
std::string::size_type position = firstPosition;
for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
return result;} {}
  }
  Function {delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> Vector;
std::string original,preComma,postComma;
original=string_to_become_vector;
unsigned int found,finder;
finder=original.length();
if(original.find(delimiter)>original.length()){
  Vector.push_back(original);
  return Vector;
}
for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {desktop_dirs()} {return_type {std::vector<std::string>}
  } {
    code {std::string envVar ="XDG_DATA_DIRS";
std::string incasenothingexists="/usr/local/share/:/usr/share/";
std::vector<std::string> thisPath;
std::vector<std::string>::iterator it;
std::string thisXDG;
const char* datadirs=getenv(envVar.c_str());
if (datadirs == NULL)
{
  thisXDG=incasenothingexists;
}
else
{
  thisXDG=datadirs;
}
unsigned int numberOfPaths;
std::string tempXDG = thisXDG;
unsigned int tryer=0;
unsigned int xdgLen=0;
xdgLen=thisXDG.length();
for (numberOfPaths=0;tryer<xdgLen;)
{
  tryer = tempXDG.find(":");
  tempXDG=tempXDG.erase(0,tryer+1);
  xdgLen=tempXDG.length();
  numberOfPaths++;
}
unsigned int lastPath = 0;
std::string result;
for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
{
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  std::string::size_type firstPosition = thisXDG.find_first_of(':');
  std::string::size_type position = thisXDG.find(':');
  for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
  result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
  thisPath.push_back(result);    
}
std::sort (thisPath.begin(), thisPath.end());
it = std::unique (thisPath.begin(), thisPath.end());
thisPath.resize( std::distance(thisPath.begin(),it) );
return thisPath;} {}
  }
  Function {file_to_string(std::string filename)} {return_type {std::string}
  } {
    code {if(filename.compare("")==0){return "";}
/** make sure it is actually a file */
if(!test_file(filename)){trace("No file sent in: "+filename);}
std::string thisLine;
std::string fullString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(fullString.compare("")==0){fullString=thisLine;}
    else{fullString=fullString+"\\n"+thisLine;}
  }
}
return fullString;} {}
  }
  Function {find_xdg_data_dir_subdir(std::string subdir)} {return_type {std::string}
  } {
    code {std::vector<std::string> xdgDataDirs = desktop_dirs();
std::string dirToOpen;
for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
it!=xdgDataDirs.end();
++it)
{
  dirToOpen=*it;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
  else
  {
    dirToOpen+="/";
    dirToOpen+=subdir;
  }
  if(test_dir(dirToOpen))
  {
    if(finder+1==dirToOpen.length()){return dirToOpen;}
    else
    {
      dirToOpen+="/";
      return dirToOpen;
    }
  }
  else{trace(dirToOpen+" does not exist");}
}
return "";} {}
  }
  Function {get_directory_from_filename(std::string filename)} {return_type {std::string}
  } {
    code {unsigned int finder=filename.rfind("/");
if(finder<filename.length())
{
  filename=filename.erase(finder,std::string::npos);
}
else{return "";} /**return empty if there is no directory*/
return filename;} {}
  }
  Function {get_equal_value(std::string INTERNAL_LINE)} {return_type {std::string}
  } {
    code {std::string subString;
unsigned int found =INTERNAL_LINE.find("=");
if(found < INTERNAL_LINE.length())
{
 subString=INTERNAL_LINE.substr(found+1,std::string::npos);
 return subString;
}
return "";} {}
  }
  Function {get_file_vector(std::string DIRECTORY,std::string file)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> myVector;
if(!test_dir(DIRECTORY)){return myVector;}
if(DIRECTORY.compare("")==0){return myVector;}
if(file.compare("")==0){return myVector;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(DIRECTORY.c_str());
if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      unsigned int findIT = fullpath.find(file);
      if(findIT<=fullpath.length()){myVector.push_back(fullpath);}

    }
    if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
      std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        std::string temp=fullpath+file;
        myVector.push_back(temp);
      }
    }
  }
}
myVector=sort_array(myVector);
return myVector;} {}
  }
  Function {get_gtk_icon_theme()} {return_type {std::string}
  } {
    code {if(m_gtk_theme.compare("")!=0)
  return m_gtk_theme;
std::string itemToGet="icon";
std::string defaultTheme="hicolor";
std::string gtkrc2_result, gtkrc3_result,gtk2;
if((itemToGet.compare("icon")!=0)&&(itemToGet.compare("")!=0))
{
  itemToGet="";
}
std::string item=itemToGet;
std::string GSETTINGS=term_out("which gsettings");
std::string GCONF2=term_out("which gconftool-2");
if(GSETTINGS.find("gsettings")<GSETTINGS.length())
{
  std::string temp=item;
  if(item.compare("")==0)temp="gtk";
  gtkrc3_result=term_out(GSETTINGS+" get org.gnome.desktop.interface "+temp+"-theme");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\'");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\'");
  m_gtk_theme = gtkrc3_result;
  return gtkrc3_result;
}
if(GCONF2.find("gconftool-2")<GCONF2.length())
{
  std::string temp="gtk";
  if(item.compare("")!=0)temp=item;
  gtk2=term_out(GCONF2+" --get /desktop/gnome/interface/"+temp+"_theme");
  m_gtk_theme = gtk2;
  return gtk2;
}
const char* home = getenv("HOME");
if(home==NULL){return defaultTheme;}
std::string HOME=home;
//CHECK/SET GTKRC FILES
std::string GTKRC2=HOME + "/.gtkrc-2.0";
const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
std::string XDG_CONFIG_HOME;
if (xdg_config_home!=NULL)
{
  XDG_CONFIG_HOME=xdg_config_home;
}
else
{
  XDG_CONFIG_HOME=HOME +"/.config";
}
std::string GTKRC3=XDG_CONFIG_HOME + "/gtk-3.0/settings.ini";
if(test_file(GTKRC3.c_str()))
{
  std::string temp;
  if(item.compare("")!=0)temp=item+"-";
  temp="gtk"+temp+"-theme-name=";
  gtkrc3_result=get_line_with_equal(GTKRC3,temp);
  gtkrc3_result=remove_cruft(gtkrc3_result,temp);
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\"");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\"");
  m_gtk_theme = gtkrc3_result;
  return gtkrc3_result;
}
if(test_file(GTKRC2.c_str()))
{
  std::string temp;
  if(item.compare("")!=0)temp=item+"-";
  temp="gtk"+temp+"-theme-name=";
  gtkrc2_result=get_line_with_equal(GTKRC2,temp);
  gtkrc2_result=remove_cruft(gtkrc2_result,"\\"");
  gtkrc2_result=remove_cruft(gtkrc2_result,"\\"");
  m_gtk_theme = gtkrc2_result;
  return gtkrc2_result;
}
return defaultTheme;} {}
  }
  Function {get_line_with_delim(std::string filename, std::string line,std::string delim)} {return_type {std::string}
  } {
    code {if(line.compare("")==0){return "";}
if(filename.compare("")==0){return "";}
if(!test_file(filename)){trace("get_line_with_delim::No file sent in\\n"+filename+","+line);}
std::string thisLine;
std::string subString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
std::string hash="\#";
std::string itemToFind=line+delim;
unsigned int len=itemToFind.length();
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(thisLine.find(hash)<=1){}
    else
    {
      unsigned int found=thisLine.find(itemToFind);
      if(found<thisLine.length())
      {
        found+=len;
        subString=thisLine.substr(found,std::string::npos);
        return subString;
      }
    }
  }
}
return "";} {}
  }
  Function {get_line_with_equal(std::string filename, std::string line)} {return_type {std::string}
  } {
    code {return get_line_with_delim(filename,line,"=");} {}
  }
  Function {get_shell_for_C()} {return_type {std::string}
  } {
    code {std::string shell=term_out("which bash");
if(shell.compare("")==0){
  if(!test_exec(shell)){
  shell=term_out("which sh");
  if(!test_exec(shell)){return "";}
  //TODO make this work for others
  }
}
shell=shell+" -c '";
return shell;} {}
  }
  Function {get_symlinkpath(std::string symlink)} {return_type {std::string}
  } {
    code {struct stat statinfo;
if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
{
  std::vector<char> buf(400);
  size_t len;
  do
  {
    buf.resize(buf.size() + 100);
    len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
  }
  while(buf.size() == len);
  if (len > 0)
  {
    buf[len] = '\\0';
    return (std::string(&(buf[0])));
  }
}
else
{
  return symlink;
}
return symlink;} {}
  }
  Function {has_file_extention_at_end(std::string filename,std::string extention)} {return_type bool
  } {
    code {std::string extention_check;
std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
unsigned int found=filename.find(extention);
unsigned int ext_len=extention.length();
unsigned int file_len=filename.length();
if(found<file_len)
{
  if(found==(file_len-ext_len))
  {
    return true;
  }
}
return false;} {}
  }
  Function {items_in_path()} {return_type {unsigned int}
  } {
    code {const char* path =getenv("PATH");
std::string::size_type pathPosition =0;
if(path==NULL){return 1;}
std::string stringPATH = path;
unsigned int howmany;
for(howmany=1;(pathPosition!=std::string::npos);howmany++)
{
  pathPosition=stringPATH.find(':', pathPosition+1);
}
return howmany;} {}
  }
  Function {IconPaths(int size_to_use=32)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ret;
if(m_themesVector.empty())
  m_themesVector=icon_themefiles_vector();

std::string gtk_theme=get_gtk_icon_theme();
gtk_theme=sed_i(gtk_theme,"-"," ");

trace("IconPaths::Look for this="+gtk_theme);
if(m_themesVector.empty())
{
  trace("IconPaths::Didn't find any Icon themes");
  return ret;
}
return IconPathsForTheme(gtk_theme,size_to_use);} {}
  }
  Function {IconPathsForTheme(std::string theme,int size_to_use=32)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ret;
std::string themefile;
for( std::vector<std::string>::iterator it = m_themesVector.begin();
it!=m_themesVector.end();
++it)
{
  std::string THEME=*it;
  std::string theme_name=get_line_with_equal(THEME,"Name");
  if(theme_name.compare(theme)==0)
  {
    trace("IconPathsForTheme::File="+THEME);
    ret=join_string_vectors(ret,list_icon_dirs_in_themefile(THEME,size_to_use));
    //std::reverse(ret.begin(),ret.end());
    std::string inherits=get_line_with_equal(THEME,"Inherits");
    std::vector<std::string> inheritsVec = delimiter_vector_from_string(inherits,",");

    for( std::vector<std::string>::iterator iter = inheritsVec.begin();
      iter!=inheritsVec.end();
      ++iter)
    {
      std::string item = *iter;
      ret=join_string_vectors(ret,IconPathsForTheme(item,size_to_use));
    }
  }
}
//std::reverse(ret.begin(),ret.end());
return ret;} {}
  }
  Function {icon_themefiles_vector()} {return_type {std::vector<std::string>}
  } {
    code {std::string DIRECTORY=find_xdg_data_dir_subdir("icons");
std::vector<std::string> thisISmyVector;
if(DIRECTORY.compare("")==0){trace("Icon directory NOT found");}
else{thisISmyVector=get_file_vector(DIRECTORY,"index.theme");}
if(thisISmyVector.empty()){trace("Didn't find and Icon themes");}
return thisISmyVector;} {}
  }
  Function {join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> bothVectors;
bothVectors.reserve(vectorA.size()+vectorB.size());
bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
return bothVectors;} {}
  }
  Function {list_icon_dirs_in_themefile(std::string themefile,int size_to_use)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ListOfIconDirs;
std::string SIZE_TO_USE=convert_num_to_string(size_to_use);
std::string INTERNAL_LINE;
std::string subString;
std::string basedir=get_directory_from_filename(themefile);
std::string THEME_DIR=basedir;
if(!test_file(themefile))
     return ListOfIconDirs;
std::ifstream inputFileStrem (themefile.c_str(), std::ifstream::in);
std::string INHERITS;
std::string tmpDIRi="/usr/share/pixmaps/";
if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);

tmpDIRi="/usr/share/icons/hicolor/48x48/apps/";

if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);

tmpDIRi="/usr/share/icons/hicolor/scalable/apps/";

if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);
if(inputFileStrem.is_open())
{
  std::string DIRS,MIN,MAX,SIZE,TYPE,THRESH,CONTEXT,HEADER;
  int size=0;
  int tresh=0;
  int max=0;
  int min=0;
  std::string LINE=get_equal_value(INTERNAL_LINE);
  while (getline(inputFileStrem,INTERNAL_LINE))
  {
       if(INTERNAL_LINE.find('[')<INTERNAL_LINE.length())
       {
         HEADER=INTERNAL_LINE;
         HEADER=remove_cruft(HEADER,"[");
         HEADER=remove_cruft(HEADER,"]");
         HEADER="/"+HEADER;
       }
       else if(INTERNAL_LINE.find("Inherits=")<INTERNAL_LINE.length())
       {
         INHERITS=LINE;
       }
       else if(INTERNAL_LINE.find("Directories=")<INTERNAL_LINE.length())
       {
         DIRS=LINE;
       }
       else if(INTERNAL_LINE.find("MinSize=")<INTERNAL_LINE.length())
       {
         MIN=LINE;
         min=convert_string_to_number(MIN);
       }
       else if(INTERNAL_LINE.find("MaxSize=")<INTERNAL_LINE.length())
       {
         MAX=LINE;
         max=convert_string_to_number(MAX);
       }
       else if(INTERNAL_LINE.find("Size=")<INTERNAL_LINE.length())
       {
         SIZE=LINE;
         size=convert_string_to_number(SIZE);
       }
       else if(INTERNAL_LINE.find("Type=")<INTERNAL_LINE.length())
       {
         TYPE=LINE;
       }
       else if(INTERNAL_LINE.find("Threshold=")<INTERNAL_LINE.length())
       {
         THRESH=LINE;
         tresh=convert_string_to_number(THRESH);
       }
       else if(INTERNAL_LINE.find("Context=")<INTERNAL_LINE.length())
       {
         CONTEXT=LINE;
       }
       if((CONTEXT.compare("Animations")!=0)
       &&(CONTEXT.compare("Stock")!=0)
       &&(CONTEXT.compare("Status")!=0)
       &&(CONTEXT.compare("Emblems")!=0)
       &&(CONTEXT.compare("Emotes")!=0)
       &&(CONTEXT.compare("International")!=0) )
       {
         if((SIZE.compare(SIZE_TO_USE))||
         ((tresh-size)==(size_to_use))||
         ((tresh+size)==(size_to_use)) )
         {
            if(HEADER.find(SIZE)<HEADER.length())
            {
              std::string testDIR=THEME_DIR+HEADER;
              if(test_dir(testDIR))
              {
                if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                  ListOfIconDirs.push_back(testDIR);
              }
            }
       }
       else{
            if(TYPE.compare("Scalable")==0)
            {
              if((max>=size)&&(min<=size))
              {
                std::string testDIR=THEME_DIR+HEADER;
                if(test_dir(testDIR))
                {
                     if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                       ListOfIconDirs.push_back(testDIR);
                }
              }
            }
       }
       }
     }
}
trace("list_icon_dirs_in_themefile::Done parsing themefile "+themefile);
if(INHERITS.compare("")!=0)
{
  std::string inheritThemeFileDIR=find_xdg_data_dir_subdir("icons");
  std::string inheritThemeFile=inheritThemeFileDIR;
  if(INHERITS.find(",")<INHERITS.length())
  {
    std::vector<std::string> InheritFileVector=comma_vector(INHERITS,InheritFileVector);
    std::vector<std::string> IconFileVector=list_icon_dirs_in_themefile( themefile, size_to_use);
    for( std::vector<std::string>::iterator it = InheritFileVector.begin();
       it!=InheritFileVector.end();
       ++it)
    {
       std::string thisTheme=*it;
       inheritThemeFile+=thisTheme;
       std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
       if(temp.compare("")==0)
       {
            trace("list_icon_dirs_in_themefile::Couldn't find theme file in:"+inheritThemeFile);
       }
       else{
            std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
            if(!ListOfInheritIconDirs.empty())
            {
              ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
            }
       }
       }
     }
     else
     {
       inheritThemeFile+=INHERITS;
       std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
       if(temp.compare("")==0)
       {
         trace("list_icon_dirs_in_themefileCouldn't find theme file in:"+inheritThemeFile);
       }
       else{
         std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
         if(!ListOfInheritIconDirs.empty())
         {
            ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
         }
       }
     }
}
return ListOfIconDirs;} {}
  }
  Function {look_for_icon_file(std::string fileWITHOUTpath)} {return_type {std::string}
  } {
    code {std::string dir=find_xdg_data_dir_subdir("icons");
trace("std::string look_for_icon_file(std::string "+fileWITHOUTpath+")");
std::string gtktheme=get_gtk_icon_theme();

if(dir.rfind('/')!=dir.length()-1){dir+="/";}

std::string testingDIR=dir+gtktheme;

if(testingDIR.rfind('/')!=testingDIR.length()-1){testingDIR+="/";}
if(test_dir(testingDIR)){dir=testingDIR;}

if(fileWITHOUTpath.compare("")==0)
{
  trace("look_for_icon_file::(std::string "+fileWITHOUTpath+") requires non empty variables to work\\nMUST EXIT");
  return "";
}
trace("look_for_icon_file::GTKtheme="+gtktheme+"\\nDir="+dir);
if(!test_dir(dir))
{
  trace("look_for_icon_file::"+dir+" is not a directory\\nTrying to look in icons directories");
  dir=find_xdg_data_dir_subdir("icons");
  if(!test_dir(dir))
  {
    trace("look_for_icon_file::"+dir+" is not a directory\\nMUST EXIT");
    return "";
  }
  return look_for_first_file_in_subdirs(fileWITHOUTpath,dir);
}

std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
std::string finalAnswer;

if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string fullpath=entryPointer->d_name;

    if(dir.rfind('/')!=dir.length()-1){dir+="/";}

    fullpath=dir+fullpath;

    if((entryPointer->d_type == DT_REG)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string tempFINDER="/"+fileWITHOUTpath;
      unsigned int findIT = fullpath.find(tempFINDER);
      if(findIT<=fullpath.length())
      {
        closedir(mydir);
        finalAnswer=fullpath;
        return fullpath;
      }
    }

    if((entryPointer->d_type==DT_DIR)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(test_file(thisAnswer))
        {
          closedir(mydir);
          finalAnswer=thisAnswer;
          return thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
}
else
{
  trace("look_for_icon_file::"+dir+" cannot be opened\\nMUST EXIT");
}

if(finalAnswer.compare("")!=0)
  trace("look_for_icon_file::Final Answer="+finalAnswer);

return finalAnswer;} {}
  }
  Function {look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {open return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
  return "";

/** if it is not a directory return empty */
if(!test_dir(dir))
  return "";

/** remove the preceding path*/
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}

std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());

/** open the directory */
if(mydir!=NULL){
  while ((entryPointer=readdir(mydir))!=NULL)
  {
  /** find out if it is a symlink or regular file that is not hidden*/
    if(((entryPointer->d_type == DT_LNK)
    ||(entryPointer->d_type == DT_REG))
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      unsigned int findIT = fullpath.find(fileWITHOUTpath);
      if(findIT<=fullpath.length())
      {
    /** add a comma at the end if there isn't one already*/
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
        ANSWERS+=fullpath;
      }
    }
    /** find out if it is a directory that is not hidden*/
    if((entryPointer->d_type==DT_DIR)
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
        {
          ANSWERS+=",";
        }
        ANSWERS+=thisAnswer;
      }
    }
  }
}
closedir(mydir);
if(ANSWERS.compare("")!=0)
{
  return ANSWERS;
}
return "";} {}
  }
  Function {look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
{
  trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\\nMUST EXIT");
  return "";
}
if(!test_dir(dir))
{
  trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\\nMUST EXIT");
  return "";
}
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}
std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
std::string finalAnswer;
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string fullpath=entryPointer->d_name;
    if(dir.rfind('/')!=dir.length()-1){dir+="/";}
    fullpath=dir+fullpath;
  /** if it is a symlink or file check it */
    if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
    {
      std::string tempFINDER="/"+fileWITHOUTpath;
      trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\\nfullpath="+fullpath);
      unsigned int findIT = fullpath.find(tempFINDER);
      if(findIT<=fullpath.length())
      {
        if(entryPointer->d_type == DT_LNK)
        {
    /** if it is a symlink get the actual file */
          std::string temporary=get_symlinkpath(fullpath);
          trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\\nFile="+temporary);
          if(temporary.compare("")!=0)
          {
            closedir(mydir);
            if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
            trace("look_for_first_file_in_subdirs::Symlink="+temporary);
            finalAnswer=temporary;
            return temporary;
          }
        }
        else
        {
          closedir(mydir);
          finalAnswer=fullpath;
          return fullpath;
        }
      }
    }
  /** if it is a directory look inside recursively */
    if((entryPointer->d_type==DT_DIR)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(test_file(thisAnswer))
        {
          closedir(mydir);
          finalAnswer=thisAnswer;
          return thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
}
else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\\nMUST EXIT");}
trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
return finalAnswer;} {}
  }
  Function {look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find)} {return_type bool
  } {
    code {for( std::vector<std::string>::iterator it = vector_to_check.begin();
it!=vector_to_check.end();
++it){
  std::string tmp=*it;
  if(tmp.compare(item_to_find)==0){return true;}
}
return false;} {}
  }
  Function {remove_cruft(std::string StringInput, std::string CruftToRemove)} {return_type {std::string}
  } {
    code {if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
unsigned int found=0;
unsigned int cruftLength=CruftToRemove.length();
found=StringInput.find(CruftToRemove);
if(found>StringInput.length()){return StringInput;}
std::string temp=StringInput;
temp=temp.erase(0,found+cruftLength);
if(temp.compare("")!=0){return temp;}
std::string temp2=StringInput;
temp2=temp2.erase(found,std::string::npos);
if(temp2.compare("")!=0){return temp2;}
trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
return StringInput;} {}
  }
  Function {sort_array(std::vector<std::string> vector_to_sort)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string>::iterator it;
std::sort (vector_to_sort.begin(), vector_to_sort.end());
it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
return vector_to_sort;} {}
  }
  Function {test_dir(std::string dirToTest)} {return_type bool
  } {
    code {if(dirToTest.compare("")==0){return false;}
DIR *dir = NULL;
dir = opendir(dirToTest.c_str());
if (dir!=NULL)
{
  closedir(dir);
  return true;
}
return false;} {}
  }
  Function {test_exec(std::string execToTest)} {return_type bool
  } {
    code {if(execToTest.compare("")==0){return false;}
/** the list of directories it might check*/
/** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
std::string stringEXEC;
std:: string testPATH, testExec;
bool result = false;
unsigned int numofpaths = items_in_path();
for (unsigned int i = 1; i <= numofpaths; i++)
{
  stringEXEC = execToTest;
  testPATH = current_path(i);
  stringEXEC = testPATH + "/" + stringEXEC;
  if(test_file(stringEXEC.c_str())){return true;}
}
return result;} {}
  }
  Function {test_file(std::string fileWithFullPATH)} {return_type bool
  } {
    code {if(fileWithFullPATH.compare("")==0){return false;}
std::string dir=get_directory_from_filename(fileWithFullPATH);
if(dir.compare("")==0){return false;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      if(fullpath.compare(fileWithFullPATH)==0)
      {
        closedir(mydir);
        return true;
      }
    }
  }
  closedir(mydir);
}
else{trace("could not open directory to search for "+fileWithFullPATH);}
return false;} {}
  }
  Function {test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check)} {return_type {std::string}
  } {
    code {if(fileWithNOPATH.compare("")==0){return "";}
std::string filePathRemoved=fileWithNOPATH;
unsigned int found=filePathRemoved.rfind('/');
trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
if(found<filePathRemoved.length())
{
  unsigned int len=filePathRemoved.length()-found;
  filePathRemoved=filePathRemoved.erase(0,len);
}
for( std::vector<std::string>::iterator it = directories_to_check.begin();
  it!=directories_to_check.end();
  ++it)
{
  std::string dirToOpen=*it;
  std::string result=dirToOpen;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
  else
  {
    result+="/";
    result+=filePathRemoved;
  }
  if(test_file(result))
  {
    trace("test_file_in_vector_path::FOUND="+result);
    return result;
  }
  else
  {
    std::string tmp=result;
    tmp=get_symlinkpath(tmp);
    if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
  }
}
return "";} {}
  }
  Function {term_out(std::string terminal_Command_You_Want_Output_From)} {return_type {std::string}
  } {
    code {if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
/** set a locale so this works well */
const char* LANG=getenv("LANG");
std::string LOCALE;
if(LANG==NULL)
{
  LANG=getenv("LANGUAGE");
  if(LANG!=NULL){
  std::string tmp=LANG;
  unsigned int find=tmp.find(".UTF-8");
  if(find>tmp.length()){tmp+=".UTF-8";}
  LOCALE=tmp;
  }
}
else
{
  LOCALE=LANG;
}
if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
std::string result="";
const int max_buffer = 1024;
char buffer[max_buffer];
FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
if (command_p)
{
  while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
  pclose(command_p);
}
else{ return "";}
if (result.compare("")==0){return "";}
int end = result.length();
if((end-1) == 0){return "";}
if((end) == 0){return "";}
return result.erase(end-1,1);} {}
  }
  Function {sed_i(std::string input, std::string remove, std::string replace)} {return_type {std::string}
  } {
    code {unsigned int xmlfix=0;
unsigned int oldFind=0;
unsigned int length=input.length();
unsigned int removeLength=remove.length();
std::string modinput=input;
while(modinput.find(remove,oldFind)<length)
{
  xmlfix = modinput.find(remove,oldFind);
  oldFind=xmlfix+replace.length();
  std::string tempPRE,tempPOST,temp;
  if(xmlfix<length)
  {
    temp=modinput;
    tempPOST=modinput;
    tempPRE = temp.erase(xmlfix,std::string::npos);
    tempPOST = modinput.erase(0,xmlfix+removeLength);
    modinput = tempPRE + replace + tempPOST;
    length=modinput.length();
  }
}
return modinput;} {}
  }
} 

class ContextMenu {: {public Fl_Menu_Window}
} {
  decl {Fl_Menu_Item *Menu;} {private local
  }
  decl {std::string _filename;} {private local
  }
  Function {ContextMenu(std::string Filename, int X, int Y, int W, int H, const char* L=0):Fl_Menu_Window(X,Y,W,H,L)} {open
  } {
    code {_filename=Filename;
const char* ext = fl_filename_ext(Filename.c_str());
std::string EXT;
if(ext!=NULL)
  EXT=ext;
/*
TODO build  a real full menu dependant on whatever it is...
*/
//Menu->add(""&Open",0,open_cb);
std::transform(EXT.begin(), EXT.end(), EXT.begin(), ::tolower);
if(extension(EXT,"txt"))
{}
else if(extension(EXT,"tar","gz","gzip","bz","bzip","xz","7zip"))
{}
else if(extension(EXT,"gif","bmp","ico","tiff","tga","psd","png","jpg","jpeg","xpm","xbm"))
{}
else if(extension(EXT,"ogg","mp3","wav","mp2","flac","aac","aiff","m4a","midi","xi"))
{}
else if(extension(EXT,"mp4","wmv","ogm","asf","webm","vivo","m4v","vob","divx","flv","avi","ogv","mpeg","mov"))
{}
else
{}} {}
  }
  Function {open_cb_i(Fl_Widget* o,void*)} {open return_type {static void}
  } {
    code {((ContextMenu*)o)->open_cb();} {}
  }
  Function {open_cb()} {open
  } {
    code {((Tab *) (parent()->parent()->user_data()))->change_dir(_filename);} {}
  }
} 

class Item {: {public Icon}
} {
  decl {std::string Filename;} {public local
  }
  decl {void (*Picker)(Fl_Widget*);} {public local
  }
  decl {void (*Menu)(Fl_Widget*);} {public local
  }
  Function {Item(std::string filename, int X=5, int Y=5, int W=80, int H=80, const char *L=0,std::string icon="") : Icon ("",X,Y,W,H,L)} {open
  } {
    code {box(FL_NO_BOX);
align(FL_ALIGN_INSIDE);
if(icon.compare("")==0)
  default_folder=icon;
Filename = filename;
copy_label(L);
int Wx= 0, Hx=0;
measure_label(Wx,Hx);
size(Wx,h());
tooltip(Filename.c_str());
if(fl_filename_isdir (Filename.c_str()))
{
  //changeWidgetIcon("folder",true);
  image(color_folder_image);
}
else
{
  const char* ext = fl_filename_ext(Filename.c_str());
  std::string EXT;
  if(ext!=NULL)
    EXT=ext;
  std::transform(EXT.begin(), EXT.end(), EXT.begin(), ::tolower);
//TODO MIME
/*
  const char *mime
  magic_t magic;
  magic = magic_open(MAGIC_MIME_TYPE);
  magic_load(magic, NULL);
  magic_compile(magic, NULL);
  mime = magic_file(magic, Filename.c_str());
  magic_close(magic);
  trace(mime);
*/
  image(color_file_image);
  /*
  if(extension(EXT,"txt"))
    changeWidgetIcon("application-document",true);
  else if(extension(EXT,"tar","gz","gzip","bz","bzip","xz","7zip"))
    changeWidgetIcon("application-archive",true);
  else if(extension(EXT,"gif","bmp","ico","tiff","tga","psd","png","jpg","jpeg","xpm","xbm"))
    changeWidgetIcon("application-images",true);
  else if(extension(EXT,"ogg","mp3","wav","mp2","flac","aac","aiff","m4a","midi","xi"))
    changeWidgetIcon("application-audio",true);
  else if(extension(EXT,"mp4","wmv","ogm","asf","webm","vivo","m4v","vob","divx","flv","avi","ogv","mpeg","mov"))
    changeWidgetIcon("application-video",true);
  else
    changeWidgetIcon("unknown",true);
  */
}} {}
  }
  Function {handle(int e)} {open return_type int
  } {
    code {int ret = Fl_Button::handle(e);
switch ( e )
{
  case FL_PUSH:
    switch(Fl::event_buttons())
    {
      case FL_BUTTON1:
        if(Fl::event_clicks())
        {
        trace("button 1!");
          open();
          ret=1;
        }
      case FL_BUTTON2:
        //Menu(this);
        ret = 1;
        break;
    }
    break;
} 
return ret;} {}
  }
  Function {open()} {open
  } {
    code {((Tab *) (parent()->parent()->user_data()))->change_dir(Filename);} {}
  }
} 

class Grid {open : {public Fl_Scroll}
} {
  decl {std::string Directory;} {public local
  }
  decl {int _x;} {private local
  }
  decl {int _y;} {private local
  }
  decl {int _w;} {private local
  }
  decl {std::string default_folder;} {private local
  }
  decl {int _h;} {private local
  }
  Function {Grid(std::string directory, int X=165, int Y=95, int W=375, int H=350) : Fl_Scroll (X,Y,W,H)} {open
  } {
    code {Directory=directory;
color(FL_BACKGROUND2_COLOR);
theme_scrollbars(this);
populate();} {}
  }
  Function {populate()} {open
  } {
    code {trace("populate:"+Directory);
int spacer = 5;
_w = 100;
_h = 52;
int W = _w;
_x = spacer;
_y = _x;
clear();
int lines=0;
int columns = w();
columns = (columns / (_w + spacer*2));
int column=0;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(Directory.c_str());
begin();
if(Directory.rfind('/')!=Directory.length()-1){Directory+="/";}
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string name=entryPointer->d_name;
    if( (name.compare(".")==0) || (name.compare("..")==0) )
    {
      //do nothing for this... since it means 'current directory'
    }
    else
    {
      std::string fullpath=Directory+name;
      Item *i = new Item(fullpath,_x,_y,_w,_h,name.c_str(),default_folder);
      W=i->w();
      i->show();
      if(i->default_folder.compare("")!=0)
      {
        default_folder=i->default_folder;
      }
      if(column<=columns)
      {
        _x+=(spacer+W);
      }
      else
      {
        column=0;
        lines++;
        _y+=(spacer+_h);
        _x=spacer;
      }
      column++;
    }
  }
}
else
{
 trace("Couldn't open: "+Directory);
}
end();
//std::cout<<xposition()<<","<<yposition()<<std::endl;
scrollbar.scrollvalue(0,scrollbar.slider_size(),0,lines);
hscrollbar.scrollvalue(0,hscrollbar.slider_size(),0,lines);
parent()->redraw();} {}
  }
  Function {load(std::string directory)} {open
  } {
    code {Directory=directory;
clear();
populate();} {}
  }
} 

class File_List_Browser {open : {public Fl_File_Browser}
} {
  decl {void (*Picker)(Fl_Widget*);} {public local
  }
  Function {handle(int e)} {open return_type int
  } {
    code {int ret = Fl_File_Browser::handle(e);
switch ( e )
{
  case FL_PUSH:
    switch(Fl::event_buttons())
    {
      case FL_BUTTON1:
        if(Fl::event_clicks())
        {
        trace("button 1!");
          Picker(this);
          ret=1;
        }
      case FL_BUTTON2:
        ret = 1;
        break;
    }
    break;
} 
return ret;} {}
  }
  Function {File_List_Browser(int X, int Y, int W, int H, const char *L=0) : Fl_File_Browser (X,Y,W,H,L)} {open
  } {
    code {/*
Fl_File_Icon(,Fl_File_Icon::PLAIN);
Fl_File_Icon(,Fl_File_Icon::DIRECTORY);
Fl_File_Icon(,Fl_File_Icon::PLAIN);
Fl_File_Icon(,Fl_File_Icon::DEVICE);
Fl_File_Icon(,Fl_File_Icon::FIFO);
Fl_File_Icon(,Fl_File_Icon::ANY);
*/
scrollbar.slider(FL_FLAT_BOX);
hscrollbar.slider(FL_FLAT_BOX);} {}
  }
} 

class Tab {: {public Fl_Group}
} {
  decl {Fl_Browser* Places;} {public local
  }
  decl {Fl_Browser* Bookmarks;} {public local
  }
  decl {std::vector <std::string> HISTORY;} {public local
  }
  decl {std::vector <std::string> BOOKMARKS;} {public local
  }
  decl {std::vector <std::string> PLACES;} {public local
  }
  decl {std::vector <std::string> PLACES_LIST;} {public local
  }
  decl {std::string CurrentDirectory;} {public local
  }
  decl {std::string XDG_CONFIG_HOME;} {public local
  }
  decl {std::string HOME;} {public local
  }
  decl {File_List_Browser* FileBrowser;} {public local
  }
  decl {Grid* FileGrid;} {public local
  }
  Function {Tab(std::string directory="", void *v=NULL, int X=0, int Y=80, int W=540, int H=370,const char *l="") : Fl_Group (X,Y,W,H,l)} {open
  } {
    code {trace("Add a TAB");
begin();
user_data(v);
color((Fl_Color)51);
const char * h = getenv("HOME");
if(h!=NULL)
{
  HOME=h;
  HOME+="/";
}
else
{
  HOME="/";
  XDG_CONFIG_HOME="";
}
const char * x = getenv("XDG_CONFIG_HOME");
if(x != NULL)
  XDG_CONFIG_HOME=x;
else
  XDG_CONFIG_HOME=HOME+=".config";


if(h!=NULL)
{
  if(directory.compare("")==0)
  {
    directory=h;
    directory+="/";
  }
}
if(TYPE==0)
{
  FileBrowser = new File_List_Browser(165, 95, 375, 350);
  FileBrowser->box(FL_FLAT_BOX);
  FileBrowser->selection_color((Fl_Color)80);
  FileBrowser->type(2);
  FileBrowser->Picker=f_cb;
  Fl_Group::current()->resizable(FileBrowser);
}
else
{
  FileGrid = new Grid(directory,165, 95, 375, 350);
  Fl_Group::current()->resizable(FileGrid);
}

Places = new Fl_Browser(10, 95, 150, 90);
Places->box(FL_FLAT_BOX);
Places->type(2);
Places->selection_color((Fl_Color)80);
Places->callback((Fl_Callback*)p_cb);
theme_scrollbars(Places);

Bookmarks = new Fl_Browser(10, 190, 150, 250);
Bookmarks->type(2);
Bookmarks->box(FL_FLAT_BOX);
Bookmarks->selection_color((Fl_Color)80);
Bookmarks->callback((Fl_Callback*)b_cb);
theme_scrollbars(Bookmarks);

end();


change_dir(directory);
make_bookmarks();} {}
  }
  Function {add_place(std::string Name, std::string URI,int iter)} {} {
    code {Places->add(Name.c_str());
browser_icon(iter,URI,Places);
PLACES.push_back(URI);} {}
  }
  Function {change_type()} {} {
    code {std::string directory=CurrentDirectory;;
if(TYPE==0)
  directory=FileGrid->Directory;
  

clear();

begin();
user_data((void*)(this));
color((Fl_Color)51);
const char * h = getenv("HOME");
if(h!=NULL)
{
  HOME=h;
  HOME+="/";
}
else
{
  HOME="/";
  XDG_CONFIG_HOME="";
}
const char * x = getenv("XDG_CONFIG_HOME");
if(x != NULL)
  XDG_CONFIG_HOME=x;
else
  XDG_CONFIG_HOME=HOME+=".config";


if(h!=NULL)
{
  if(directory.compare("")==0)
  {
    directory=h;
    directory+="/";
  }
}
if(TYPE==0)
{
  FileBrowser = new File_List_Browser(165, 95, 375, 350);
  FileBrowser->box(FL_FLAT_BOX);
  FileBrowser->selection_color((Fl_Color)80);
  FileBrowser->type(2);
  FileBrowser->Picker=f_cb;
  Fl_Group::current()->resizable(FileBrowser);
}
else
{
  FileGrid = new Grid(directory,165, 95, 375, 350);
  Fl_Group::current()->resizable(FileGrid);
}

Places = new Fl_Browser(10, 95, 150, 90);
Places->box(FL_FLAT_BOX);
Places->type(2);
Places->selection_color((Fl_Color)80);
Places->callback((Fl_Callback*)p_cb);
theme_scrollbars(Places);

Bookmarks = new Fl_Browser(10, 190, 150, 250);
Bookmarks->type(2);
Bookmarks->box(FL_FLAT_BOX);
Bookmarks->selection_color((Fl_Color)80);
Bookmarks->callback((Fl_Callback*)b_cb);
theme_scrollbars(Bookmarks);

end();


parent()->redraw();
change_dir(directory);
make_bookmarks();} {}
  }
  Function {back()} {} {
    code {if(HISTORY.empty())
  return;
std::string ret = HISTORY.at(HISTORY.size()-1);
HISTORY.pop_back();
change_dir(ret);
if(HISTORY.size()>1)
  HISTORY.pop_back();} {}
  }
  Function {bookmark_icon(int line,std::string LINE)} {} {
    code {browser_icon(line,LINE,Bookmarks);} {}
  }
  Function {browser_icon(int line,std::string LINE, Fl_Browser* o)} {} {
    code {//TODO eventually..
std::string HOME_ICON="folder-home";
std::string DOCUMENTS_ICON="folder-documents";
std::string DOWNLOADS_ICON="folder-downloads";
std::string MUSIC_ICON="folder-music";
std::string PICTURES_ICON="folder-pictures";
std::string VIDEOS_ICON="folder-video";
std::string FOLDER_ICON="folder";
std::string NET_FOLDER_ICON="network";

if(line_contains(LINE,"Documents"))
{
  o->icon(line,color_docs_image.copy());
}
else if(line_contains(LINE,"Videos"))
{
  o->icon(line,color_videos_image.copy());
}
else if(line_contains(LINE,"Music"))
{
  o->icon(line,color_music_image.copy());
}
else if(line_contains(LINE,"Pictures"))
{
  o->icon(line,color_pictures_image.copy());
}
else if(line_contains(LINE,"Downloads"))
{
  o->icon(line,color_downloads_image.copy());
}
else if(line_contains(LINE,HOME+"Desktop"))
{
  o->icon(line,color_desktop_image.copy());
}
else if(line_contains(LINE,HOME+".local/share/Trash/files/"))
{
  o->icon(line,color_trash_image.copy());
}
else if(LINE.compare(HOME)==0)
{
  o->icon(line,color_home_image.copy());
}
else
  o->icon(line,color_folder_image.copy());} {}
  }
  Function {change_dir(std::string dir)} {open
  } {
    code {trace("Change directory: "+CurrentDirectory);
if(CurrentDirectory.compare("")!=0)
{
  if(chdir(CurrentDirectory.c_str())==-1)
  {
    std::string msg=": ";
    switch(errno)
    {
      case EACCES:
        msg+="Search permission is denied for one of the components of path. (See also path_resolution(7).)";
        break;
      case EFAULT:
        msg+="path points outside your accessible address space.";
        break;
      case EIO:
        msg+="An I/O error occurred.";
        break;
      case ELOOP:
        msg+="Too many symbolic links were encountered in resolving path.";
        break;
      case ENAMETOOLONG:
        msg+="path is too long.";
        break;
      case ENOENT:
        msg+="The file does not exist.";
        break;
      case ENOMEM:
        msg+="Insufficient kernel memory was available.";
        break;
      case ENOTDIR:
        msg+="A component of path is not a directory";
        break;
      case EBADF:
        msg+="fd is not a valid file descriptor";
        break;
      default:
        msg=" an unspecified error was returned";
    }
    trace("Failed to change to current directory"+msg);
  }
}

if(dir.compare("")==0)
  return;

unsigned int finder = dir.find("file://");
if(finder == 0)
{
  dir = dir.erase(0,7);
}
finder = dir.find("sftp://");
if(finder == 0)
{
  dir = dir.erase(0,7);
  //TODO open sftp directory
}

if(CurrentDirectory.compare(dir)==0)
  return;

char Out[FL_PATH_MAX];

fl_filename_expand(Out, sizeof(Out), dir.c_str());
dir=Out;

char out[FL_PATH_MAX];
std::string tmpDIR=dir;
if(fl_filename_absolute(out, sizeof(out), dir.c_str() ) )
  tmpDIR=out;
if(fl_filename_isdir(tmpDIR.c_str()))
{
  trace("change to:"+tmpDIR);
  CurrentDirectory = tmpDIR;
  HISTORY.push_back(CurrentDirectory);
  if(TYPE==0)
    FileBrowser->load(CurrentDirectory.c_str());
  else
    FileGrid->load(CurrentDirectory.c_str());
  copy_label(CurrentDirectory.c_str());
  UserInterface * ui = (UserInterface *) user_data();
  ui->barinput->value(CurrentDirectory.c_str());
  //redraw();

}
else
{
  trace(tmpDIR+" is not a directory");
  char msg[512];
  tmpDIR="file://"+tmpDIR;
  if(!fl_open_uri(tmpDIR.c_str(),msg,sizeof(msg)))
  {
    trace(msg);
    fl_alert("%s",msg);
  }
}} {}
  }
  Function {b_cb(Fl_Widget * o, void* v)} {open return_type {static void}
  } {
    code {((Tab *) (o->parent()))->pick_bookmark();} {}
  }
  Function {f_cb(Fl_Widget * o)} {open return_type {static void}
  } {
    code {((Tab *) (o->parent()))->pick_selected();} {}
  }
  Function {home()} {} {
    code {change_dir(HOME);} {}
  }
  Function {line_contains(std::string line, std::string item)} {return_type bool
  } {
    code {unsigned int homeLength = HOME.length();
unsigned int length = line.length();
unsigned int itemLength = item.length();
std::string tmp = "/"+item+"/";
if(line.compare(item)==0)
  return true;
if(line.find(tmp,homeLength)<length)
{
  return true;
}
tmp = "/"+item;
itemLength = tmp.length();
if(line.find(tmp,homeLength)==(length-itemLength))
{
  return true;
}

return false;} {}
  }
  Function {line_icon(Fl_Browser* o, std::string icon)} {} {
    code {//todo
//o->icon(iter,color_folder_image.copy());} {}
  }
  Function {make_bookmarks()} {open
  } {
    code {trace("Make bookmarks!");
Bookmarks->clear();
BOOKMARKS.clear();
if(XDG_CONFIG_HOME.compare("")!=0)
{
  std::string bookMarks = XDG_CONFIG_HOME + "/gtk-3.0/bookmarks";
  //test_file(bookMarks)
  std::string thisLine;
  std::ifstream inputFileStream(bookMarks.c_str(), std::ifstream::in);
  int iter=1;
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      std::string URI = thisLine;
      std::string  Name = thisLine;
      unsigned int find = thisLine.find(" ");
      if(find < thisLine.length())
      {
        URI = URI.substr(0,find);
        char *uri = const_cast<char *>(URI.c_str());
        fl_decode_uri(uri);
        if(uri!=NULL)
          URI=uri;
        //trace("URI="+URI);
        Name = Name.substr(find+1, std::string::npos);
        Bookmarks->add(Name.c_str());
        //TODO custom icons for music/video/etc...
        bookmark_icon(iter,URI);
        iter++;
        BOOKMARKS.push_back(URI);
      }
    }
  }

}
Bookmarks->redraw();} {}
  }
  Function {make_places()} {open
  } {
    code {trace("make places");
Places->clear();
PLACES.clear();
if(PLACES_LIST.empty())
{
  PLACES_LIST.push_back("Home");
  PLACES_LIST.push_back("Desktop");
  PLACES_LIST.push_back("Trash");
  PLACES_LIST.push_back("Root");
}
int iter = 1;
for( std::vector<std::string>::iterator it = PLACES_LIST.begin();
    it!=PLACES_LIST.end();
    ++it)
{
  std::string curr = *it;
  if ( curr == "Home" )
    add_place("Home",HOME,iter);
  else if ( curr == "Desktop" )
    add_place("Desktop",HOME+"Desktop/",iter);
  else if ( curr == "Trash")
    add_place("Trash",HOME+".local/share/Trash/files/",iter);
  else if ( curr == "Root")
    add_place("Root","/",iter);
        
  iter++;
}
trace("fin make places");} {}
  }
  Function {p_cb(Fl_Widget * o, void* v)} {open return_type {static void}
  } {
    code {((Tab *) (o->parent()))->pick_place();} {}
  }
  Function {pick_bookmark()} {} {
    code {int value = Bookmarks->value();
if(value<=Bookmarks->size())
{
  trace(Bookmarks->text(value));
  value--;
  unsigned int v = value;
  if(v<BOOKMARKS.size())
  {
    std::string t = BOOKMARKS.at(v);
    change_dir(t);
  }
}} {}
  }
  Function {pick_place()} {open
  } {
    code {int value = Places->value();
if(value<=Places->size())
{
  trace(Places->text(value));
  value--;
  unsigned int v = value;
  if(v<PLACES.size())
  {
    std::string t = PLACES.at(v);
    change_dir(t);
  }
}} {}
  }
  Function {pick_selected()} {open
  } {
    code {if(FileBrowser->value()<=FileBrowser->size())
{
  const char* t = FileBrowser->text(FileBrowser->value());
  if(t==NULL)
    return;
  trace(t);
  change_dir(t);
}} {}
  }
  Function {up()} {} {
    code {std::string T=CurrentDirectory;
unsigned int found = T.rfind('/',(T.length()-2));
T=T.erase(found,std::string::npos);
change_dir(T);} {}
  }
} 

class ImageBox {: {public Fl_Box}
} {
  Function {handle(int e)} {open return_type int
  } {
    code {static int offset[2] = { 0, 0 };
int ret = Fl_Box::handle(e);
switch ( e )
{
  case FL_PUSH:
    offset[0] = x() - Fl::event_x();    // save where user clicked for dragging
    offset[1] = y() - Fl::event_y();
    return(1);
  case FL_RELEASE:
    return(1);
  case FL_DRAG:
    position(offset[0]+Fl::event_x(), offset[1]+Fl::event_y());
    this->parent()->parent()->redraw();
    return(1);
  case FL_MOUSEWHEEL:
    UserInterface *ui = (UserInterface*)this->parent()->parent()->user_data();
    if(Fl::event_dy( )>0)
    {
      //DOWN aka zoom out
      ui->zoom(true);
    }
    else if (Fl::event_dy( )<0)
    {
      ui->zoom();
    }
    
}
return(ret);} {}
  }
  Function {ImageBox(Fl_Boxtype b=FL_FLAT_BOX, int X=0, int Y=55, int W=385, int H=320, const char *l=NULL):Fl_Box(b,X,Y,W,H,l)} {open
  } {
    code {box(FL_FLAT_BOX);
color(FL_DARK3);} {}
  }
} 

class UserInterface {open
} {
  decl {ImageBox *viewer;} {protected local
  }
  decl {std::vector <std::string> PLACES_LIST;} {public local
  }
  decl {std::string CURRENT_DIR;} {protected local
  }
  decl {std::string CURRENT_FILE;} {protected local
  }
  Function {UserInterface()} {} {
    code {} {}
  }
  Function {about_window()} {} {
    Fl_Window about_win {
      label About open
      xywh {786 332 388 200} type Double hide resizable
    } {
      Fl_Button {} {
        label Close
        callback {about_win->hide();}
        xywh {320 170 65 30} box FLAT_BOX color 80 selection_color 72 labelcolor 7
      }
      Fl_Box {} {
        xywh {4 4 380 160} box FLAT_BOX color 7 align 64 resizable
        code0 {about_text(o);}
      }
    }
  }
  Function {about_text(Fl_Widget* o)} {} {
    code {std::string t="Libre Software Developed for ToriOS\\n Copyright 2018 GPL3\\nA simple FLTK file manager";
display_text(t,o);} {}
  }
  Function {add_tab(std::string dir="")} {open
  } {
    code {int y = menu->y()+TABS->y()+tab_button->y();
int h = TABS->h();
int w = TABS->w();
int x = TABS->x();
Tab *t = new Tab(dir,this,x,y,w,h);
t->PLACES_LIST=PLACES_LIST;
t->make_places();
TABS->add(t);
TABS->redraw();
TABS->value(t);} {}
  }
  Function {button_style(int style=0)} {} {
    code {if(style==0)
{

//open_button->image(open_image);
//save_button->image(save_image);
//new_button->image(new_image);
//undo_button->image(undo_image);
//zoom_in_button->image(zoom_in);
//zoom_out_button->image(zoom_out);
//replace_button->image(replace_image);
//cp_button->image(copy_image);
tab_button->labelcolor(FL_BLACK);
home_button->image(home_image);
previous_button->labelcolor(FL_BLACK);
up_button->labelcolor(FL_BLACK);
}
else
{
//open_button->image(color_open_image);
//save_button->image(color_save_image);
//new_button->image(color_new_image);
//undo_button->image(color_undo_image);
//zoom_in_button->image(color_zoom_in);
//zoom_out_button->image(color_zoom_out);
//replace_button->image(color_replace_image);
//cp_button->image(color_copy_image);
//p_button->image(color_paste_image);
//cut_button->image(color_cut_image);
tab_button->labelcolor(FL_DARK_GREEN);
home_button->image(color_home_image);
previous_button->labelcolor((Fl_Color)179);
up_button->labelcolor((Fl_Color)179);
}

//open_button->redraw();
//save_button->redraw();
//new_button->redraw();
//undo_button->redraw();
//zoom_in_button->redraw();
//zoom_out_button->redraw();
//replace_button->redraw();
//cp_button->redraw();
//p_button->redraw();
home_button->redraw();} {}
  }
  Function {changeWidgetImage(std::string icon_file, Fl_Widget * widget)} {return_type void
  } {
    code {if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}
widget->align(FL_ALIGN_CENTER);
widget->copy_label("");
widget->image(NULL);
widget->redraw();
widget->label(0L);
if(!test_file(icon_file))
{
  trace("changeWidgetImage:: "+icon_file+" is not an Image");
  return;
}
if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}

Fl_Image* image2=widget->image();//new Fl_Image(w,h,4);

if(has_file_extention_at_end(icon_file,".png"))
{
  Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xpm"))
{
  Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xbm"))
{
  Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".svg"))
{
  NSVGimage *svg_image = NULL;
  NSVGrasterizer *rast = NULL;
  unsigned char* img_data = NULL;
  int width;
  int height;
  const int depth = 4;
  svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
  if (svg_image == NULL)
  {
    trace("changeWidgetImage::Could not open SVG image:"+icon_file);
    return;
  }
  width = (int)svg_image->width;
  height = (int)svg_image->height;
  rast = nsvgCreateRasterizer();
  if (rast == NULL)
  {
    trace("changeWidgetImage::Could not init rasterizer.");
    return;
  }
  img_data = (unsigned char*)malloc(width * height * depth);
  if (img_data == NULL)
  {
    trace("changeWidgetImage::Could not alloc image buffer.\\n");
    return;
  }
  nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
  Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
  image2 = image->copy();
  delete(image);
  nsvgDeleteRasterizer(rast);
  nsvgDelete(svg_image);
}
else if((has_file_extention_at_end(icon_file,".jpg"))||
(has_file_extention_at_end(icon_file,".jpeg"))||
(has_file_extention_at_end(icon_file,".face")))
{
  Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".gif"))
{
  Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else{return;}
widget->show();
//double A = (image2->h()*image2->w());
//double newW = sqrt(A*(win->w()/win->h()));
//double newH = A/newW;
int newW2 = image2->w();//(int)(newW+0.5);
int newH2 = image2->h();// (int)(newH+0.5);
//std::cout<<"w="<<newW2<<":"<<newW<<"\\nH="<<newH2<<"::"<<newH<<std::endl;

widget->size(newW2,newH2);
widget->image(image2);
win->redraw();
//resizeImage(widget);} {}
  }
  Function {comma_vector(std::string LINE,std::vector<std::string> Vector)} {return_type {std::vector<std::string>}
  } {
    code {std::string original,preComma,postComma;
original=LINE;
unsigned int found,finder;
finder=original.length();
for(found=original.find(",");found<finder;found=original.find(",")){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {convert_num_to_string(int num)} {return_type {std::string}
  } {
    code {std::string number;
std::stringstream out;
out << num;
number = out.str();
return number;} {}
  }
  Function {convert_string_to_number(std::string num)} {return_type {unsigned int}
  } {
    code {if(num.compare("")==0){return 0;}
std::stringstream out;
out << num;
unsigned int integer;
out >> integer;
return integer;} {}
  }
  Function {current_path(int whichPath)} {return_type {std::string}
  } {
    code {unsigned int lastPath = 0;
std::string result;
if (whichPath >=1){lastPath = whichPath - 1;}
else {lastPath = 0;}
const char* path =getenv("PATH");
std::string stringPATH;
if(path == NULL){stringPATH = "/usr/bin";}
else{stringPATH = path;}
std::string::size_type firstPosition = stringPATH.find(':');
if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
std::string::size_type position = firstPosition;
for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
return result;} {}
  }
  Function {delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> Vector;
std::string original,preComma,postComma;
original=string_to_become_vector;
unsigned int found,finder;
finder=original.length();
if(original.find(delimiter)>original.length()){
  Vector.push_back(original);
  return Vector;
}
for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {desktop_dirs()} {return_type {std::vector<std::string>}
  } {
    code {std::string envVar ="XDG_DATA_DIRS";
std::string incasenothingexists="/usr/local/share/:/usr/share/";
std::vector<std::string> thisPath;
std::vector<std::string>::iterator it;
std::string thisXDG;
const char* datadirs=getenv(envVar.c_str());
if (datadirs == NULL)
{
  thisXDG=incasenothingexists;
}
else
{
  thisXDG=datadirs;
}
unsigned int numberOfPaths;
std::string tempXDG = thisXDG;
unsigned int tryer=0;
unsigned int xdgLen=0;
xdgLen=thisXDG.length();
for (numberOfPaths=0;tryer<xdgLen;)
{
  tryer = tempXDG.find(":");
  tempXDG=tempXDG.erase(0,tryer+1);
  xdgLen=tempXDG.length();
  numberOfPaths++;
}
unsigned int lastPath = 0;
std::string result;
for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
{
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  std::string::size_type firstPosition = thisXDG.find_first_of(':');
  std::string::size_type position = thisXDG.find(':');
  for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
  result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
  thisPath.push_back(result);    
}
std::sort (thisPath.begin(), thisPath.end());
it = std::unique (thisPath.begin(), thisPath.end());
thisPath.resize( std::distance(thisPath.begin(),it) );
return thisPath;} {}
  }
  Function {display_text(std::string text, Fl_Widget *o)} {} {
    code {o->copy_label(text.c_str());
o->redraw();} {}
  }
  Function {file_to_string(std::string filename)} {return_type {std::string}
  } {
    code {if(filename.compare("")==0){return "";}
/** make sure it is actually a file */
if(!test_file(filename)){trace("No file sent in: "+filename);}
std::string thisLine;
std::string fullString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(fullString.compare("")==0){fullString=thisLine;}
    else{fullString=fullString+"\\n"+thisLine;}
  }
}
return fullString;} {}
  }
  Function {find_xdg_data_dir_subdir(std::string subdir)} {return_type {std::string}
  } {
    code {std::vector<std::string> xdgDataDirs = desktop_dirs();
std::string dirToOpen;
for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
it!=xdgDataDirs.end();
++it)
{
  dirToOpen=*it;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
  else
  {
    dirToOpen+="/";
    dirToOpen+=subdir;
  }
  if(test_dir(dirToOpen))
  {
    if(finder+1==dirToOpen.length()){return dirToOpen;}
    else
    {
      dirToOpen+="/";
      return dirToOpen;
    }
  }
  else{trace(dirToOpen+" does not exist");}
}
return "";} {}
  }
  Function {get_equal_value(std::string INTERNAL_LINE)} {return_type {std::string}
  } {
    code {std::string subString;
unsigned int found =INTERNAL_LINE.find("=");
if(found < INTERNAL_LINE.length())
{
 subString=INTERNAL_LINE.substr(found+1,std::string::npos);
 return subString;
}
return "";} {}
  }
  Function {get_file_vector(std::string DIRECTORY,std::string file)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> myVector;
if(!test_dir(DIRECTORY)){return myVector;}
if(DIRECTORY.compare("")==0){return myVector;}
if(file.compare("")==0){return myVector;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(DIRECTORY.c_str());
if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      unsigned int findIT = fullpath.find(file);
      if(findIT<=fullpath.length()){myVector.push_back(fullpath);}

    }
    if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
      std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        std::string temp=fullpath+file;
        myVector.push_back(temp);
      }
    }
  }
}
myVector=sort_array(myVector);
return myVector;} {}
  }
  Function {get_fl_color(XColor *c)} {return_type {unsigned int}
  } {
    code {int red = (int)c->red>>8;
int green = (int)c->green>>8;
int blue = (int)c->blue>>8;
//std::cout<<"r="<<red<<" g="<<green<<" b="<<blue<<std::endl;
char tmp[8];
std::snprintf(tmp, sizeof(tmp), "%02x%02x%02x", red, green, blue);
std::string output = tmp;
output="0x"+output+"00";
return strtoul(output.c_str(),0,16);} {}
  }
  Function {get_line_with_delim(std::string filename, std::string line,std::string delim)} {return_type {std::string}
  } {
    code {if(line.compare("")==0){return "";}
if(filename.compare("")==0){return "";}
if(!test_file(filename)){trace("get_line_with_delim::No file sent in\\n"+filename+","+line);}
std::string thisLine;
std::string subString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
std::string hash="\#";
std::string itemToFind=line+delim;
unsigned int len=itemToFind.length();
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(thisLine.find(hash)<=1){}
    else
    {
      unsigned int found=thisLine.find(itemToFind);
      if(found<thisLine.length())
      {
        found+=len;
        subString=thisLine.substr(found,std::string::npos);
        return subString;
      }
    }
  }
}
return "";} {}
  }
  Function {get_line_with_equal(std::string filename, std::string line)} {return_type {std::string}
  } {
    code {return get_line_with_delim(filename,line,"=");} {}
  }
  Function {getProcIdByName(std::string procName)} {return_type int
  } {
    code {int pid = -1;
if(procName.compare("")==0){return -1;}
// Open the /proc directory
DIR *dp = opendir("/proc");
if (dp != NULL)
{
  // Enumerate all entries in directory until process found
  struct dirent *dirp;
  while (pid < 0 && (dirp = readdir(dp)))
  {
  // Skip non-numeric entries
    int id = atoi(dirp->d_name);
    if (id > 0)
    {
  // Read contents of virtual /proc/{pid}/cmdline file
      std::string cmdPath = std::string("/proc/") + dirp->d_name + "/cmdline";
      std::ifstream cmdFile(cmdPath.c_str());
      std::string cmdLine;
      getline(cmdFile, cmdLine);
      if (!cmdLine.empty())
      {
    // Keep first cmdline item which contains the program path
        size_t pos = cmdLine.find('\\0');
        if (pos != std::string::npos){cmdLine = cmdLine.substr(0, pos);}
    // Keep program name only, removing the path
        pos = cmdLine.rfind('/');
        if (pos != std::string::npos){cmdLine = cmdLine.substr(pos + 1);}
    // Compare against requested process name
        if (procName == cmdLine){pid = id;}
      }
    }
  }
}
closedir(dp);
std::cout<<"Process Name="<<procName<<" pid="<<pid<<std::endl;
return pid;} {}
  }
  Function {get_shell_for_C()} {return_type {std::string}
  } {
    code {std::string shell=term_out("which bash");
if(shell.compare("")==0){
  if(!test_exec(shell)){
  shell=term_out("which sh");
  if(!test_exec(shell)){return "";}
  //TODO make this work for others
  }
}
shell=shell+" -c '";
return shell;} {}
  }
  Function {get_symlinkpath(std::string symlink)} {return_type {std::string}
  } {
    code {struct stat statinfo;
if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
{
  std::vector<char> buf(400);
  size_t len;
  do
  {
    buf.resize(buf.size() + 100);
    len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
  }
  while(buf.size() == len);
  if (len > 0)
  {
    buf[len] = '\\0';
    return (std::string(&(buf[0])));
  }
}
else
{
  return symlink;
}
return symlink;} {}
  }
  Function {items_in_path()} {return_type {unsigned int}
  } {
    code {const char* path =getenv("PATH");
std::string::size_type pathPosition =0;
if(path==NULL){return 1;}
std::string stringPATH = path;
unsigned int howmany;
for(howmany=1;(pathPosition!=std::string::npos);howmany++)
{
  pathPosition=stringPATH.find(':', pathPosition+1);
}
return howmany;} {}
  }
  Function {join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> bothVectors;
bothVectors.reserve(vectorA.size()+vectorB.size());
bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
return bothVectors;} {}
  }
  Function {load_file(std::string filename, Fl_Widget *o)} {} {
    code {if( (filename.compare("")==0) || (!test_file(filename)) )
  return;
display_text(file_to_string(filename),o);} {}
  }
  Function {look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
  return "";

/** if it is not a directory return empty */
if(!test_dir(dir))
  return "";

/** remove the preceding path*/
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}

std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());

/** open the directory */
if(mydir!=NULL){
  while ((entryPointer=readdir(mydir))!=NULL)
  {
  /** find out if it is a symlink or regular file that is not hidden*/
    if(((entryPointer->d_type == DT_LNK)
    ||(entryPointer->d_type == DT_REG))
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      unsigned int findIT = fullpath.find(fileWITHOUTpath);
      if(findIT<=fullpath.length())
      {
    /** add a comma at the end if there isn't one already*/
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
        ANSWERS+=fullpath;
      }
    }
    /** find out if it is a directory that is not hidden*/
    if((entryPointer->d_type==DT_DIR)
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
        {
          ANSWERS+=",";
        }
        ANSWERS+=thisAnswer;
      }
    }
  }
}
closedir(mydir);
if(ANSWERS.compare("")!=0)
{
  return ANSWERS;
}
return "";} {}
  }
  Function {look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
{
  trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\\nMUST EXIT");
  return "";
}
if(!test_dir(dir))
{
  trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\\nMUST EXIT");
  return "";
}
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}
std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
std::string finalAnswer;
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string fullpath=entryPointer->d_name;
    if(dir.rfind('/')!=dir.length()-1){dir+="/";}
    fullpath=dir+fullpath;
  /** if it is a symlink or file check it */
    if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
    {
      std::string tempFINDER="/"+fileWITHOUTpath;
      trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\\nfullpath="+fullpath);
      unsigned int findIT = fullpath.find(tempFINDER);
      if(findIT<=fullpath.length())
      {
        if(entryPointer->d_type == DT_LNK)
        {
    /** if it is a symlink get the actual file */
          std::string temporary=get_symlinkpath(fullpath);
          trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\\nFile="+temporary);
          if(temporary.compare("")!=0)
          {
            closedir(mydir);
            if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
            trace("look_for_first_file_in_subdirs::Symlink="+temporary);
            finalAnswer=temporary;
            return temporary;
          }
        }
        else
        {
          closedir(mydir);
          finalAnswer=fullpath;
          return fullpath;
        }
      }
    }
  /** if it is a directory look inside recursively */
    if((entryPointer->d_type==DT_DIR)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(test_file(thisAnswer))
        {
          closedir(mydir);
          finalAnswer=thisAnswer;
          return thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
}
else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\\nMUST EXIT");}
trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
return finalAnswer;} {}
  }
  Function {look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find)} {return_type bool
  } {
    code {for( std::vector<std::string>::iterator it = vector_to_check.begin();
it!=vector_to_check.end();
++it){
  std::string tmp=*it;
  if(tmp.compare(item_to_find)==0){return true;}
}
return false;} {}
  }
  Function {make_icon(Fl_Window *o)} {} {
    code {Fl_Pixmap f(flfm_xpm);
const Fl_Pixmap * flpad_xpm_icon = &f;
const Fl_RGB_Image *img = new Fl_RGB_Image(flpad_xpm_icon,FL_GRAY);
o->icon(img);} {}
  }
  Function {make_window()} {open
  } {
    Fl_Window win {
      label flfm open
      xywh {139 214 540 450} type Double when 3 resizable
      code0 {make_icon(o);} xclass flfm visible
    } {
      Fl_Menu_Bar menu {
        xywh {0 0 555 25} box FLAT_BOX color 38 selection_color 80 labelcolor 7 textcolor 7
      } {
        Submenu {} {
          label {&File} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&Open}
            callback {open_cb();}
            xywh {0 0 100 20} shortcut 0x4006f
          }
          MenuItem {} {
            label {&Exit}
            callback {exit(0);}
            xywh {0 0 100 20} shortcut 0x40071
          }
        }
        Submenu {} {
          label {&Edit} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label Preferences
            callback {pref_window()->show();}
            xywh {0 0 100 20}
          }
        }
        Submenu {} {
          label {&Tool} open
          xywh {5 5 100 20}
        } {
          MenuItem {} {
            label {&Open in Terminal}
            callback {open_in_terminal()}
            xywh {0 0 100 20} shortcut 0xffc1
          }
        }
        Submenu {} {
          label {&Help} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&About}
            callback {about_window()->show();}
            xywh {0 0 100 20} shortcut 0xffbe
          }
        }
      }
      Fl_Button tab_button {
        label {@+}
        callback {add_tab();}
        tooltip {New Tab} xywh {5 27 25 25} box NO_BOX shortcut 0x2b color 23
      }
      Fl_Button home_button {
        callback {Tab *tab = (Tab*)(TABS->value());
tab->home();}
        tooltip Home xywh {35 27 25 25} box NO_BOX shortcut 0x31 color 23
        code0 {o->image(home_image);}
      }
      Fl_Button previous_button {
        label {@<-}
        callback {Tab *tab = (Tab*)(TABS->value());
tab->back();}
        tooltip {Press ',' to use this} xywh {65 27 25 25} box NO_BOX shortcut 0xff51 color 23
      }
      Fl_Button up_button {
        label {@8->}
        callback {Tab *tab = (Tab*)(TABS->value());
tab->up();}
        tooltip {Press '.' to use this} xywh {95 27 25 25} box NO_BOX shortcut 0xff52 color 23
      }
      Fl_Input barinput {
        callback {update(o);}
        xywh {140 30 385 30} box BORDER_BOX selection_color 80
      }
      Fl_Tabs TABS {
        callback {Tab *tab = (Tab*)(o->value());
std::string C = tab->CurrentDirectory;
barinput->value(C.c_str());
barinput->redraw();} open selected
        xywh {0 60 540 390} box BORDER_BOX color 46 selection_color 51
        code0 {add_tab();}
        code1 {button_style(1);}
      } {}
    }
  }
  Function {program_is_running(std::string program_line)} {return_type bool
  } {
    code {if(program_line.compare("")==0){return false;}
int pid=getProcIdByName(program_line);
if(pid>0){return true;}
std::string pgrepProg=term_out("which pgrep");
if(pgrepProg.compare("")==0)
{
  //TODO: make a way for this to still check...
  return false;
}
  //std::cout<<"pgrep is "+pgrepProg<<std::endl;
std::string shell=get_shell_for_C();
if(shell.compare("")==0)return false;
  //std::cout<<"Using shell command="+shell<<std::endl;
std::string processline=program_line;
std::string pgrep = shell + " "+pgrepProg+" "+program_line+ "'";
  //std::cout<<"Total command to run:\\n"+pgrep<<std::endl;
std::string returnVal=term_out(pgrep);
if(returnVal.compare("")==0){return false;}
return true;} {}
  }
  Function {remove_cruft(std::string StringInput, std::string CruftToRemove)} {return_type {std::string}
  } {
    code {if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
unsigned int found=0;
unsigned int cruftLength=CruftToRemove.length();
found=StringInput.find(CruftToRemove);
if(found>StringInput.length()){return StringInput;}
std::string temp=StringInput;
temp=temp.erase(0,found+cruftLength);
if(temp.compare("")!=0){return temp;}
std::string temp2=StringInput;
temp2=temp2.erase(found,std::string::npos);
if(temp2.compare("")!=0){return temp2;}
trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
return StringInput;} {}
  }
  Function {run_a_program_in_background(std::string program)} {return_type int
  } {
    code {std::string shell=get_shell_for_C();
program += " &disown";
if(shell.compare("")!=0){
  shell+=program;
  shell+="'";
}
else{shell=program;}
trace("run_program_in_background::"+shell);
return system(shell.c_str());} {}
  }
  Function {run(std::string program)} {return_type int
  } {
    code {std::string shell=get_shell_for_C();
if(shell.compare("")!=0)
{
  shell+=program;
  shell+="'";
}
else{shell=program;}
trace("run_program::"+shell);
return system(shell.c_str());} {}
  }
  Function {run_in_bg(void *userdata)} {return_type {static void*}
  } {
    code {while(true){
printf("Hello, World!\\n");
}} {}
  }
  Function {sed_i(std::string input, std::string remove, std::string replace)} {return_type {std::string}
  } {
    code {unsigned int xmlfix=0;
unsigned int oldFind=0;
unsigned int length=input.length();
unsigned int removeLength=remove.length();
std::string modinput=input;
while(modinput.find(remove,oldFind)<length)
{
  xmlfix = modinput.find(remove,oldFind);
  oldFind=xmlfix+replace.length();
  std::string tempPRE,tempPOST,temp;
  if(xmlfix<length)
  {
    temp=modinput;
    tempPOST=modinput;
    tempPRE = temp.erase(xmlfix,std::string::npos);
    tempPOST = modinput.erase(0,xmlfix+removeLength);
    modinput = tempPRE + replace + tempPOST;
    length=modinput.length();
  }
}
return modinput;} {}
  }
  Function {sort_array(std::vector<std::string> vector_to_sort)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string>::iterator it;
std::sort (vector_to_sort.begin(), vector_to_sort.end());
it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
return vector_to_sort;} {}
  }
  Function {test_exec(std::string execToTest)} {return_type bool
  } {
    code {if(execToTest.compare("")==0){return false;}
/** the list of directories it might check*/
/** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
std::string stringEXEC;
std:: string testPATH, testExec;
bool result = false;
unsigned int numofpaths = items_in_path();
for (unsigned int i = 1; i <= numofpaths; i++)
{
  stringEXEC = execToTest;
  testPATH = current_path(i);
  stringEXEC = testPATH + "/" + stringEXEC;
  if(test_file(stringEXEC.c_str())){return true;}
}
return result;} {}
  }
  Function {test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check)} {return_type {std::string}
  } {
    code {if(fileWithNOPATH.compare("")==0){return "";}
std::string filePathRemoved=fileWithNOPATH;
unsigned int found=filePathRemoved.rfind('/');
trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
if(found<filePathRemoved.length())
{
  unsigned int len=filePathRemoved.length()-found;
  filePathRemoved=filePathRemoved.erase(0,len);
}
for( std::vector<std::string>::iterator it = directories_to_check.begin();
  it!=directories_to_check.end();
  ++it)
{
  std::string dirToOpen=*it;
  std::string result=dirToOpen;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
  else
  {
    result+="/";
    result+=filePathRemoved;
  }
  if(test_file(result))
  {
    trace("test_file_in_vector_path::FOUND="+result);
    return result;
  }
  else
  {
    std::string tmp=result;
    tmp=get_symlinkpath(tmp);
    if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
  }
}
return "";} {}
  }
  Function {term_out(std::string terminal_Command_You_Want_Output_From)} {return_type {std::string}
  } {
    code {if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
/** set a locale so this works well */
const char* LANG=getenv("LANG");
std::string LOCALE;
if(LANG==NULL)
{
  LANG=getenv("LANGUAGE");
  if(LANG!=NULL){
  std::string tmp=LANG;
  unsigned int find=tmp.find(".UTF-8");
  if(find>tmp.length()){tmp+=".UTF-8";}
  LOCALE=tmp;
  }
}
else
{
  LOCALE=LANG;
}
if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
std::string result="";
const int max_buffer = 1024;
char buffer[max_buffer];
FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
if (command_p)
{
  while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
  pclose(command_p);
}
else{ return "";}
if (result.compare("")==0){return "";}
int end = result.length();
if((end-1) == 0){return "";}
if((end) == 0){return "";}
return result.erase(end-1,1);} {}
  }
  Function {resizeImage(Fl_Widget * widget)} {return_type void
  } {
    code {std::string icon_file=CURRENT_DIR+CURRENT_FILE;
if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}
widget->align(FL_ALIGN_CENTER);
widget->copy_label("");
widget->image(NULL);
widget->redraw();
widget->label(0L);
int w=widget->w();
int h=widget->h();
if(!test_file(icon_file))
{
  trace("changeWidgetImage:: "+icon_file+" is not an Image");
  return;
}
if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}

Fl_Image* image2=widget->image();//new Fl_Image(w,h,4);

if(has_file_extention_at_end(icon_file,".png"))
{
  Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xpm"))
{
  Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xbm"))
{
  Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".svg"))
{
  NSVGimage *svg_image = NULL;
  NSVGrasterizer *rast = NULL;
  unsigned char* img_data = NULL;
  int width;
  int height;
  const int depth = 4;
  svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
  if (svg_image == NULL)
  {
    trace("changeWidgetImage::Could not open SVG image:"+icon_file);
    return;
  }
  width = (int)svg_image->width;
  height = (int)svg_image->height;
  rast = nsvgCreateRasterizer();
  if (rast == NULL)
  {
    trace("changeWidgetImage::Could not init rasterizer.");
    return;
  }
  img_data = (unsigned char*)malloc(width * height * depth);
  if (img_data == NULL)
  {
    trace("changeWidgetImage::Could not alloc image buffer.\\n");
    return;
  }
  nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
  Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
  image2 = image->copy(w,h);
  delete(image);
  nsvgDeleteRasterizer(rast);
  nsvgDelete(svg_image);
}
else if((has_file_extention_at_end(icon_file,".jpg"))||
(has_file_extention_at_end(icon_file,".jpeg"))||
(has_file_extention_at_end(icon_file,".face")))
{
  Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".gif"))
{
  Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else{return;}
widget->size(image2->w(),image2->h());
widget->image(image2);
widget->show();
win->redraw();} {}
  }
  Function {open_cb()} {open
  } {
    code {const char* home=getenv("HOME");
std::string DIR=home;
if(home==NULL)
{
  DIR="/tmp";
}
else
{
  std::string tmp = DIR;
  tmp+="/Pictures";
  if(test_dir(tmp))
    DIR=tmp;
}
char *newfile = fl_file_chooser("Open", "*.{jpg,jpeg,png,gif,bmp,svg,xbm,xpm}", DIR.c_str(),0);
if (newfile != NULL)
{
  std::string tmp = newfile;
  view_image(tmp);  
}} {}
  }
  Function {right_cb()} {return_type bool
  } {
    code {if(CURRENT_DIR.compare("")==0)
  return false;
if(CURRENT_FILE.compare("")==0)
  return false;

bool NEXT=false;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(CURRENT_DIR.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=CURRENT_DIR+fullpath;
      if(NEXT)
      {
        return view_image(fullpath);
      }
      if(fullpath.compare(CURRENT_FILE)==0)
      {
        NEXT=true;
      }
      else
      {
        std::string tmp = CURRENT_DIR + CURRENT_FILE;
        if(fullpath.compare(tmp)==0)
        {
          NEXT=true;
        }

      }
    }
  }
}
return false;} {}
  }
  Function {left_cb()} {return_type bool
  } {
    code {if(CURRENT_DIR.compare("")==0)
  return false;
if(CURRENT_FILE.compare("")==0)
  return false;

std::string previous;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(CURRENT_DIR.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=CURRENT_DIR+fullpath;
      if(fullpath.compare(CURRENT_FILE)==0)
      {
        return view_image(previous);
      }
      else
      {
        std::string tmp = CURRENT_DIR + CURRENT_FILE;
        if(fullpath.compare(tmp)==0)
        {
           return view_image(previous);
        }
      }

      previous=fullpath;
    }
  }
}
return false;} {}
  }
  Function {view_image(std::string filename)} {return_type bool
  } {
    code {if(filename.compare("")==0)
  return false;
CURRENT_FILE=filename;
CURRENT_DIR=get_directory_from_filename(filename);
viewer->position(0, 55);
changeWidgetImage(CURRENT_FILE,viewer);
unsigned int finder=filename.rfind("/");
if(finder<filename.length())
{
  filename=CURRENT_FILE.erase(0,finder+1);
}
win->label(filename.c_str());
return true;} {}
  }
  Function {zoom(bool out=false)} {} {
    code {if(CURRENT_FILE.compare("")==0)
  return;
int w = viewer->w();
int h = viewer->h();
int scaleW = w * 0.10;
int scaleH = h * 0.10;
if(out)
{
  w = w - scaleW;
  h = h - scaleH; 
}
else
{
  w = w + scaleW;
  h = h + scaleH;
}
viewer->size(w,h);
resizeImage(viewer);} {}
  }
  Function {update(Fl_Input *o)} {open
  } {
    code {const char* curr = o->value();
if(curr==NULL)
  return;
Tab *tab = (Tab*)(TABS->value());
std::string C = tab->CurrentDirectory;
tab->copy_label(curr);
tab->change_dir(curr);
barinput->value(curr);} {}
  }
  Function {test_dir(std::string dirToTest)} {return_type bool
  } {
    code {if(dirToTest.compare("")==0){return false;}
DIR *dir = NULL;
dir = opendir(dirToTest.c_str());
if (dir!=NULL)
{
  closedir(dir);
  return true;
}
return false;} {}
  }
  Function {open_in_terminal()} {} {
    code {Tab *tab = (Tab*)(TABS->value());
const char* path=tab->label();
if(path==NULL)
  return;
const char* list[]={"x-terminal-emulator","sakura","lxterm","xterm","roxterm","terminator"};
for(int i = 0;i<5;i++)
{
  const char* I = list[i];
  if(test_exec(I))
  {
    std::string tt=I;
    tt+=" ";
    tt+=path;
    run_a_program_in_background(tt);
    return;
  }
}} {}
  }
  Function {pref_window()} {open
  } {
    Fl_Window {} {open
      xywh {852 201 370 340} type Double visible
    } {
      Fl_Tabs {} {open
        xywh {-5 0 375 340} box FLAT_BOX color 46 selection_color 51
      } {
        Fl_Group {} {
          label General open
          xywh {-5 25 375 315} color 51 selection_color 46 hide
        } {
          Fl_Check_Button {} {
            label {Move deleted files to trash}
            tooltip {Store deleted files in user's Trash folder, rather than removing them completely} xywh {10 35 25 25} down_box GTK_DOWN_BOX color 7 selection_color 63
          }
          Fl_Check_Button {} {
            label {Confirm before deleting}
            tooltip {Show pop-up to confirm delete} xywh {10 59 220 25} down_box GTK_DOWN_BOX color 7 selection_color 63
          }
          Fl_Check_Button {} {
            label {Show Grid instead of File List}
            tooltip {Show a grid of icons, rather than a list} xywh {10 82 25 25} down_box GTK_DOWN_BOX color 7 selection_color 63
          }
          Fl_Check_Button handle_desktop {
            label {Handle Desktop}
            callback {if(o->value())
{
  desktop_icons->show();
  desktop_image->show();
  desktop_color->show();
}
else
{
  desktop_icons->hide();
  desktop_image->hide();
  desktop_color->hide();
}}
            tooltip {Draw the desktop background, and icons} xywh {10 105 220 25} down_box GTK_DOWN_BOX color 7 selection_color 63
          }
          Fl_Button desktop_image {
            label Image
            tooltip {Background Image} xywh {40 130 65 30} box FLAT_BOX down_box FLAT_BOX color 43 selection_color 22 labelcolor 7
            code0 {if(!handle_desktop->value())o->hide();}
          }
          Fl_Button desktop_color {
            label Color
            tooltip {Background Color} xywh {40 165 65 30} box FLAT_BOX down_box FLAT_BOX color 43 selection_color 22 labelcolor 7
            code0 {if(!handle_desktop->value())o->hide();}
          }
          Fl_Check_Button desktop_icons {
            label {Show Desktop Icons}
            tooltip {Show icons (from Desktop folder) on the desktop} xywh {40 200 165 25} down_box GTK_DOWN_BOX color 7 selection_color 63
            code0 {if(!handle_desktop->value())o->hide();}
          }
        }
        Fl_Group {} {
          label Places open
          xywh {0 25 370 315} color 51 selection_color 46 hide
        } {
          Fl_Check_Button {} {
            label Home
            tooltip {Your personal folder} xywh {10 35 70 25} down_box GTK_DOWN_BOX color 55 selection_color 63
          }
          Fl_Check_Button {} {
            label Desktop
            tooltip {Your desktop folder} xywh {10 60 85 25} down_box GTK_DOWN_BOX color 55 selection_color 63
          }
          Fl_Check_Button {} {
            label Trash
            tooltip {Your Trash folder} xywh {10 85 85 25} down_box GTK_DOWN_BOX color 55 selection_color 63
          }
          Fl_Check_Button {} {
            label Root
            tooltip {The system's root filesystem folder '/'} xywh {10 110 65 25} down_box GTK_DOWN_BOX color 55 selection_color 63
          }
        }
        Fl_Group {} {
          label {Removable Media} open
          xywh {0 25 370 315} color 51 selection_color 46
        } {
          Fl_Check_Button {} {
            label {Automatically show new devices}
            tooltip {Automatically mount media} xywh {20 45 260 25} down_box GTK_DOWN_BOX color 55 selection_color 63
          }
        }
      }
    }
  }
  Function {change_dir(std::string dir)} {open
  } {
    code {Tab *tab = (Tab*)(TABS->value());
std::string C = tab->CurrentDirectory;
tab->copy_label(dir.c_str());
tab->change_dir(dir.c_str());
barinput->value(dir.c_str());} {}
  }
} 

class Desktop {open
} {
  decl {std::string Background;} {protected local
  }
  decl {int Type;} {protected local
  }
  Function {Desktop(std::string BG, int type)} {open
  } {
    code {Background=BG;
Type=type;
set_background(Background,Type);
make_desktop()->show();} {}
  }
  Function {make_desktop()} {open
  } {
    Fl_Window DESKTOP {
      xywh {594 185 100 100} type Double
      code0 {o->resize(0,0,Fl::w(),Fl::h());}
      code1 {configure();} visible
    } {}
  }
  Function {configure()} {open
  } {
    code {printf("Hello, World!\\n");} {}
  }
  Function {set_background(std::string icon_file, int type)} {open
  } {
    code {if(type>0)
  trace("TODO... type...");

if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}
DESKTOP->align(FL_ALIGN_CENTER);
DESKTOP->copy_label("");
DESKTOP->image(NULL);
DESKTOP->redraw();
DESKTOP->label(0L);
if(!test_file(icon_file))
{
  trace("changeWidgetImage:: "+icon_file+" is not an Image");
  return;
}
if(icon_file.compare("")==0)
{
  trace("changeWidgetImage::Image file is empty");
  return;
}

Fl_Image* image2=DESKTOP->image();//new Fl_Image(w,h,4);

if(has_file_extention_at_end(icon_file,".png"))
{
  Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xpm"))
{
  Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xbm"))
{
  Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".svg"))
{
  NSVGimage *svg_image = NULL;
  NSVGrasterizer *rast = NULL;
  unsigned char* img_data = NULL;
  int width;
  int height;
  const int depth = 4;
  svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
  if (svg_image == NULL)
  {
    trace("changeWidgetImage::Could not open SVG image:"+icon_file);
    return;
  }
  width = (int)svg_image->width;
  height = (int)svg_image->height;
  rast = nsvgCreateRasterizer();
  if (rast == NULL)
  {
    trace("changeWidgetImage::Could not init rasterizer.");
    return;
  }
  img_data = (unsigned char*)malloc(width * height * depth);
  if (img_data == NULL)
  {
    trace("changeWidgetImage::Could not alloc image buffer.\\n");
    return;
  }
  nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
  Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
  image2 = image->copy();
  delete(image);
  nsvgDeleteRasterizer(rast);
  nsvgDelete(svg_image);
}
else if((has_file_extention_at_end(icon_file,".jpg"))||
(has_file_extention_at_end(icon_file,".jpeg"))||
(has_file_extention_at_end(icon_file,".face")))
{
  Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".gif"))
{
  Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
  image2 = image->copy();
  delete(image);
}
else{return;}
DESKTOP->show();

//widget->size(newW2,newH2);
DESKTOP->image(image2);
DESKTOP->redraw();} {}
  }
} 

Function {main(int argc, char *argv[])} {open return_type int
} {
  code {Fl::visual(FL_RGB);
Fl_File_Icon::load_system_icons();
TYPE=0;
FOREGROUND_COLOR = (Fl_Color)17;
BACKGROUND_COLOR = (Fl_Color)38;

UserInterface* ui = new UserInterface;
try
{
  ui->make_window()->show();
  if (argc > 1)
  {
    char* charchar1 = argv[1];
    fl_decode_uri(charchar1);
    trace(charchar1);
    std::string fname = charchar1;
    unsigned int URI  = fname.find("file:///");
    if(URI==0)
    {
      fname = fname.substr(URI+7,std::string::npos);
    }
    ui->change_dir(fname);
  }

  return Fl::run();
}
catch (const std::exception& e){
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...){
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}} {}
} 

Function {trace(std::string msg)} {} {
  code {std::cout<<msg<<std::endl;} {}
} 

Function {extension(std::string ext,...)} {return_type bool
} {
  code {va_list args;
va_start(args,ext);
const char* list = va_arg(args,const char*);
while (list!=NULL)
{
  std::cout << __PRETTY_FUNCTION__ <<":"<<list<<std::endl;
  if(ext.compare(list)==0)
  {
    va_end(args);
    return true;
  }
}
va_end(args);
return false;} {}
} 

Function {get_directory_from_filename(std::string input)} {open return_type {std::string}
} {
  code {std::string filename = input;
unsigned int finder=filename.rfind("/");
if(finder<filename.length())
{
  filename=filename.erase(finder+1,std::string::npos);
}
else{return "";} /**return empty if there is no directory*/
return filename;} {}
} 

Function {has_file_extention_at_end(std::string filename,std::string extention)} {open return_type bool
} {
  code {std::string extention_check;
std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
unsigned int found=filename.find(extention);
unsigned int ext_len=extention.length();
unsigned int file_len=filename.length();
if(found<file_len)
{
  if(found==(file_len-ext_len))
  {
    return true;
  }
}
return false;} {}
} 

Function {test_file(std::string fileWithFullPATH)} {open return_type bool
} {
  code {if(fileWithFullPATH.compare("")==0){return false;}
std::string dir=get_directory_from_filename(fileWithFullPATH);
if(dir.compare("")==0){return false;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      if(fullpath.compare(fileWithFullPATH)==0)
      {
        closedir(mydir);
        return true;
      }
    }
  }
  closedir(mydir);
}
else{trace("could not open directory to search for "+fileWithFullPATH);}
return false;} {}
} 

Function {theme_scrollbars(Fl_Browser* o)} {open
} {
  code {trace("theme browser scroll bars");
o->box(FL_BORDER_BOX);
o->scrollbar.slider(FL_BORDER_BOX);
o->hscrollbar.slider(FL_BORDER_BOX);

o->hscrollbar.labelcolor(BACKGROUND_COLOR);
o->hscrollbar.color(BACKGROUND_COLOR);
o->hscrollbar.selection_color(FOREGROUND_COLOR);

o->scrollbar.labelcolor(BACKGROUND_COLOR);
o->scrollbar.color(BACKGROUND_COLOR);
o->scrollbar.selection_color(FOREGROUND_COLOR);} {}
} 

Function {theme_scrollbars(Fl_Scroll* o)} {open
} {
  code {trace("theme Scroll scroll bars");
o->box(FL_BORDER_BOX);
o->scrollbar.slider(FL_BORDER_BOX);
o->hscrollbar.slider(FL_BORDER_BOX);

o->hscrollbar.labelcolor(BACKGROUND_COLOR);
o->hscrollbar.color(BACKGROUND_COLOR);
o->hscrollbar.selection_color(FOREGROUND_COLOR);

o->scrollbar.labelcolor(BACKGROUND_COLOR);
o->scrollbar.color(BACKGROUND_COLOR);
o->scrollbar.selection_color(FOREGROUND_COLOR);} {}
} 
