// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <libintl.h>
#include "flabout.h"

void UI::cb_ok_i(Fl_Button*, void*) {
  exit(0);
}
void UI::cb_ok(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_ok_i(o,v);
}

std::string UI::combine(std::vector<std::string> in) {
  std::string out;
  if(in.empty())
  {
    out="";
  }
  else
  {
    for( std::vector<std::string>::iterator it = in.begin();
      it!=in.end();
      ++it)
    {
      out+=*it;
      out+=" ";
    }
  }
  return out;
}

std::string UI::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename))
  {
    return "";
    trace("No file sent in: "+filename);
  }
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

std::string UI::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string UI::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

void UI::make_text() {
  if(MSG.compare("")!=0)
  {
    populateBrowserWithString(text,MSG);
    return;
  }
  std::string FALL_BACK_TEXT="/usr/share/torios/about_us.plain";
  std::string TEXT="ToriOS version "+toriosversion();
  
  TEXT+="\nYes, we are a family\n\
  Ali Jawad\tThe founder and project lead\n\
  Israel Dahl\tLead developer\n\
  Nio Wiklund\tDeveloper, QA testing\n\
  Paul\tDocumentation\n\
  Geoffrey\tDocumentation\n\
  Sam Klein\tDocumentation\n\
  JackT\tQA testing\n\
  Rafael\tArtwork & Web Design\n\
  Kris\tWeb hosting\n\
  Phill\tWeb hosting, technical support, & Hosting the ISO";
  if(test_file(FALL_BACK_TEXT))
  {
    TEXT=file_to_string(FALL_BACK_TEXT);
  }
  populateBrowserWithString(text,TEXT);
}

Fl_Double_Window* UI::make_window() {
  { about = new Fl_Double_Window(310, 330, gettext("About"));
    about->user_data((void*)(this));
    { ok = new Fl_Button(215, 290, 90, 35, gettext("Ok"));
      ok->box(FL_FLAT_BOX);
      ok->color(FL_DARK_GREEN);
      ok->selection_color(FL_DARK_RED);
      ok->labelcolor(FL_BACKGROUND2_COLOR);
      ok->callback((Fl_Callback*)cb_ok);
    } // Fl_Button* ok
    { text = new Fl_Browser(5, 5, 305, 275);
      text->box(FL_FLAT_BOX);
      text->selection_color((Fl_Color)80);
      make_text();
    } // Fl_Browser* text
    about->end();
  } // Fl_Double_Window* about
  return about;
}

void UI::populateBrowserWithString(Fl_Browser *o, std::string STRING) {
  if(STRING.compare("")==0)return;
  std::string sep="\n";
  unsigned int finder=STRING.find(sep);
  unsigned int length=STRING.length();
  /** If no '\n' is found just add the string and return*/
  if(finder>length){
    //("No Newline found");
    o->add(STRING.c_str());
    return;
  }
  /** while there is a new line keep adding*/
  while(finder<length){
    finder=STRING.find(sep);
    length=STRING.length();
    std::string tmp1=STRING;
    /** make sure if no newline is at the end it wont crash*/
    if(finder<length+1){
    std::string tmp2=tmp1.erase(finder,std::string::npos);
    o->add(tmp2.c_str());
    tmp1=STRING;
    finder=tmp1.find(sep);
    STRING=tmp1.substr(finder+1,std::string::npos);
    }
  }
}

bool UI::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

std::string UI::toriosversion() {
  return file_to_string("/usr/share/torios/version");
}

int main(int argc, char*argv[]) {
  std::string current_exec_name = argv[0];
  std::string first_arge;
  std::vector<std::string> all_args;
  if (argc > 1)
  {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
  UI *ui = new UI();
  ui->MSG=ui->combine(all_args);
  ui->make_window()->show();
  return Fl::run();
}

void trace(std::string msg) {
  //std::cout<<msg<<std::endl;
}
