// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <apt-pkg/cachefile.h>
#include <apt-pkg/pkgcache.h>
#include "flapt.h"

void UI::cb_ok_i(Fl_Button*, void*) {
  exit(0);
}
void UI::cb_ok(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_ok_i(o,v);
}

void UI::cb_installed_i(Fl_Button*, void*) {
  get_packages(text);
}
void UI::cb_installed(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_installed_i(o,v);
}

bool UI::compare_nocase(const std::string& first, const std::string& second) {
  unsigned int i=0;
  while ( (i<first.length()) && (i<second.length()) )
  {
    if (tolower(first[i])<tolower(second[i])) return true;
    else if (tolower(first[i])>tolower(second[i])) return false;
    ++i;
  }
  return ( first.length() < second.length() );
}

std::string UI::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename))
  {
    return "";
    trace("No file sent in: "+filename);
  }
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

void UI::get_packages(Fl_Browser *o) {
  pkgInitConfig(*_config);
  pkgInitSystem(*_config, _system);
  pkgCacheFile cache_file;     
  pkgCache* cache = cache_file.GetPkgCache();
  
  for (pkgCache::PkgIterator package = cache->PkgBegin(); !package.end(); package++)
  {
    LIST.push_back(package.Name());
  }
  LIST.sort(compare_nocase);
  for( std::list<std::string>::iterator it = LIST.begin();
  it!=LIST.end();
  ++it){
    std::string tmp=*it;
    o->add(tmp.c_str());
  }
}

std::string UI::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string UI::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

Fl_Double_Window* UI::make_window() {
  { about = new Fl_Double_Window(310, 410, "About");
    about->user_data((void*)(this));
    { ok = new Fl_Button(215, 290, 90, 35, "Ok");
      ok->box(FL_FLAT_BOX);
      ok->color(FL_DARK_GREEN);
      ok->selection_color(FL_DARK_RED);
      ok->labelcolor(FL_BACKGROUND2_COLOR);
      ok->callback((Fl_Callback*)cb_ok);
    } // Fl_Button* ok
    { text = new Fl_Browser(5, 5, 305, 275);
      text->box(FL_FLAT_BOX);
      text->selection_color((Fl_Color)80);
    } // Fl_Browser* text
    { installed = new Fl_Button(5, 285, 90, 35, "Installed");
      installed->box(FL_FLAT_BOX);
      installed->color((Fl_Color)12);
      installed->selection_color((Fl_Color)34);
      installed->labelcolor(FL_BACKGROUND2_COLOR);
      installed->callback((Fl_Callback*)cb_installed);
    } // Fl_Button* installed
    about->end();
  } // Fl_Double_Window* about
  return about;
}

void UI::populateBrowserWithString(Fl_Browser *o, std::string STRING) {
  if(STRING.compare("")==0)return;
  std::string sep="\n";
  unsigned int finder=STRING.find(sep);
  unsigned int length=STRING.length();
  /** If no '\n' is found just add the string and return*/
  if(finder>length){
    //("No Newline found");
    o->add(STRING.c_str());
    return;
  }
  /** while there is a new line keep adding*/
  while(finder<length){
    finder=STRING.find(sep);
    length=STRING.length();
    std::string tmp1=STRING;
    /** make sure if no newline is at the end it wont crash*/
    if(finder<length+1){
    std::string tmp2=tmp1.erase(finder,std::string::npos);
    o->add(tmp2.c_str());
    tmp1=STRING;
    finder=tmp1.find(sep);
    STRING=tmp1.substr(finder+1,std::string::npos);
    }
  }
}

bool UI::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

int main(int argc, char*argv[]) {
  UI *ui = new UI();
  ui->make_window()->show();
  return Fl::run();
}

void trace(std::string msg) {
  //std::cout<<msg<<std::endl;
}
