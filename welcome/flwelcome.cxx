// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include <libintl.h>
#include "flwelcome.h"

Terminal::Terminal(int X,int Y,int W,int H,const char* L) : Fl_Text_Display(X,Y,W,H,L) {
  terminalbuffer = new Fl_Text_Buffer();
  buffer(terminalbuffer);
  textfont(FL_COURIER);
  textsize(12);
  box(FL_FLAT_BOX);
  color((Fl_Color)38);
  textcolor(FL_WHITE);
  //parent()->resizable(this);
}

void Terminal::append(char* p) {
  terminalbuffer->append(p);
  insert_position(buffer()->length());
  scroll(count_lines(0, buffer()->length(), 1), 0);
  parent()->redraw();
}

int Terminal::terminal_output(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return 1;}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  terminalbuffer->text("");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer)-1, command_p) !=NULL)
    {
      append(buffer);
      //std::cout<<buffer<<"::"<<std::endl;
      Fl::flush();
    }
    pclose(command_p);
    return 0;
  }
  else{ return -1;}
  return 2; //this shouldn't be possible
}

void UI::cb_Close_i(Fl_Button*, void*) {
  install_win->hide();
}
void UI::cb_Close(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void UI::cb_Install_i(Fl_Button*, void*) {
  int val = install_list->value();
if( (install_list->size()>0) && (val>0) )
{
  const char* t = install_list->text(val);
  if(t != NULL)
  {
    term_win->show();
    term_win->wait_for_expose();
    Fl::flush();
    std::string p=t;  
    install(p);
  }
};
}
void UI::cb_Install(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Install_i(o,v);
}

void UI::cb_Information_i(Fl_Button*, void*) {
  int val = install_list->value();
if( (install_list->size()>0) && (val>0) )
{
  const char* t = install_list->text(val);
  if(t != NULL)
  {
    std::string p=t;
    info(p);
  }
};
}
void UI::cb_Information(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Information_i(o,v);
}

void UI::cb_Exit_i(Fl_Button*, void*) {
  exit(0);
}
void UI::cb_Exit(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

void UI::cb_Web_i(Fl_Button*, void*) {
  std::string LIST="midori\nqupzilla\nhttps://www.google.com/chrome/index.html\nhttp://www.opera.com/\nhttp://linux.palemoon.org/";
if(isDebian())
  LIST="firefox-esr\nchromium\n"+LIST;
else
   LIST="firefox\nchromium-browser\n"+LIST;
make_install_list(LIST);
}
void UI::cb_Web(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Web_i(o,v);
}

void UI::cb_Office_i(Fl_Button*, void*) {
  make_install_list("libreoffice\nabiword gnumeric");
}
void UI::cb_Office(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Office_i(o,v);
}

void UI::cb_Music_i(Fl_Button*, void*) {
  std::string PLAYERS="audacious\namarok\nbanshee\nclementine\ndeadbeef\ngnome-music\nlxmusic\nmpv\nrhythmbox";
make_install_list(PLAYERS);
}
void UI::cb_Music(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Music_i(o,v);
}

void UI::cb_Video_i(Fl_Button*, void*) {
  std::string PLAYERS="vlc\nparole\ntotem";
if(DIST<=1)
  PLAYERS+="\nhandbrake";
make_install_list(PLAYERS);
}
void UI::cb_Video(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Video_i(o,v);
}

void UI::cb_Media_i(Fl_Button*, void*) {
  std::string DEBS="gstreamer0.10-bad gstreamer0.10-bad-plugins gstreamer0.10-ugly-plugins gst-libav  unrar lib32-flashplugin flashplugin libdvdread libdvdcss gst-plugins-bad gst-plugins-ugly";
//DEBS="gstreamer0.10-plugins-bad libavcodec-extra  gstreamer1.0-plugins-ugly gstreamer0.10-fluendo-mp3 gstreamer0.10-plugins-bad gstreamer0.10-plugins-ugly gstreamer1.0-fluendo-mp3 gstreamer1.0-libav gstreamer1.0-plugins-bad  ttf-mscorefonts-installer unrar flashplugin-nonfree pepperflashplugin-nonfree libdvdread4"
switch(DIST)
{
  case 0:
    DEBS+=" gvfs gvfs-fuse mtp-tools gvfs-backends gstreamer0.10-plugins-base";
    break;
  case 1:
    DEBS+=" gvfs-mtp gst-plugins-base gst-plugins-base-libs gvfs-gphoto2";
    break;
  default:
    break;
}
install(DEBS);
}
void UI::cb_Media(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Media_i(o,v);
}

void UI::cb_Games_i(Fl_Button*, void*) {
  std::string DEBS="ace-of-penguins\naisleriot\nfltk1.3-games\nfrogatto\ngcompris\nscratch\nsupertux\nteeworlds\npopen-invaders\nwesnoth-1.12-core\nxboard\nxbomb\nxjig\nxjump\nzsnes";
switch(DIST)
{
  case 0:
    break;
  case 1:
    break;
  default:
    break;
}
make_install_list(DEBS);
}
void UI::cb_Games(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Games_i(o,v);
}

void UI::cb_System_i(Fl_Button*, void*) {
  if(test_exec("torios-packagetool"))
  show_command("torios-packagetool upgrade");
else
  show_command("sudo -A apt -y full-upgrade");
}
void UI::cb_System(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_System_i(o,v);
}

void UI::cb_Bootloader_i(Fl_Button* o, void*) {
  std::string COMMAND="sudo -A grub-mkconfig -o /boot/grub/grub.cfg";
switch(DIST)
{
  case 0:
    COMMAND="sudo -A update-grub";
    break;
  default:
    break;
}
show_command(COMMAND);
}
void UI::cb_Bootloader(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Bootloader_i(o,v);
}

void UI::cb_Appearance_i(Fl_Button*, void*) {
  //TODO check things
run("jwm-settings-manager");
}
void UI::cb_Appearance(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Appearance_i(o,v);
}

void UI::cb_Login_i(Fl_Button*, void*) {
  run("fltk-lightdm");
}
void UI::cb_Login(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_Login_i(o,v);
}

void UI::cb_ToriOS_i(Fl_Button*, void*) {
  open_website("http://www.torios.top");
}
void UI::cb_ToriOS(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_ToriOS_i(o,v);
}

void UI::cb_ToriOS1_i(Fl_Button*, void*) {
  open_website("https://launchpad.net/~torios");
}
void UI::cb_ToriOS1(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_ToriOS1_i(o,v);
}

void UI::cb_ToriOS2_i(Fl_Button*, void*) {
  open_website("https://twitter.com/ToriOS_Official");
}
void UI::cb_ToriOS2(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_ToriOS2_i(o,v);
}

void UI::cb_Close1_i(Fl_Button* o, void*) {
  o->parent()->hide();
}
void UI::cb_Close1(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Close1_i(o,v);
}

void UI::cb_Close2_i(Fl_Button* o, void*) {
  o->parent()->hide();
}
void UI::cb_Close2(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Close2_i(o,v);
}

std::string UI::current_path(int whichPath) {
  unsigned int lastPath = 0;
  std::string result;
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  const char* path =getenv("PATH");
  std::string stringPATH;
  if(path == NULL){stringPATH = "/usr/bin";}
  else{stringPATH = path;}
  std::string::size_type firstPosition = stringPATH.find(':');
  if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
  std::string::size_type position = firstPosition;
  for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
  result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
  return result;
}

std::string UI::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename))
  {
    return "";
    trace("No file sent in: "+filename);
  }
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

std::string UI::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string UI::get_shell_for_C() {
  std::string shell=term_out("which bash");
  if(shell.compare("")==0){
    if(!test_exec(shell)){
    shell=term_out("which sh");
    if(!test_exec(shell)){return "";}
    //TODO make this work for others
    }
  }
  shell=shell+" -c '";
  return shell;
}

std::string UI::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

void UI::install(std::string pkg) {
  //TODO make actual installer
  unsigned int HTTP = pkg.find("http");
  if(HTTP==0)
  {
    open_website(pkg);
    return;
  }
  trace("Install: "+pkg);
  std::string cmd = "sudo -A torios-packagetool -y install ";
  if(!test_exec("torios-packagetool"))
    cmd="sudo -A apt install";
  cmd+=pkg;
  terminal->terminal_output(cmd);
  cmd="jwm-menu --reload";
  run(cmd);
}

void UI::info(std::string pkg) {
  //TODO
  trace("Looking up: "+pkg);
  std::string command = "torios-packagetool show "+pkg;
  std::string MSG=term_out(command);
  info_window(MSG)->show();
}

Fl_Double_Window* UI::install_list_window() {
  { install_win = new Fl_Double_Window(270, 295, gettext("Install"));
    install_win->user_data((void*)(this));
    { install_list = new Fl_Browser(5, 5, 265, 250);
      install_list->type(2);
      install_list->box(FL_FLAT_BOX);
      install_list->selection_color((Fl_Color)80);
    } // Fl_Browser* install_list
    { Fl_Button* o = new Fl_Button(130, 260, 65, 30, gettext("Close"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(200, 260, 65, 30, gettext("Install"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)61);
      o->selection_color(FL_DARK_GREEN);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Install);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(5, 260, 95, 30, gettext("Information"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)180);
      o->selection_color((Fl_Color)137);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Information);
    } // Fl_Button* o
    install_win->end();
  } // Fl_Double_Window* install_win
  return install_win;
}

unsigned int UI::items_in_path() {
  const char* path =getenv("PATH");
  std::string::size_type pathPosition =0;
  if(path==NULL){return 1;}
  std::string stringPATH = path;
  unsigned int howmany;
  for(howmany=1;(pathPosition!=std::string::npos);howmany++)
  {
    pathPosition=stringPATH.find(':', pathPosition+1);
  }
  return howmany;
}

Fl_Double_Window* UI::make_window() {
  { about = new Fl_Double_Window(345, 345, gettext("Welcome"));
    about->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(265, 300, 65, 30, gettext("Exit"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Exit);
    } // Fl_Button* o
    { Fl_Group* o = new Fl_Group(5, 30, 255, 125, gettext("Install"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)46);
      o->labelsize(20);
      { Fl_Button* o = new Fl_Button(10, 35, 120, 35, gettext("Web Browser"));
        o->tooltip(gettext("Install many popular web browsers"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Web);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 35, 120, 35, gettext("Office Programs"));
        o->tooltip(gettext("Write documents easily"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Office);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(10, 75, 120, 35, gettext("Music Player"));
        o->tooltip(gettext("Install a music player"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Music);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(10, 115, 120, 35, gettext("Video Player"));
        o->tooltip(gettext("Install a video player"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Video);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 75, 120, 35, gettext("Media Codecs"));
        o->tooltip(gettext("Install programs needed to play certain media"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Media);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 115, 120, 35, gettext("Games"));
        o->tooltip(gettext("Many games to choose from"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Games);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 180, 255, 45, gettext("Update"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)46);
      o->labelsize(20);
      { Fl_Button* o = new Fl_Button(10, 185, 120, 35, gettext("System"));
        o->tooltip(gettext("Keep your system up to date"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_System);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 185, 120, 35, gettext("Bootloader"));
        o->tooltip(gettext("Update your computers boot loader"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Bootloader);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(5, 250, 255, 85, gettext("System"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)46);
      o->labelsize(20);
      { Fl_Button* o = new Fl_Button(10, 255, 120, 35, gettext("Appearance"));
        o->tooltip(gettext("Configure your desktop"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Appearance);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 255, 120, 35, gettext("Login"));
        o->tooltip(gettext("Modify user logins easily"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->callback((Fl_Callback*)cb_Login);
        if(!test_exec("fltk-lightdm"))o->deactivate();
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(10, 295, 120, 35, gettext("Information"));
        o->tooltip(gettext("Get information on your computer"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->deactivate();
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(135, 295, 120, 35, gettext("Language"));
        o->tooltip(gettext("Modify language settings"));
        o->box(FL_FLAT_BOX);
        o->color((Fl_Color)23);
        o->deactivate();
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(265, 35, 65, 40, gettext("ToriOS Website"));
      o->tooltip(gettext("See our website"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)61);
      o->selection_color(FL_DARK_GREEN);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_ToriOS);
      o->align(Fl_Align(FL_ALIGN_WRAP));
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(265, 80, 65, 40, gettext("ToriOS Code"));
      o->tooltip(gettext("Code with us!"));
      o->box(FL_FLAT_BOX);
      o->color(FL_YELLOW);
      o->selection_color((Fl_Color)94);
      o->callback((Fl_Callback*)cb_ToriOS1);
      o->align(Fl_Align(FL_ALIGN_WRAP));
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(265, 125, 65, 40, gettext("ToriOS Twitter"));
      o->tooltip(gettext("Tweet us!"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)222);
      o->selection_color((Fl_Color)178);
      o->callback((Fl_Callback*)cb_ToriOS2);
      o->align(Fl_Align(FL_ALIGN_WRAP));
    } // Fl_Button* o
    DIST=0;
    make_terminal()->show();term_win->hide();
    about->end();
  } // Fl_Double_Window* about
  return about;
}

void UI::populateBrowserWithString(Fl_Browser *o, std::string STRING) {
  if(STRING.compare("")==0)return;
  std::string sep="\n";
  unsigned int finder=STRING.find(sep);
  unsigned int length=STRING.length();
  /** If no '\n' is found just add the string and return*/
  if(finder>length){
    //("No Newline found");
    o->add(STRING.c_str());
    return;
  }
  /** while there is a new line keep adding*/
  while(finder<length)
  {
    finder=STRING.find(sep);
    length=STRING.length();
    std::string tmp1=STRING;
    /** make sure if no newline is at the end it wont crash*/
    if(finder<length+1)
    {
      std::string tmp2=tmp1.erase(finder,std::string::npos);
      o->add(tmp2.c_str());
      tmp1=STRING;
      finder=tmp1.find(sep);
      STRING=tmp1.substr(finder+1,std::string::npos);
    }
  }
  if(STRING.length()>0)
    o->add(STRING.c_str());
}

int UI::run(std::string program) {
  std::string shell=get_shell_for_C();
  if(shell.compare("")!=0)
  {
    shell+=program;
    shell+="' &";
  }
  else{shell=program;}
  //trace("run_program::"+shell);
  return system(shell.c_str());
}

bool UI::test_exec(std::string execToTest) {
  if(execToTest.compare("")==0){return false;}
  /** the list of directories it might check*/
  /** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
  std::string stringEXEC;
  std:: string testPATH, testExec;
  bool result = false;
  unsigned int numofpaths = items_in_path();
  for (unsigned int i = 1; i <= numofpaths; i++)
  {
    stringEXEC = execToTest;
    testPATH = current_path(i);
    stringEXEC = testPATH + "/" + stringEXEC;
    if(test_file(stringEXEC.c_str())){return true;}
  }
  return result;
}

bool UI::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

std::string UI::toriosversion() {
  return file_to_string("/usr/share/torios/version");
}

void UI::make_install_list(std::string LIST) {
  install_list_window()->show();
  populateBrowserWithString(install_list,LIST);
}

bool UI::isDebian() {
  std::string deb=term_out("uname -v");
  unsigned int D = deb.find("Debian");
  if(D<deb.length())
    return true;
  
  return false;
}

void UI::open_website(std::string site) {
  char errmsg[512];
  if ( !fl_open_uri(site.c_str(),errmsg, sizeof(errmsg)) )
  {
    char warnmsg[768];
    sprintf(warnmsg, "Error: %s", errmsg);
    fl_alert(warnmsg); 
  }
}

Fl_Double_Window* UI::info_window(std::string MSG) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(270, 260);
    w = o;
    o->user_data((void*)(this));
    { Fl_Text_Display* o = text_info = new Fl_Text_Display(5, 5, 260, 215);
      text_info->box(FL_FLAT_BOX);
      Fl_Group::current()->resizable(text_info);
      Fl_Text_Buffer *a = new Fl_Text_Buffer();o->buffer(a);a->text(MSG.c_str());
    } // Fl_Text_Display* text_info
    { Fl_Button* o = new Fl_Button(200, 225, 65, 30, gettext("Close"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Close1);
    } // Fl_Button* o
    o->end();
  } // Fl_Double_Window* o
  return w;
}

Fl_Double_Window* UI::make_terminal() {
  { term_win = new Fl_Double_Window(320, 275, gettext("Terminal Output"));
    term_win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(240, 235, 65, 30, gettext("Close"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Close2);
    } // Fl_Button* o
    terminal = new Terminal(5, 5, 310, 225);
    term_win->end();
  } // Fl_Double_Window* term_win
  return term_win;
}

std::string UI::term_out(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  std::string result="";
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer), command_p) !=NULL)
    {
      result.append(buffer);
    }
    pclose(command_p);
  }
  else{ return "";}
  if (result.compare("")==0){return "";}
  int end = result.length();
  if((end-1) == 0){return "";}
  if((end) == 0){return "";}
  return result.erase(end-1,1);
}

void UI::show_command(std::string command) {
  term_win->show();
  term_win->wait_for_expose();
  Fl::flush();
  terminal->terminal_output(command);
}

int main(int argc, char*argv[]) {
  std::string current_exec_name = argv[0];
  std::string first_arge;
  if (argc > 1)
  {
    first_arge = argv[1];
  }
  UI *ui = new UI();
  ui->make_window()->show();
  return Fl::run();
}

void trace(std::string msg) {
  std::cout<<msg<<std::endl;
}
