// copyright 2018 Israel Dahl
// GPL 3
// created from the FLTK tutorial using FLUID to design the UI
// created as part of the ToriOS project
// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <libintl.h>
#include "flpad.h"

Fl_Syntax_Text_Editor::Fl_Syntax_Text_Editor(int x, int y, int w, int h, const char* label ):Fl_Text_Editor(x,y,w,h,label) {
  this->resize(x,y,w,h);
  //this->label(label);
  changed=0;
  loading=0;
  filename="";
  RELEASE=false;
  //std::cerr<<"Constructor: new Text Editor="<<this<<std::endl;
  textbuffer = new Fl_Text_Buffer();
  this->buffer(textbuffer);
  char *style = new char[textbuffer->length() + 1];
  char *text = textbuffer->text();
  memset(style, 'A', textbuffer->length());
  stylebuffer = new Fl_Text_Buffer(textbuffer->length());
  style[textbuffer->length()] = '\0';
  init_highlight();
  //style_parse(text, style, textbuffer->length(),12);
  stylebuffer->text(style);
  //std::cerr<<"stylebuffer="<<stylebuffer<<std::endl;
  delete[] style;
  free(text);
  WRAPPED=false;
  box(FL_FLAT_BOX);
  //trace("editor colors");
  theme_editor(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);
  //trace("add modify callback");
  textbuffer->add_modify_callback(changed_cb,(void *)this);
  //textbuffer->call_modify_callbacks();
}

Fl_Syntax_Text_Editor::~Fl_Syntax_Text_Editor() {
  buffer(0);
  textbuffer->remove_modify_callback(style_update, this);
  textbuffer->remove_modify_callback(changed_cb, this);
}

void Fl_Syntax_Text_Editor::changed_cb(int, int nInserted, int nDeleted, int, const char*, void *v) {
  Fl_Syntax_Text_Editor * o = (Fl_Syntax_Text_Editor *)v;
  //std::cerr<<"Editor object="<< o<<std::endl;
  std::string f = o->filename;
  if ((nInserted || nDeleted) && !o->loading)
  {
    o->changed = 1;
  }
  ((UI *)(o->parent()->user_data()))->set_title(o->parent());
}

std::string Fl_Syntax_Text_Editor::file_string() {
  if(filename.compare("")==0){return "";}
  std::ifstream t(filename);
  std::string str;
  
  t.seekg(0, std::ios::end);   
  str.reserve(t.tellg());
  t.seekg(0, std::ios::beg);
  
  str.assign((std::istreambuf_iterator<char>(t)),
              std::istreambuf_iterator<char>());
  return str;
}

void Fl_Syntax_Text_Editor::get_styletable(Fl_Text_Display::Style_Table_Entry &styles,int which) {
  int font = FONT_TEXT;
  int bold = font + 1;
  int ital = bold + 1;
  std::string whichtype="Plain";
  switch(which)
  {
    case 0:
      styles={ FOREGROUND_TEXT, font, FL_NORMAL_SIZE }; // A - Plain
      whichtype="Plain";
      break;
    case 1:
      styles={ COMMENT_TEXT, ital, FL_NORMAL_SIZE }; // B - Line comments
      whichtype="Line comments";
      break;
    case 2:
      styles={ COMMENT_TEXT, ital, FL_NORMAL_SIZE }; // C - Block comments
      whichtype="Block comments";
      break;
    case 3:
      styles={ STRING_TEXT, font, FL_NORMAL_SIZE }; // D - Strings
      whichtype="Strings";
      break;
    case 4:
      styles={ DIRECTIVE_TEXT, font, FL_NORMAL_SIZE }; // E - Directives
      whichtype="Directives";
      break;
    case 5:
      styles={ TYPE_TEXT, bold, FL_NORMAL_SIZE }; // F - Types
      whichtype="Types";
      break;
    case 6:
      styles={ KEYWORD_TEXT, bold, FL_NORMAL_SIZE }; // G - Keywords
      whichtype="Keywords";
      break;
    case 7:
      styles={ NUMBER_TEXT, font, FL_NORMAL_SIZE }; // H - numbers
      whichtype="numbers";
      break;
  }
  styletable[which] = styles; //  set
  //std::cout<<"Got style table for: "<<whichtype<<"\nFONT="<<styles.font<<"\tCOLOR="<<styles.color<<std::endl;
}

int Fl_Syntax_Text_Editor::handle(int event) {
  UI* ui = ((UI*)(parent()->parent()->parent()->user_data()));
  switch(event)
  {
    case FL_PUSH:
    case FL_RELEASE:
      //trace("push/release!");
      if(Fl::event_button() == FL_RIGHT_MOUSE)
      {
        if(Fl::event_clicks())
        {
          break;
        }
        ui->make_popup(this);
        //trace("Right");
        return 1;
      }
      break;
    case FL_DND_DRAG:
    case FL_DND_LEAVE:
    break;
    case FL_DND_RELEASE:
      RELEASE=true;
      break;
    case FL_PASTE:
      if(RELEASE)
      {
        RELEASE=false;
        ui->dnd_file(Fl::event_text());
        return 1;
      }
  }
  return Fl_Text_Editor::handle(event);
}

void Fl_Syntax_Text_Editor::init_highlight() {
  Fl_Text_Display::Style_Table_Entry A; //  Plain
  get_styletable(A,0);
  
  Fl_Text_Display::Style_Table_Entry B; // Line comments
  get_styletable(B,1);
  
  Fl_Text_Display::Style_Table_Entry C; // Block comments
  get_styletable(C,2);
  
  Fl_Text_Display::Style_Table_Entry D; // Strings
  get_styletable(D,3);
  
  Fl_Text_Display::Style_Table_Entry E; // Directives
  get_styletable(E,4);
  
  Fl_Text_Display::Style_Table_Entry F; // Types
  get_styletable(F,5);
  
  Fl_Text_Display::Style_Table_Entry G;  // Keywords
  get_styletable(G,6);
  
  Fl_Text_Display::Style_Table_Entry H; // Numbers
  get_styletable(H,7);
  
  highlight_data(stylebuffer, styletable, sizeof(styletable) / sizeof(styletable[0]), 'A', style_unfinished_cb, 0);
  textbuffer->add_modify_callback(style_update, (void*) this);
}

void Fl_Syntax_Text_Editor::modify_cb(int pos, int nInserted, int nDeleted, int unused, const char * nada) {
  std::string thisLine;
  if ( (HIGHLIGHT_PLAIN==0)&& (STYLE_HEADER.compare("")==0) )
  {
    char *style = new char[textbuffer->length() + 1];
    memset(style, 'A', textbuffer->length());
    style[textbuffer->length()] = '\0';
    stylebuffer->text(style);
  }
  else
  {
    char* buf = textbuffer->text();
    std::string out(buf);
    std::string res = style_line(out);
    char* RES = const_cast <char*> (res.c_str());
    stylebuffer->text(RES);
  }
  redisplay_range(0,stylebuffer->length());
}

void Fl_Syntax_Text_Editor::set_type(std::string fname) {
  std::string dir=fname;
  unsigned int find = dir.rfind("/");
  
  //if there is no directory this isn't correct
  if(find>dir.length())
  {
    // try the PWD if we can
    const char* PWD= getenv("PWD");
    if(PWD!=NULL)
    {
      dir=PWD;
      dir+="/";
      fname=dir+fname;
      filename=fname;
    }
  }
  
  if(fname.empty())
    return;
  STYLE_HEADER = get_type(fname);
  KEYWORDS=keywords(STYLE_HEADER);
  TYPES=types(STYLE_HEADER);
  generator.set_keywords(KEYWORDS);
  generator.set_types(TYPES);
  trace("set syntax type for: "+fname+" to:"+STYLE_HEADER);
}

std::string Fl_Syntax_Text_Editor::style_line(std::string thisLine) {
  if(!generator.process(thisLine))
    trace("error processing text:"+thisLine);
  else
  {
    std::string line =lexertk::helper::style_line(generator);
    if(line.compare("")==0)
    {
      //trace("adding newline!");
      line="\n";
    }
    return line;
  }
  return "A";
}

void Fl_Syntax_Text_Editor::style_update(int pos, int nInserted, int nDeleted, int unused, const char * nada, void *cbArg ) {
  Fl_Syntax_Text_Editor * ED = (Fl_Syntax_Text_Editor *)cbArg;
  if(ED==NULL)
  {
    trace("Couldn't get text editor :(");
    return;
  }
  ED->modify_cb(pos, nInserted, nDeleted, unused, nada);
}

void Fl_Syntax_Text_Editor::style_unfinished_cb(int, void*) {
}

void Fl_Syntax_Text_Editor::theme_editor(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size,int linenum ) {
  textcolor(FG);
  cursor_color(FG);
  color(BG);
  textfont(font);
  textsize(size);
  selection_color(selection);
  linenumber_width(linenum);
  linenumber_size(size);
  ///renew highlighter
  Fl_Text_Display::Style_Table_Entry A; //  Plain
  get_styletable(A,0);
  
  Fl_Text_Display::Style_Table_Entry B; // Line comments
  get_styletable(B,1);
  
  Fl_Text_Display::Style_Table_Entry C; // Block comments
  get_styletable(C,2);
  
  Fl_Text_Display::Style_Table_Entry D; // Strings
  get_styletable(D,3);
  
  Fl_Text_Display::Style_Table_Entry E; // Directives
  get_styletable(E,4);
  
  Fl_Text_Display::Style_Table_Entry F; // Types
  get_styletable(F,5);
  
  Fl_Text_Display::Style_Table_Entry G;  // Keywords
  get_styletable(G,6);
  
  Fl_Text_Display::Style_Table_Entry H; // Numbers
  get_styletable(H,7);
  
  highlight_data(stylebuffer, styletable, sizeof(styletable) / sizeof(styletable[0]), 'A', style_unfinished_cb, 0);
  
  
  char *style = stylebuffer->text();
  char *text = textbuffer->text();
  modify_cb();
  //style_parse(text, style, textbuffer->length(),12);
  delete[] style;
  free(text);
}

void Fl_Syntax_Text_Editor::refresh() {
  style_update(0,0,0,0,NULL,this);
  redisplay_range(0,textbuffer->length());
  redraw();
}

void UI::cb_Close_i(Fl_Button*, void*) {
  about_win->hide();
}
void UI::cb_Close(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void UI::cb_replace_cancel_i(Fl_Button*, void*) {
  replace_dlg->hide();
}
void UI::cb_replace_cancel(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_replace_cancel_i(o,v);
}

void UI::cb_replace_all_i(Fl_Button*, void*) {
  replall_cb();
}
void UI::cb_replace_all(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_replace_all_i(o,v);
}

void UI::cb_replace_next_i(Fl_Button*, void*) {
  replace2_cb();
}
void UI::cb_replace_next(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_replace_next_i(o,v);
}

void UI::cb_New_i(Fl_Menu_*, void*) {
  new_cb();
}
void UI::cb_New(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_New_i(o,v);
}

void UI::cb_Open_i(Fl_Menu_*, void*) {
  open_cb();
}
void UI::cb_Open(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

void UI::cb_Insert_i(Fl_Menu_*, void*) {
  insert_cb();
}
void UI::cb_Insert(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Insert_i(o,v);
}

void UI::cb_Save_i(Fl_Menu_*, void*) {
  save_cb();
}
void UI::cb_Save(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void UI::cb_Save1_i(Fl_Menu_*, void*) {
  saveas_cb();
}
void UI::cb_Save1(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Save1_i(o,v);
}

void UI::cb_Exit_i(Fl_Menu_*, void*) {
  quit_cb();
}
void UI::cb_Exit(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

void UI::cb_Undo_i(Fl_Menu_*, void*) {
  undo_cb();
}
void UI::cb_Undo(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Undo_i(o,v);
}

void UI::cb_Cut_i(Fl_Menu_*, void*) {
  cut_cb();
}
void UI::cb_Cut(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Cut_i(o,v);
}

void UI::cb_Copy_i(Fl_Menu_*, void*) {
  copy_cb();
}
void UI::cb_Copy(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Copy_i(o,v);
}

void UI::cb_Paste_i(Fl_Menu_*, void*) {
  paste_cb();
}
void UI::cb_Paste(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Paste_i(o,v);
}

void UI::cb_Select_i(Fl_Menu_*, void*) {
  Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_select_all(0,textor);
}
void UI::cb_Select(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Select_i(o,v);
}

void UI::cb_Preferences_i(Fl_Menu_*, void*) {
  pref_window()->show();
}
void UI::cb_Preferences(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Preferences_i(o,v);
}

void UI::cb_Word_i(Fl_Menu_*, void*) {
  wordwrap();
}
void UI::cb_Word(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Word_i(o,v);
}

void UI::cb_Find_i(Fl_Menu_*, void*) {
  find_cb();
}
void UI::cb_Find(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Find_i(o,v);
}

void UI::cb_F_i(Fl_Menu_*, void*) {
  find2_cb();
}
void UI::cb_F(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_F_i(o,v);
}

void UI::cb_Replace_i(Fl_Menu_*, void*) {
  replace_cb();
}
void UI::cb_Replace(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Replace_i(o,v);
}

void UI::cb_Re_i(Fl_Menu_*, void*) {
  replace2_cb();
}
void UI::cb_Re(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Re_i(o,v);
}

void UI::cb_Go_i(Fl_Menu_*, void*) {
  goto_cb();
}
void UI::cb_Go(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Go_i(o,v);
}

void UI::cb_About_i(Fl_Menu_*, void*) {
  about_window()->show();
}
void UI::cb_About(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_About_i(o,v);
}

unsigned char UI::menu_menu_i18n_done = 0;
Fl_Menu_Item UI::menu_menu[] = {
 {"&File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&New", 0,  (Fl_Callback*)UI::cb_New, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0,  (Fl_Callback*)UI::cb_Open, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Insert", 0,  (Fl_Callback*)UI::cb_Insert, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Save", 0,  (Fl_Callback*)UI::cb_Save, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save &As...", 0,  (Fl_Callback*)UI::cb_Save1, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Exit", 0,  (Fl_Callback*)UI::cb_Exit, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Edit", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 16, 0},
 {"&Undo", 0,  (Fl_Callback*)UI::cb_Undo, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Cut", 0,  (Fl_Callback*)UI::cb_Cut, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 16, 0},
 {"&Copy", 0,  (Fl_Callback*)UI::cb_Copy, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Paste", 0,  (Fl_Callback*)UI::cb_Paste, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Select &All", 0,  (Fl_Callback*)UI::cb_Select, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Preferences", 0,  (Fl_Callback*)UI::cb_Preferences, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Word Wrap Toggle", 0,  (Fl_Callback*)UI::cb_Word, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Search", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Find", 0,  (Fl_Callback*)UI::cb_Find, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"F&ind Next", 0,  (Fl_Callback*)UI::cb_F, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Replace", 0,  (Fl_Callback*)UI::cb_Replace, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Re&place Next", 0,  (Fl_Callback*)UI::cb_Re, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Go to Line", 0,  (Fl_Callback*)UI::cb_Go, 0, 17, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0,  (Fl_Callback*)UI::cb_About, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_add_button_i(Fl_Button*, void*) {
  add_tab(false);
}
void UI::cb_add_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_add_button_i(o,v);
}

void UI::cb_remove_button_i(Fl_Button*, void*) {
  close_tab();
}
void UI::cb_remove_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_remove_button_i(o,v);
}

void UI::cb_open_button_i(Fl_Button*, void*) {
  open_cb();
}
void UI::cb_open_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_open_button_i(o,v);
}

void UI::cb_save_button_i(Fl_Button*, void*) {
  save_cb();
}
void UI::cb_save_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_save_button_i(o,v);
}

void UI::cb_new_button_i(Fl_Button*, void*) {
  new_cb();
}
void UI::cb_new_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_new_button_i(o,v);
}

void UI::cb_undo_button_i(Fl_Button*, void*) {
  undo_cb();
}
void UI::cb_undo_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_undo_button_i(o,v);
}

void UI::cb_find_button_i(Fl_Button*, void*) {
  find_cb();
}
void UI::cb_find_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_find_button_i(o,v);
}

void UI::cb_replace_button_i(Fl_Button*, void*) {
  replace_cb();
}
void UI::cb_replace_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_replace_button_i(o,v);
}

void UI::cb_cp_button_i(Fl_Button*, void*) {
  copy_cb();
}
void UI::cb_cp_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_cp_button_i(o,v);
}

void UI::cb_p_button_i(Fl_Button*, void*) {
  paste_cb();
}
void UI::cb_p_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_p_button_i(o,v);
}

void UI::cb_settings_button_i(Fl_Button*, void*) {
  pref_window()->show();
}
void UI::cb_settings_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_settings_button_i(o,v);
}

void UI::cb_cut_button_i(Fl_Button*, void*) {
  cut_cb();
}
void UI::cb_cut_button(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->user_data()))->cb_cut_button_i(o,v);
}

void UI::cb_tabs_i(Fl_Tabs* o, void*) {
  set_title(o->value());
}
void UI::cb_tabs(Fl_Tabs* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_tabs_i(o,v);
}

void UI::cb_font_b_i(Fl_Browser* o, void*) {
  int F = o->value();
font_save->value(F);
const char* fonty = o->text(F);
if(fonty==NULL){return;}
font_show->value(fonty);
font_show->textfont(F);
font_show->redraw();
}
void UI::cb_font_b(Fl_Browser* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_font_b_i(o,v);
}

void UI::cb_tool_color_i(Fl_Check_Button* o, void*) {
  int val=o->value();
button_style(val);
}
void UI::cb_tool_color(Fl_Check_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_tool_color_i(o,v);
}

void UI::cb_tExt_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_tExt(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_tExt_i(o,v);
}

void UI::cb_f_s_i(Fl_Slider* o, void*) {
  fsout->value(o->value());
}
void UI::cb_f_s(Fl_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_f_s_i(o,v);
}

void UI::cb_fsout_i(Fl_Value_Input* o, void*) {
  f_s->value(o->value());
}
void UI::cb_fsout(Fl_Value_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_fsout_i(o,v);
}

void UI::cb_l_s_i(Fl_Slider* o, void*) {
  lsout->value(o->value());
}
void UI::cb_l_s(Fl_Slider* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_l_s_i(o,v);
}

void UI::cb_lsout_i(Fl_Value_Input* o, void*) {
  l_s->value(o->value());
}
void UI::cb_lsout(Fl_Value_Input* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_lsout_i(o,v);
}

void UI::cb_bg_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_bg(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_bg_i(o,v);
}

void UI::cb_cm_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_cm(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_cm_i(o,v);
}

void UI::cb_str_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_str(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_str_i(o,v);
}

void UI::cb_directives_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_directives(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_directives_i(o,v);
}

void UI::cb_typezz_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_typezz(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_typezz_i(o,v);
}

void UI::cb_keywordz_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_keywordz(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_keywordz_i(o,v);
}

void UI::cb_numbers_i(Fl_Button* o, void*) {
  choose_a_color(o);
}
void UI::cb_numbers(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_numbers_i(o,v);
}

void UI::cb_Light_i(Fl_Menu_*, void*) {
  default_theme();
colorize_syntax_buttons();
}
void UI::cb_Light(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Light_i(o,v);
}

void UI::cb_Dark_i(Fl_Menu_*, void*) {
  dark_theme();
colorize_syntax_buttons();
}
void UI::cb_Dark(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_Dark_i(o,v);
}

void UI::cb_None_i(Fl_Menu_*, void*) {
  none_theme();
colorize_syntax_buttons();
}
void UI::cb_None(Fl_Menu_* o, void* v) {
  ((UI*)(o->parent()->parent()->parent()->user_data()))->cb_None_i(o,v);
}

unsigned char UI::menu_Theme_i18n_done = 0;
Fl_Menu_Item UI::menu_Theme[] = {
 {"Light Background", 0,  (Fl_Callback*)UI::cb_Light, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Dark Background", 0,  (Fl_Callback*)UI::cb_Dark, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"None", 0,  (Fl_Callback*)UI::cb_None, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void UI::cb_Cancel_i(Fl_Button* o, void*) {
  o->parent()->hide();
}
void UI::cb_Cancel(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void UI::cb_SAVE_i(Fl_Button* o, void*) {
  FOREGROUND_TEXT=tExt->color();
BACKGROUND_TEXT=bg->color();
SIZE_TEXT=f_s->value();
LINE_NUMBERS=l_s->value();
FONT_TEXT=font_save->value();
BUTTON_COLOR=tool_color->value();
COMMENT_TEXT=cm->color();
STRING_TEXT=str->color();
DIRECTIVE_TEXT=directives->color();
TYPE_TEXT=typezz->color();
KEYWORD_TEXT=keywordz->color();
NUMBER_TEXT=numbers->color();
HIGHLIGHT_PLAIN=plain_text->value();
if(!save_preferences())
{
  trace("Failed to save preferences");
}
refresh_all();
o->parent()->hide();
}
void UI::cb_SAVE(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_SAVE_i(o,v);
}

UI::UI() {
  get_preferences();
  RELEASE=false;
}

Fl_Double_Window* UI::about_window() {
  { about_win = new Fl_Double_Window(250, 240, gettext("About"));
    about_win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(160, 205, 80, 30, gettext("Close"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Button* o
    { Fl_Box* o = new Fl_Box(0, 0, 250, 200, gettext("Designed in FLUID, based on the FLTK tutorial\nCopyright 1998-2005 by Bill Sp\
itzak and others.\n\nThis version was built for ToriOS\ncopyright 2018 Israel \
Dahl"));
      o->box(FL_FLAT_BOX);
      o->color(FL_BACKGROUND2_COLOR);
      o->align(Fl_Align(FL_ALIGN_WRAP));
    } // Fl_Box* o
    about_win->xclass("flpad");
    about_win->end();
  } // Fl_Double_Window* about_win
  return about_win;
}

void UI::make_popup(Fl_Widget *o) {
  Fl_Menu_Item rclick_menu[] = {
    { "Copy",  0, handle_menu, (void*)1 },
    { "Cut",  0, handle_menu, (void*)2 },
    { "Find",  0, handle_menu, (void*)3 },
    { "Paste",  0, handle_menu, (void*)4 },
    { "Undo",  0, handle_menu, (void*)5 },
    { 0 }
  };
  Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)o->user_data());
  UI* ui = ((UI*)T->user_data());
  
  const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, ui->menu);
  if ( m )
  {
  
    m->do_callback(o, m->user_data());
  }
  return;
}

Fl_Double_Window* UI::make_replace() {
  { replace_dlg = new Fl_Double_Window(375, 100, gettext("Find and Replace"));
    replace_dlg->user_data((void*)(this));
    { replace_find = new Fl_Input(70, 5, 295, 25, gettext("Find"));
      replace_find->box(FL_FLAT_BOX);
      replace_start();
    } // Fl_Input* replace_find
    { replace_with = new Fl_Input(70, 35, 295, 25, gettext("Replace"));
      replace_with->box(FL_FLAT_BOX);
    } // Fl_Input* replace_with
    { replace_cancel = new Fl_Button(295, 65, 70, 30, gettext("Cancel"));
      replace_cancel->box(FL_FLAT_BOX);
      replace_cancel->color((Fl_Color)80);
      replace_cancel->labelcolor(FL_BACKGROUND2_COLOR);
      replace_cancel->callback((Fl_Callback*)cb_replace_cancel);
    } // Fl_Button* replace_cancel
    { replace_all = new Fl_Button(185, 65, 95, 30, gettext("Replace All"));
      replace_all->box(FL_FLAT_BOX);
      replace_all->color((Fl_Color)94);
      replace_all->callback((Fl_Callback*)cb_replace_all);
    } // Fl_Button* replace_all
    { replace_next = new Fl_Button(70, 65, 100, 30, gettext("Replace Next"));
      replace_next->box(FL_FLAT_BOX);
      replace_next->color((Fl_Color)61);
      replace_next->labelcolor(FL_BACKGROUND2_COLOR);
      replace_next->callback((Fl_Callback*)cb_replace_next);
    } // Fl_Button* replace_next
    replace_dlg->xclass("flpad");
    replace_dlg->end();
  } // Fl_Double_Window* replace_dlg
  return replace_dlg;
}

Fl_Double_Window* UI::make_window() {
  { Fl_Double_Window* o = win = new Fl_Double_Window(520, 545, gettext("FLTK Pad"));
    win->color(FL_DARK1);
    win->user_data((void*)(this));
    { menu = new Fl_Menu_Bar(0, 0, 520, 25);
      menu->box(FL_FLAT_BOX);
      menu->down_box(FL_FLAT_BOX);
      menu->color(FL_DARK3);
      menu->selection_color((Fl_Color)80);
      menu->labelsize(16);
      menu->labelcolor(FL_BACKGROUND2_COLOR);
      menu->textsize(16);
      menu->textcolor(FL_BACKGROUND2_COLOR);
      menu->align(Fl_Align(260));
      { Fl_Menu_Item* o = &menu_menu[1];
        o->shortcut(FL_COMMAND+'n');
      }
      { Fl_Menu_Item* o = &menu_menu[2];
        o->shortcut(FL_COMMAND+'o');
      }
      { Fl_Menu_Item* o = &menu_menu[3];
        o->shortcut(FL_COMMAND+'i');
      }
      { Fl_Menu_Item* o = &menu_menu[4];
        o->shortcut(FL_COMMAND+'s');
      }
      { Fl_Menu_Item* o = &menu_menu[5];
        o->shortcut(FL_COMMAND+FL_SHIFT+'s');
      }
      { Fl_Menu_Item* o = &menu_menu[9];
        o->shortcut(FL_COMMAND+'z');
      }
      { Fl_Menu_Item* o = &menu_menu[10];
        o->shortcut(FL_COMMAND+'x');
      }
      { Fl_Menu_Item* o = &menu_menu[11];
        o->shortcut(FL_COMMAND+'c');
      }
      { Fl_Menu_Item* o = &menu_menu[12];
        o->shortcut(FL_COMMAND+'v');
      }
      { Fl_Menu_Item* o = &menu_menu[13];
        o->shortcut(FL_COMMAND+'a');
      }
      { Fl_Menu_Item* o = &menu_menu[18];
        o->shortcut(FL_COMMAND+'f');
      }
      { Fl_Menu_Item* o = &menu_menu[19];
        o->shortcut(FL_COMMAND+'g');
      }
      { Fl_Menu_Item* o = &menu_menu[20];
        o->shortcut(FL_COMMAND+'r');
      }
      { Fl_Menu_Item* o = &menu_menu[21];
        o->shortcut(FL_COMMAND+'t');
      }
      if (!menu_menu_i18n_done) {
        int i=0;
        for ( ; i<26; i++)
          if (menu_menu[i].label())
            menu_menu[i].label(gettext(menu_menu[i].label()));
        menu_menu_i18n_done = 1;
      }
      menu->menu(menu_menu);
    } // Fl_Menu_Bar* menu
    { buttons = new Fl_Group(0, 25, 520, 30);
      buttons->box(FL_FLAT_BOX);
      { add_button = new Fl_Button(492, 27, 25, 25, gettext("@+"));
        add_button->tooltip(gettext("Add a Tab"));
        add_button->box(FL_FLAT_BOX);
        add_button->color((Fl_Color)23);
        add_button->callback((Fl_Callback*)cb_add_button);
      } // Fl_Button* add_button
      { Fl_Button* o = remove_button = new Fl_Button(463, 27, 25, 25);
        remove_button->tooltip(gettext("Remove current Tab"));
        remove_button->box(FL_FLAT_BOX);
        remove_button->color((Fl_Color)23);
        remove_button->labelfont(1);
        remove_button->labelsize(18);
        remove_button->callback((Fl_Callback*)cb_remove_button);
        o->image(close_image);
      } // Fl_Button* remove_button
      { Fl_Button* o = open_button = new Fl_Button(5, 27, 25, 25);
        open_button->tooltip(gettext("Open"));
        open_button->box(FL_FLAT_BOX);
        open_button->labelfont(1);
        open_button->callback((Fl_Callback*)cb_open_button);
        o->image(color_open_image);
      } // Fl_Button* open_button
      { Fl_Button* o = save_button = new Fl_Button(35, 27, 25, 25);
        save_button->tooltip(gettext("Save"));
        save_button->box(FL_FLAT_BOX);
        save_button->labelfont(1);
        save_button->callback((Fl_Callback*)cb_save_button);
        o->image(color_save_image);
      } // Fl_Button* save_button
      { Fl_Button* o = new_button = new Fl_Button(65, 27, 25, 25);
        new_button->tooltip(gettext("New"));
        new_button->box(FL_FLAT_BOX);
        new_button->labelfont(1);
        new_button->callback((Fl_Callback*)cb_new_button);
        o->image(color_new_image);
      } // Fl_Button* new_button
      { Fl_Button* o = undo_button = new Fl_Button(95, 27, 25, 25);
        undo_button->tooltip(gettext("Undo"));
        undo_button->box(FL_FLAT_BOX);
        undo_button->labelfont(1);
        undo_button->callback((Fl_Callback*)cb_undo_button);
        o->image(color_undo_image);
      } // Fl_Button* undo_button
      { Fl_Button* o = find_button = new Fl_Button(145, 27, 25, 25);
        find_button->tooltip(gettext("Find"));
        find_button->box(FL_FLAT_BOX);
        find_button->labelfont(1);
        find_button->callback((Fl_Callback*)cb_find_button);
        o->image(color_search_image);
      } // Fl_Button* find_button
      { Fl_Button* o = replace_button = new Fl_Button(175, 27, 25, 25);
        replace_button->tooltip(gettext("Replace"));
        replace_button->box(FL_FLAT_BOX);
        replace_button->labelfont(1);
        replace_button->callback((Fl_Callback*)cb_replace_button);
        o->image(color_replace_image);
      } // Fl_Button* replace_button
      { Fl_Button* o = cp_button = new Fl_Button(220, 27, 25, 25);
        cp_button->tooltip(gettext("Copy current selection"));
        cp_button->box(FL_FLAT_BOX);
        cp_button->labelfont(1);
        cp_button->callback((Fl_Callback*)cb_cp_button);
        o->image(color_copy_image);
      } // Fl_Button* cp_button
      { Fl_Button* o = p_button = new Fl_Button(250, 27, 25, 25);
        p_button->tooltip(gettext("Paste current clipboard"));
        p_button->box(FL_FLAT_BOX);
        p_button->labelfont(1);
        p_button->callback((Fl_Callback*)cb_p_button);
        o->image(color_paste_image);
      } // Fl_Button* p_button
      { Fl_Button* o = settings_button = new Fl_Button(430, 27, 25, 25);
        settings_button->tooltip(gettext("Settings"));
        settings_button->box(FL_FLAT_BOX);
        settings_button->labelfont(1);
        settings_button->callback((Fl_Callback*)cb_settings_button);
        o->image(settings_image);
      } // Fl_Button* settings_button
      { Fl_Button* o = cut_button = new Fl_Button(280, 27, 25, 25);
        cut_button->tooltip(gettext("Paste current clipboard"));
        cut_button->box(FL_FLAT_BOX);
        cut_button->labelfont(1);
        cut_button->callback((Fl_Callback*)cb_cut_button);
        o->image(color_cut_image);
      } // Fl_Button* cut_button
      buttons->end();
    } // Fl_Group* buttons
    { tabs = new Fl_Tabs(0, 55, 520, 485);
      tabs->box(FL_FLAT_BOX);
      tabs->selection_color((Fl_Color)23);
      tabs->callback((Fl_Callback*)cb_tabs);
      tabs->when(3);
      add_tab(false);
      button_style(BUTTON_COLOR);
      tabs->end();
    } // Fl_Tabs* tabs
    //Fl::event_dispatch(handle);
    o->size_range(o->w(), o->h(), 0, 0);
    make_icon(o);
    win->xclass("flpad");
    win->end();
  } // Fl_Double_Window* win
  return win;
}

Fl_Double_Window* UI::pref_window() {
  { pref_win = new Fl_Double_Window(310, 460, gettext("Preferences"));
    pref_win->color((Fl_Color)46);
    pref_win->user_data((void*)(this));
    { pref_tabs = new Fl_Tabs(0, 0, 310, 420);
      pref_tabs->box(FL_FLAT_BOX);
      { gen = new Fl_Group(0, 25, 310, 395, gettext("General"));
        gen->selection_color((Fl_Color)43);
        { Fl_Browser* o = font_b = new Fl_Browser(5, 55, 290, 175, gettext("Font"));
          font_b->tooltip(gettext("Browse system installed fonts"));
          font_b->type(2);
          font_b->box(FL_FLAT_BOX);
          font_b->selection_color((Fl_Color)80);
          font_b->callback((Fl_Callback*)cb_font_b);
          font_b->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          font_populate(o);
          o->value(FONT_TEXT);
        } // Fl_Browser* font_b
        { Fl_Output* o = font_show = new Fl_Output(5, 240, 255, 30);
          font_show->tooltip(gettext("Sample text to show font"));
          font_show->box(FL_FLAT_BOX);
          font_show->selection_color((Fl_Color)80);
          const char* F = font_b->text(font_b->value());
          if( F!=NULL){o->value(F);}
        } // Fl_Output* font_show
        { Fl_Value_Output* o = font_save = new Fl_Value_Output(265, 240, 30, 30);
          font_save->tooltip(gettext("Font Numeric for use in config file"));
          font_save->box(FL_BORDER_BOX);
          font_save->color((Fl_Color)35);
          font_save->textcolor(FL_BACKGROUND2_COLOR);
          o->value(font_b->value());
        } // Fl_Value_Output* font_save
        { Fl_Check_Button* o = tool_color = new Fl_Check_Button(5, 270, 175, 30, gettext("Toolbar Button Color"));
          tool_color->tooltip(gettext("Use color in the tool bar icons?"));
          tool_color->down_box(FL_GTK_DOWN_BOX);
          tool_color->value(1);
          tool_color->selection_color(FL_GREEN);
          tool_color->callback((Fl_Callback*)cb_tool_color);
          tool_color->align(Fl_Align(36|FL_ALIGN_INSIDE));
          o->value(BUTTON_COLOR);
        } // Fl_Check_Button* tool_color
        { Fl_Button* o = tExt = new Fl_Button(25, 315, 55, 30, gettext("Color"));
          tExt->tooltip(gettext("Text color"));
          tExt->box(FL_BORDER_BOX);
          tExt->color((Fl_Color)23);
          tExt->callback((Fl_Callback*)cb_tExt);
          tExt->align(Fl_Align(FL_ALIGN_TOP));
          o->color(FOREGROUND_TEXT);
        } // Fl_Button* tExt
        { Fl_Slider* o = f_s = new Fl_Slider(115, 310, 135, 30, gettext("Font Size"));
          f_s->tooltip(gettext("Size of the text"));
          f_s->type(1);
          f_s->box(FL_GTK_DOWN_BOX);
          f_s->color((Fl_Color)38);
          f_s->minimum(2);
          f_s->maximum(128);
          f_s->step(1);
          f_s->callback((Fl_Callback*)cb_f_s);
          f_s->align(Fl_Align(FL_ALIGN_TOP));
          o->value( SIZE_TEXT );
        } // Fl_Slider* f_s
        { Fl_Value_Input* o = fsout = new Fl_Value_Input(260, 310, 30, 30);
          fsout->tooltip(gettext("Size of the text"));
          fsout->box(FL_FLAT_BOX);
          fsout->selection_color((Fl_Color)80);
          fsout->callback((Fl_Callback*)cb_fsout);
          o->value( SIZE_TEXT );
        } // Fl_Value_Input* fsout
        { Fl_Slider* o = l_s = new Fl_Slider(115, 355, 135, 30, gettext("Line Number Size"));
          l_s->tooltip(gettext("0 hides line numbers"));
          l_s->type(1);
          l_s->box(FL_GTK_DOWN_BOX);
          l_s->color((Fl_Color)38);
          l_s->maximum(128);
          l_s->step(1);
          l_s->callback((Fl_Callback*)cb_l_s);
          l_s->align(Fl_Align(FL_ALIGN_TOP));
          o->value(LINE_NUMBERS);
        } // Fl_Slider* l_s
        { Fl_Value_Input* o = lsout = new Fl_Value_Input(260, 355, 30, 30);
          lsout->tooltip(gettext("0 hides line numbers"));
          lsout->box(FL_FLAT_BOX);
          lsout->selection_color((Fl_Color)80);
          lsout->callback((Fl_Callback*)cb_lsout);
          o->value(LINE_NUMBERS);
        } // Fl_Value_Input* lsout
        { Fl_Button* o = bg = new Fl_Button(25, 380, 55, 30, gettext("Background Color"));
          bg->tooltip(gettext("Editor background color"));
          bg->box(FL_BORDER_BOX);
          bg->color((Fl_Color)23);
          bg->callback((Fl_Callback*)cb_bg);
          bg->align(Fl_Align(129));
          o->color(BACKGROUND_TEXT);
        } // Fl_Button* bg
        gen->end();
      } // Fl_Group* gen
      { syntax = new Fl_Group(0, 25, 310, 395, gettext("Syntax Highlighting"));
        syntax->selection_color((Fl_Color)43);
        syntax->hide();
        { Fl_Button* o = cm = new Fl_Button(25, 65, 55, 30, gettext("Comments"));
          cm->tooltip(gettext("The color of comments"));
          cm->box(FL_BORDER_BOX);
          cm->color((Fl_Color)23);
          cm->callback((Fl_Callback*)cb_cm);
          cm->align(Fl_Align(129));
          o->color( COMMENT_TEXT );
        } // Fl_Button* cm
        { Fl_Button* o = str = new Fl_Button(105, 65, 55, 30, gettext("Strings"));
          str->tooltip(gettext("The color of strings"));
          str->box(FL_BORDER_BOX);
          str->color((Fl_Color)23);
          str->callback((Fl_Callback*)cb_str);
          str->align(Fl_Align(129));
          o->color( STRING_TEXT );
        } // Fl_Button* str
        { Fl_Button* o = directives = new Fl_Button(25, 115, 55, 30, gettext("Symbols"));
          directives->tooltip(gettext("The color of symbols"));
          directives->box(FL_BORDER_BOX);
          directives->color((Fl_Color)23);
          directives->callback((Fl_Callback*)cb_directives);
          directives->align(Fl_Align(129));
          o->color( DIRECTIVE_TEXT );
        } // Fl_Button* directives
        { Fl_Button* o = typezz = new Fl_Button(105, 115, 55, 30, gettext("Types"));
          typezz->tooltip(gettext("The color of types"));
          typezz->box(FL_BORDER_BOX);
          typezz->color((Fl_Color)23);
          typezz->callback((Fl_Callback*)cb_typezz);
          typezz->align(Fl_Align(129));
          o->color( TYPE_TEXT );
        } // Fl_Button* typezz
        { Fl_Button* o = keywordz = new Fl_Button(25, 170, 55, 30, gettext("Keywords"));
          keywordz->tooltip(gettext("The color of keywords"));
          keywordz->box(FL_BORDER_BOX);
          keywordz->color((Fl_Color)23);
          keywordz->callback((Fl_Callback*)cb_keywordz);
          keywordz->align(Fl_Align(129));
          o->color( KEYWORD_TEXT );
        } // Fl_Button* keywordz
        { Fl_Button* o = numbers = new Fl_Button(105, 170, 55, 30, gettext("Numbers"));
          numbers->tooltip(gettext("The color of numbers"));
          numbers->box(FL_BORDER_BOX);
          numbers->color((Fl_Color)23);
          numbers->callback((Fl_Callback*)cb_numbers);
          numbers->align(Fl_Align(129));
          o->color( NUMBER_TEXT );
        } // Fl_Button* numbers
        { Fl_Menu_Button* o = new Fl_Menu_Button(25, 210, 135, 30, gettext("Theme"));
          o->box(FL_BORDER_BOX);
          o->color((Fl_Color)23);
          o->selection_color(FL_DARK_RED);
          if (!menu_Theme_i18n_done) {
            int i=0;
            for ( ; i<3; i++)
              if (menu_Theme[i].label())
                menu_Theme[i].label(gettext(menu_Theme[i].label()));
            menu_Theme_i18n_done = 1;
          }
          o->menu(menu_Theme);
        } // Fl_Menu_Button* o
        { Fl_Check_Button* o = plain_text = new Fl_Check_Button(25, 250, 25, 25, gettext("Highlight Plain text?"));
          plain_text->tooltip(gettext("Highlight quotes, numbers, brackets, etc... on plain text"));
          plain_text->down_box(FL_GTK_DOWN_BOX);
          plain_text->color((Fl_Color)55);
          plain_text->selection_color(FL_GREEN);
          o->value(HIGHLIGHT_PLAIN);
        } // Fl_Check_Button* plain_text
        syntax->end();
      } // Fl_Group* syntax
      pref_tabs->end();
    } // Fl_Tabs* pref_tabs
    { Fl_Button* o = new Fl_Button(170, 425, 65, 30, gettext("Cancel"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Cancel);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(240, 425, 65, 30, gettext("SAVE"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)62);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_SAVE);
    } // Fl_Button* o
    pref_win->xclass("flpad");
    pref_win->end();
  } // Fl_Double_Window* pref_win
  return pref_win;
}

void UI::add_tab(bool LOAD, bool NEW ) {
  int y = menu->y()+tabs->y()+add_button->y();
  int h = tabs->h();
  int w = tabs->w();
  int x = tabs->x();
  Fl_Group* o = new Fl_Group(x, y, w, h);
  o->copy_label("Untitled");
  Fl_Syntax_Text_Editor* te = new Fl_Syntax_Text_Editor(x, y,w, h);
  te->user_data(o);
  o->user_data(this);
  win->resizable(te);
  //te->when(3);
  o->end();
  tabs->resizable(o);
  tabs->add(o);
  tabs->redraw();
  tabs->value(o);
  if(LOAD)
    open_file(NEW);
  refresh_all();
}

int UI::ask(std::string MSG, std::string yes, std::string no, std::string other) {
  int w = 250;
  int h = 90;
  Fl_Double_Window* ask_win = new Fl_Double_Window(w, h);
  Fl_Box* o = new Fl_Box(5, 5, 5, 5);
  o->copy_label(MSG.c_str());
  o->redraw();
  Fl_Button* o1 = new Fl_Button(170, 55, 65, 30, yes.c_str());
  o1->box(FL_FLAT_BOX);
  o1->color((Fl_Color)62);
  o1->labelcolor(FL_BACKGROUND2_COLOR);
  o1->callback(ask_cb,1);
  Fl_Button* o2 = new Fl_Button(100, 55, 65, 30, no.c_str());
  o2->box(FL_FLAT_BOX);
  o2->color((Fl_Color)80);
  o2->labelcolor(FL_BACKGROUND2_COLOR);
  o2->callback(ask_cb,0);
  if(other.compare("")!=0)
  {
    Fl_Button* o3 = new Fl_Button(30, 55, 65, 30, other.c_str());
    o3->box(FL_FLAT_BOX);
    o3->color((Fl_Color)94);
    o3->labelcolor(FL_BACKGROUND2_COLOR);
    o3->callback(ask_cb,2);
  }
  else
  {
    o1->position(5,o1->y());
    o2->position(10+o1->w(),o1->y());
    
  }
  ask_win->end();
  ask_win->show();
  o->measure_label(w,h);
  o->size(w+10,h);
  if(other.compare("")!=0)
  {
    if(w<ask_win->w())
       w=ask_win->w()+10;
    else
      w+=10;
    if(h<ask_win->h())
      h=ask_win->h();
    else
      h +=10;
  }
  else
  {
    int W = o2->x()+o2->w()+5;
    if(w<W)
       w=W;
    else if (w < W +10)
      w=W+10;
    else
      w+=10;
    if(h<ask_win->h())
      h=ask_win->h();
    else
      h +=10;
  }
  ask_win->size(w,h);
  while (ask_win->shown()) Fl::wait();
  return ret_val;
}

void UI::ask_cb(Fl_Widget *o, long val) {
  ret_val = (int) val;
  o->parent()->hide();
}

void UI::button_style(int style) {
  if(style==0)
  {
  open_button->image(open_image);
  save_button->image(save_image);
  new_button->image(new_image);
  undo_button->image(undo_image);
  find_button->image(search_image);
  replace_button->image(replace_image);
  cp_button->image(copy_image);
  p_button->image(paste_image);
  cut_button->image(cut_image);
  }
  else
  {
  open_button->image(color_open_image);
  save_button->image(color_save_image);
  new_button->image(color_new_image);
  undo_button->image(color_undo_image);
  find_button->image(color_search_image);
  replace_button->image(color_replace_image);
  cp_button->image(color_copy_image);
  p_button->image(color_paste_image);
  cut_button->image(color_cut_image);
  }
  
  open_button->redraw();
  save_button->redraw();
  new_button->redraw();
  undo_button->redraw();
  find_button->redraw();
  replace_button->redraw();
  cp_button->redraw();
  p_button->redraw();
  cut_button->redraw();
}

void UI::change_theme(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size, int line) {
  FOREGROUND_TEXT=FG;
  BACKGROUND_TEXT=BG;
  SELECTION_TEXT=selection;
  FONT_TEXT=font;
  SIZE_TEXT=size;
  LINE_NUMBERS=line;
  if(tabs==NULL)
    return;
  for(int i = 0; i < tabs->children();i++)
  {
    Fl_Group* tab = tabs->child(i)->as_group();
    Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
    e->theme_editor(FG,BG,selection,font,size,line);
  }
}

int UI::check_save() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
  {
    return 1;
  }
  if (!E->changed)
    return 1;
  int r = ask("The current file has not been saved.\n" "Would you like to save it now?", "Save", "Cancel","Discard");
  if (r == 1) {
    save_cb(); // Save the file...
    return !E->changed;
  }
  return (r == 2) ? 1 : 0;
}

unsigned int UI::choose_a_color(Fl_Widget *o) {
  uchar r;
  uchar g;
  uchar b;
  Fl::get_color((o->color()),r,g,b);
  int c;
  const char * label ="Choose a Color";
  c= fl_color_chooser(label,r,g,b,2);
  if(c!=1)
    return o->color();
  unsigned int C = fl_rgb_color(r,g,b);
  o->color(C);
  o->redraw();
  return o->color();
}

void UI::choose_doc(Fl_Widget* o, void* v) {
  Fl_Menu_Bar *m = (Fl_Menu_Bar*)o;
  const Fl_Menu_Item *p = m->mvalue();
  const char* txt=p->label();
  if(txt==NULL)
    return;
  trace(txt);
  ((UI*)(p->user_data()))->pick_tab(txt);
}

void UI::close_tab() {
  Fl_Widget * E = tabs->value();
  if(E==NULL)
  {
    if(ask("Exit?", "Yes", "No"))
      exit(0);
  }
  Fl_Group* curr = tabs->value()->as_group();
  if(!check_save())
    return;
  trace("Looking for correct tab");
  Fl_Syntax_Text_Editor *T = NULL;
  for ( int i = 0;i<=curr->children();i++)
  {
    if(curr->child(i)!=NULL)
    {
    trace("found a text editor!");
      T = (Fl_Syntax_Text_Editor *) curr->child(i);
      std::string tmp = T->filename;
      tmp = "Documents/"+ tmp;
      trace("menu string ="+tmp);
      int val = menu->find_index(tmp.c_str());
      if(val != -1)
      {
        trace("removing document:"+tmp);
        menu->remove(val);
      }
      menu->redraw();
    }
  }
  
  tabs->remove(E);
  if(tabs->children()<=0)
  {
    tabs->clear();
    win->redraw();
  }
  else
    tabs->value(tabs->child(0));
  
  tabs->redraw();
}

void UI::colorize_syntax_buttons() {
  cm->color(COMMENT_TEXT);
  cm->redraw();
  str->color(STRING_TEXT);
  str->redraw();
  directives->color(DIRECTIVE_TEXT);
  directives->redraw();
  typezz->color(TYPE_TEXT);
  typezz->redraw();
  keywordz->color(KEYWORD_TEXT);
  keywordz->redraw();
  numbers->color(NUMBER_TEXT);
  numbers->redraw();
  pref_win->show();
  pref_tabs->value(syntax);
  tExt->color(FOREGROUND_TEXT);
  bg->color(BACKGROUND_TEXT);
  tExt->redraw();
  bg->redraw();
}

unsigned int UI::convert(std::string num) {
  unsigned int NUM=0;
  try{NUM=std::stoul(num);}
  catch(const std::invalid_argument e){return 0;}
  catch(const std::out_of_range e){return 0;}
  return NUM;
}

void UI::copy_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Editor::kf_copy(0, textor);
}

Fl_Syntax_Text_Editor * UI::current_editor() {
  if(tabs==NULL)
    return NULL;
  //std::cerr<<"TABS="<<tabs<<std::endl;
  if(tabs->value()==NULL)
    return NULL;
  //std::cerr<<"tabs->value() [Group holding Text Editor]="<<tabs->value()<<std::endl;
  if(tabs->children()<=0)
    return NULL;
  Fl_Group * curr = tabs->value()->as_group();
  if(curr==NULL)
    return NULL;
  //std::cout<<curr->children()<<std::endl;
  Fl_Syntax_Text_Editor * E=NULL;
  for ( int i = 0;i<=curr->children();i++)
  {
    if(curr->child(i)!=NULL)
    {
      E = (Fl_Syntax_Text_Editor *) curr->child(i);
     // std::cerr<<"Current Text editor="<<E<<std::endl;
      return E;
    }
  }
  return E;
}

void UI::cut_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Editor::kf_cut(0,textor);
}

void UI::dark_theme() {
  FOREGROUND_TEXT=4294967040;
  BACKGROUND_TEXT=56;
  SELECTION_TEXT=80;
  FONT_TEXT=FL_COURIER;
  SIZE_TEXT=14;
  LINE_NUMBERS=0;
  HIGHLIGHT_PLAIN=0;
  //syntax
  COMMENT_TEXT=3368601600;
  STRING_TEXT=4291493888;
  DIRECTIVE_TEXT=4286380544;
  NUMBER_TEXT=4280754176;
  KEYWORD_TEXT=1787232000;
  TYPE_TEXT=385820928;
  BUTTON_COLOR=1;
}

void UI::default_theme() {
  FOREGROUND_TEXT=FL_FOREGROUND_COLOR;
  BACKGROUND_TEXT=FL_BACKGROUND2_COLOR;
  SELECTION_TEXT=80;
  FONT_TEXT=FL_COURIER;
  SIZE_TEXT=14;
  HIGHLIGHT_PLAIN=0;
  LINE_NUMBERS=0;
  //syntax
  COMMENT_TEXT=1077952512;
  STRING_TEXT=2625372160;
  DIRECTIVE_TEXT=2050717696;
  NUMBER_TEXT=4280754176;
  KEYWORD_TEXT=1045337344;
  TYPE_TEXT=175444736;
  BUTTON_COLOR=1;
}

void UI::delete_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  textor->buffer()->remove_selection();
}

void UI::dnd_file(const char* items, bool NEW) {
  if(items==NULL)
    return;
  std::string s = items;
  unsigned int URI = s.find("file:///");
  if(URI==0)
  {
    s = s.substr(7,std::string::npos);
  }
  URI = s.find("\n");
  if(URI<s.length())
  {
    s=s.substr(0,URI);
  }
  char *ch = strdup(s.c_str());
  fl_decode_uri(ch);
  s=ch;
  
  load_file(s,-1,NEW);
  free(ch);
}

void UI::find_cb() {
  std::string val;
  Fl_Syntax_Text_Editor * E = current_editor();
  std::string SRCH = "";
  if(E==NULL)
    return;
  SRCH = E->search;
  char * tmp = E->textbuffer->selection_text();
  if(tmp!=NULL)
  {
    std::string t = tmp;
    if(t.compare("")!=0)
    {
      SRCH=tmp;
      E->search=SRCH;
    }
  }
  val = input("Search String:",SRCH.c_str());
  if (val.compare("")!=0)
  {
    // User entered a string - go find it!
    E->search=val;
    find2_cb();
  }
}

void UI::find2_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
    return;
  std::string SRCH = "";
  SRCH = E->search;
  if (SRCH.compare("")==0)
  {
    // Search string is blank; get a new one...
    find_cb();
    return;
  }
  int pos = E->insert_position();
  Fl_Text_Buffer * buff = E->buffer();
  int found = buff->search_forward(pos, SRCH.c_str(), &pos);
  if (found)
  {
    // Found a match; select and update the position...
    buff->select(pos, pos+SRCH.length());
    E->search = buff->selection_text();
    E->insert_position(pos+SRCH.length());
    E->show_insert_position();
  }
  else
  {
    if(buff->selected())
    {
      if(fl_choice("Do you want to search from the beginning?",fl_no,fl_yes,NULL))
      {
         E->insert_position(0);
         find2_cb();
      }
    }
    else
    {
      fl_alert("No occurrences of \'%s\' found!", SRCH.c_str());
    }
  }
}

void UI::font_populate(Fl_Browser *o) {
  Fl_Font a;a = Fl::set_fonts("-*");
  std::string v;
  Fl_Font i;
  for (i=1;i!=a;++i){
    v = Fl::get_font_name(i,0);
    o->add(v.c_str());
  }
}

std::string UI::get_filename() {
  const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
  std::string fname="";
  if(xdg_config_home==NULL)
  {
    const char* home = getenv("HOME");
    if(home==NULL)
      return "";
    fname=home;
    fname+="/.config";
  }
  else
    fname = xdg_config_home;
  fname+="/flpad/flpad.config";
  return fname;
}

void UI::get_preferences() {
  std::string fname=get_filename();
  if(fname.compare("")==0)
  {
    trace("Filename was empty...");
    return;
  }
  default_theme();
  
  std::string subString,line;
  std::ifstream inputFileStrem (fname.c_str(), std::ifstream::in);
  /** check if the input file stream is open */
  unsigned int start = 3;
  if(inputFileStrem.is_open())
  {
    while (getline(inputFileStrem,line))
    {
      if(line.find("FG:")==0)
      {
        subString=line.substr(start,std::string::npos);
        FOREGROUND_TEXT=convert(subString);
      }
      if(line.find("BG:")==0)
      {
        subString=line.substr(start,std::string::npos);
        BACKGROUND_TEXT=convert(subString);
      }
      if(line.find("SC:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        SELECTION_TEXT=convert(subString);
      }
      if(line.find("FT:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        FONT_TEXT=convert(subString);
      }
      if(line.find("SZ:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        SIZE_TEXT=convert(subString);
      }
      if(line.find("LN:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        LINE_NUMBERS=convert(subString);
      }
      if(line.find("CM:")==0)
      {
        subString=line.substr(start,std::string::npos);
        COMMENT_TEXT=convert(subString);
      }
      if(line.find("ST:")==0)
      {
        subString=line.substr(start,std::string::npos);
        STRING_TEXT=convert(subString);
      }
      if(line.find("DE:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        DIRECTIVE_TEXT=convert(subString);
      }
      if(line.find("NM:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        NUMBER_TEXT=convert(subString);
      }
      if(line.find("KY:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        KEYWORD_TEXT=convert(subString);
      }
      if(line.find("TT:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        TYPE_TEXT=convert(subString);
      }
      if(line.find("BC:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        BUTTON_COLOR=convert(subString);
      }
      if(line.find("PT:")<line.length())
      {
        subString=line.substr(start,std::string::npos);
        HIGHLIGHT_PLAIN=convert(subString);
      }
    }
  }
  else
  {
    trace(fname+" does not exist yet");
  }
}

void UI::goto_cb() {
  const char * val;
  val = fl_input("Go to line #:","");
  if(val)
  {
    goto_line(convert(val));
  }
}

void UI::goto_line(int pos) {
  Fl_Text_Editor * E = current_editor();
  E->insert_position(E->line_start(pos));
}

int UI::handle(int event, Fl_Window *o) {
  UI* ui = ((UI*)(o->user_data()));
  bool RELEASE=ui->RELEASE;
  switch(event)
  {
    case FL_DND_DRAG:
    case FL_DND_LEAVE:
    break;
    case FL_DND_RELEASE:
      RELEASE=true;
      trace("FL_DND_RELEASE");
      //return 1;
      break;
    case FL_RELEASE:
      if(RELEASE)
      {
        RELEASE=false;
        //trace("Pasting complete!");
        std::cout<<Fl::event_text()<<std::endl;
        //ui->dnd_file(Fl::event_text());
        return 1;
      }
  }
  //trace("e=",event);
  return Fl::handle_(event,o);
}

void UI::handle_menu(Fl_Widget *w, void *v) {
  if(!w || !v)
    return;
  Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)w->user_data());
  UI* ui = ((UI*)T->user_data());
  switch(static_cast<int>(reinterpret_cast<long>(v)))
  {
    case 1: //COPY
      ui->copy_cb();
      break;
    case 2:  //CUT
      ui->cut_cb();
      break;
    case 3:  //FIND
      ui->find_cb();
      break;
    case 4: //PASTE
      ui->paste_cb();
      break;
    case 5: //UNDO
      ui->undo_cb();
      break;
  }
}

std::string UI::input(std::string MSG, std::string text, std::string ok, std::string cancel) {
  Fl_Double_Window* w = new Fl_Double_Window(285, 75);
  Fl_Input* o1 = new Fl_Input(125, 5, 150, 30);
  o1->box(FL_FLAT_BOX);
  o1->selection_color((Fl_Color)80);
  o1->copy_label(MSG.c_str());
  o1->value(text.c_str());
  Fl_Button* o2 = new Fl_Button(200, 40, 75, 30);
  o2->box(FL_FLAT_BOX);
  o2->color((Fl_Color)62);
  o2->labelcolor(FL_BACKGROUND2_COLOR);
  o2->callback(ask_cb,1);
  o2->copy_label(ok.c_str());
  Fl_Button* o = new Fl_Button(115, 40, 75, 30);
  o->box(FL_FLAT_BOX);
  o->color((Fl_Color)80);
  o->labelcolor(FL_BACKGROUND2_COLOR);
  o->copy_label(cancel.c_str());
  o->callback(ask_cb,0);
  w->end();
  w->show();
  while (w->shown()) Fl::wait();
  const char* v = o1->value();
  if(v == NULL)
    return "";
  std::string V=v;
  if(ret_val)
    return V;
  return "";
}

void UI::insert_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Editor::kf_insert(0,textor);
}

void UI::load_file(std::string newfile, int ipos,bool NEW) {
  //trace("Loading file:"+newfile);
  //todo 
  //if(pick_tab(newfile)){return;}
  if(NEW)
  {
    add_tab(false);
    trace("added tab");
  }
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
  {
    std::cerr<<"Null editor"<<std::endl;
    return;
  }
  E->set_type(newfile);
  E->loading = 1;
  int insert = (ipos != -1);
  E->changed = insert;
  //E->textbuffer->call_modify_callbacks();
  if (!insert)
    E->filename="";
  int r = 0;
  if (!insert)
  {
    r = E->textbuffer->loadfile(newfile.c_str());
  }
  else
  {
    r = E->textbuffer->insertfile(newfile.c_str(), ipos);
  }
  E->refresh();
  E->textbuffer->call_modify_callbacks();
  
  if (r)
    fl_alert("Error reading from file \'%s\':\n%s.", newfile.c_str(), strerror(errno));
  else if (!insert)
    E->filename=newfile;
  E->loading = 0;
  set_title(tabs->value());
  std::string tmp = "Documents/"+E->filename;
  menu->add(tmp.c_str(),0,choose_doc,this,0);
  menu->redraw();
}

void UI::make_icon(Fl_Window *o) {
  Fl_Pixmap f(flpad_xpm);
  const Fl_Pixmap * flpad_xpm_icon = &f;
  const Fl_RGB_Image *img = new Fl_RGB_Image(flpad_xpm_icon,FL_GRAY);
  o->icon(img);
}

void UI::none_theme() {
  FOREGROUND_TEXT=FL_FOREGROUND_COLOR;
  BACKGROUND_TEXT=FL_BACKGROUND2_COLOR;
  SELECTION_TEXT=80;
  FONT_TEXT=FL_COURIER;
  SIZE_TEXT=14;
  LINE_NUMBERS=0;
  HIGHLIGHT_PLAIN=0;
  //syntax
  COMMENT_TEXT=FL_FOREGROUND_COLOR;
  STRING_TEXT=FL_FOREGROUND_COLOR;
  DIRECTIVE_TEXT=FL_FOREGROUND_COLOR;
  NUMBER_TEXT=FL_FOREGROUND_COLOR;
  KEYWORD_TEXT=FL_FOREGROUND_COLOR;
  TYPE_TEXT=FL_FOREGROUND_COLOR;
  BUTTON_COLOR=1;
}

void UI::new_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if( (!check_save()) && (textor!=NULL) )
    return;
  if (textor==NULL)
  {
    add_tab();
    return;
  }
  if(textor->filename.compare("Untitled")!=0)
  {
    add_tab(true,false);
    return;
  }
  textor->filename="";
  Fl_Text_Buffer * buff = textor->buffer();
  buff->select(0, buff->length());
  buff->remove_selection();
  textor->changed = 0;
  buff->call_modify_callbacks();
  if (!check_save())
    return;
  textor->filename="";
  buff->select(0, buff->length());
  buff->remove_selection();
  textor->changed = 0;
  buff->call_modify_callbacks();
}

void UI::open_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
  {
    trace("No current editor");
    open_file();
    return;
  }
  std::string f = E->filename;
  
  if(f.compare("")==0)
    open_file(false);
  else
    open_file();
}

void UI::open_file(bool NEW) {
  Fl_Syntax_Text_Editor * E = current_editor();
  //std::string newf="";
  std::string init="";
  if(E!=NULL)
  {
    init= E->filename;
  }
  char *newfile = fl_file_chooser("Open File?", "*",init.c_str());
  if(newfile!=NULL)
  {
    load_file(newfile, -1,NEW);
  }
}

void UI::paste_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Editor::kf_paste(0,textor);
}

bool UI::pick_tab(std::string file) {
  if(file.compare("")==0)
    return false;
  if(tabs==NULL)
    return false;  
  Fl_Group * curr = tabs->as_group();
  if(curr==NULL)
    return false;
  Fl_Syntax_Text_Editor * E=NULL;
  for ( int i = 0;i<=curr->children();i++)
  {
    if(curr->child(i)!=NULL)
    {
      E = (Fl_Syntax_Text_Editor *) curr->child(i)->as_group()->child(0);
      if(E->filename.compare(file)==0)
      {
        tabs->value(curr->child(i));
        win->redraw();
        return true;
      }
      const char* lbl = E->tooltip();
      if(lbl!=NULL)
      {
        if(file.compare(lbl)==0)
        {
          tabs->value(curr->child(i));
          return true;
        }
      }
    }
  }
  return false;
}

std::string UI::prefline(std::string LINE,unsigned int COLOR) {
  std::string out=LINE+":";
  std::string number;
  std::stringstream OUT;
  OUT << COLOR;
  number = OUT.str();
  out+=number;
  out+="\n";
  return out;
}

void UI::print_cb() {
  Fl_Printer *printer = new Fl_Printer();
  if (printer->start_job(1) == 0)
  {
    printer->start_page();
    //TODO
    printer->end_page();
    printer->end_job();
  }
  delete printer;
}

void UI::quit_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E!=NULL)
  {
    if (E->changed && !check_save())
      return;
  }
  exit(0);
}

void UI::replace_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E!=NULL)
    make_replace()->show();
}

void UI::replace2_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
    return;
  const char *find = replace_find->value();
  
  const char *replace = replace_with->value();
  if (find == NULL)
  {
  trace("NULL");
  // Search string is blank; get a new one...
    replace_dlg->show();
    return;
  }
  replace_dlg->hide();
  int pos = E->insert_position();
  Fl_Text_Buffer * buff = E->buffer();
  int found = buff->search_forward(pos, find, &pos);
  if (found)
  {
  // Found a match; update the position and replace text...
    buff->select(pos, pos+strlen(find));
    buff->remove_selection();
    buff->insert(pos, replace);
    buff->select(pos, pos+strlen(replace));
    E->insert_position(pos+strlen(replace));
    E->show_insert_position();
  }
  else
    fl_alert("No occurrences of \'%s\' found!", find);
}

void UI::replall_cb() {
  Fl_Syntax_Text_Editor * E = current_editor();
  if(E==NULL)
    return;
  const char *find = replace_find->value();
  const char *replace = replace_with->value();
  find = replace_find->value();
  if (find == NULL)
  {
  trace("NULL");
  // Search string is blank; get a new one...
    replace_dlg->show();
    return;
  }
  
  replace_dlg->hide();
  E->insert_position(0);
  int times = 0;
  Fl_Text_Buffer * buff = E->buffer();
  // Loop through the whole string
  for (int found = 1; found;)
  {
    int pos = E->insert_position();
    found = buff->search_forward(pos, find, &pos);
    if (found)
    {
    // Found a match; update the position and replace text...
      buff->select(pos, pos+strlen(find));
      buff->remove_selection();
      buff->insert(pos, replace);
      E->insert_position(pos+strlen(replace));
      E->show_insert_position();
      times++; 
    }
  }
  if (times)
    fl_message("Replaced %d occurrences.", times);
  else
    fl_alert("No occurrences of \'%s\' found!", find);
}

void UI::replace_start() {
  Fl_Syntax_Text_Editor * E = current_editor();
  std::string SRCH = "";
  if(E!=NULL)
   SRCH = E->search;
  char * tmp = E->textbuffer->selection_text();
  if(tmp!=NULL)
  {
    std::string t = tmp;
    if(t.compare("")!=0)
    {
      SRCH=tmp;
      E->search=SRCH;
    }
  }
  
  replace_find->value(SRCH.c_str());
}

void UI::resize(Fl_Widget* o) {
  if(o==NULL)
    return;
  int width = win->w();
  int height = win->h() - (buttons->h() +buttons->x());
  o->size(width,height);
  o->redraw();
}

void UI::refresh_all() {
  change_theme(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);
}

void UI::save_cb(void) {
  Fl_Syntax_Text_Editor * E = current_editor();
  std::string fname="";
  if(E==NULL)
  {
    return;
  }
  fname=E->filename;
  if (fname.compare("")==0)
  {
  // No filename - get one!
    saveas_cb();
    return;
  }
  else
    save_file(fname);
}

void UI::saveas_cb(void) {
  char *newfile;
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  newfile = fl_file_chooser("Save File As?", "*", textor->filename.c_str());
  if (newfile != NULL)
    save_file(newfile);
}

bool UI::save_preferences() {
  std::string out=prefline("FG",FOREGROUND_TEXT);
  out+=prefline("BG",BACKGROUND_TEXT);
  out+=prefline("SC",SELECTION_TEXT);
  out+=prefline("FT",FONT_TEXT);
  out+=prefline("SZ",SIZE_TEXT);
  out+=prefline("LN",LINE_NUMBERS);
  out+=prefline("CM",COMMENT_TEXT);
  out+=prefline("ST",STRING_TEXT);
  out+=prefline("DE",DIRECTIVE_TEXT);
  out+=prefline("NM",NUMBER_TEXT);
  out+=prefline("KY",KEYWORD_TEXT);
  out+=prefline("TT",TYPE_TEXT);
  out+=prefline("BC",BUTTON_COLOR);
  out+=prefline("PT",HIGHLIGHT_PLAIN);
  std::ofstream dest;
  std::string fname=get_filename();
  dest.open(fname.c_str());
  if(!dest.is_open()){
    fl_alert("Error writing to file \'%s\':\n%s.", fname.c_str(), strerror(errno));
    return false;
  }
  dest << out;
  dest.close();
  return true;
}

void UI::save_file(std::string newfile) {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Buffer * buff = textor->buffer();
  if (buff->savefile(newfile.c_str()))
    fl_alert("Error writing to file \'%s\':\n%s.", newfile.c_str(), strerror(errno));
  else
  {
    textor->filename=newfile;
    textor->changed = 0;
    buff->call_modify_callbacks();
    set_title(textor->parent());
    ((Fl_Widget *)(textor->user_data()))->labelcolor(NORMAL_COLOR);
  }
}

void UI::set_title(Fl_Widget* g) {
  if(g==NULL)
    return;
  std::string title;
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  std::string fname = textor->filename;
  std::string full = fname;
  
  //Is the file name empty???  set it to Untitled!!
  if (fname.compare("")==0)
  {
    title="Untitled";
  }
  else
  {
  // get JUST the filename (remove the path... similare to fl_filename_name()
    unsigned int slash = fname.rfind('/');
    #ifdef WIN32
    if (slash>fname.length())
      slash =fname.rfind('\\');
    #endif
    if (slash <fname.length())
    {
      //FILENAME ONLY
      title=fname.substr(slash+1,std::string::npos);
      //PATH to file ONLY
      full = fname.substr(0,slash);
    }
    else
      title=fname;
      
  }
  textor->refresh();
  //Has this been changed at all??
  if (textor->changed)
  {
    title+=" (modified)";
  }
  std::string Ti = title;
  
  if(full.compare("")!=0)
  {
    // is there a path???  add it!!
    Ti = Ti + "(" + full + ")";
  }
  win->copy_label(Ti.c_str());
  g->copy_label(title.c_str());
  g->copy_tooltip(fname.c_str());
  g->redraw();
  tabs->redraw();
}

void UI::show_line_numbers(int width) {
  for(int i = 0;i< tabs->children();i++)
  {
  std::cout<<i<<std::endl;
    Fl_Group* tab = tabs->child(i)->as_group();
    Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
    e->linenumber_width(width);
  }
}

void UI::undo_cb() {
  Fl_Syntax_Text_Editor * textor = current_editor();
  if(textor==NULL)
    return;
  Fl_Text_Editor::kf_undo(0,textor);
}

void UI::wordwrap() {
  Fl_Syntax_Text_Editor * E = current_editor();
  std::string fname="";
  if(E==NULL)
  {
    return;
  }
  if(E->WRAPPED)
  {
    E->WRAPPED=false;
    E->wrap_mode(Fl_Text_Display::WRAP_NONE, 0);
  }
  else
  {
    E->WRAPPED=true;
    E->wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
  }
}

int main(int argc, char **argv) {
  NORMAL_COLOR=FL_BLACK;
  EDIT_COLOR=FL_RED;
  UI *ui = new UI();
  try
  {
    ui->get_preferences();
    Fl::set_fonts();
    ui->make_window()->show();
    ui->win->wait_for_expose();
    if (argc > 1)
    {
      for (int i=1; i<argc; i++)
      {
        char* charchar1 = argv[i];
        if(charchar1 != NULL)
        {
          std::string fname = charchar1;
          ui->dnd_file(fname.c_str(),false);
        }
      }
    }
    return Fl::run();
  }
  catch (const std::exception& e)
  {
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...)
  {
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
}

std::vector<std::string> make_vec(std::string string_to_become_vector,std::string delimiter) {
  std::vector<std::string> Vector;
  std::string original,preComma,postComma;
  original=string_to_become_vector;
  unsigned int found,finder;
  finder=original.length();
  if(original.find(delimiter)>original.length())
  {
    Vector.push_back(original);
    return Vector;
  }
  for(found=original.find(delimiter);found<finder;found=original.find(delimiter))
  {
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0)
    {
      preComma.erase( std::remove_if( preComma.begin(), preComma.end(), is_space)
                      ,preComma.end());
      //trace(preComma);
      Vector.push_back(preComma);
    }
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

void trace(std::string MSG, int n ) {
  //return;
  std::cout<<MSG;
  if(n!=0)
    std::cout<<"-->"<<n;
  std::cout<<std::endl;
}

std::string get(std::string header, std::string line) {
  if(line.compare("")==0){return "";}
  if(header.compare("")==0){return "";}
  std::string filename = get_syntax_file();
  if(filename.compare("")==0){return "";}
  if(!test_file(filename))
  {
    trace("No file sent in\n"+filename+","+line);
    return "";
  }
  std::string find_header=header;
  unsigned int open=header.find("[");
  unsigned int close=header.find("]");
  unsigned int header_length=header.length();
  if(open>header_length){find_header="["+find_header;}
  if(close>header_length){find_header=find_header+"]";}
  
  bool found_after_this=false;
  std::string this_line;
  int lengthofARGS = line.length();
  std::string subString;
  std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
  /** check if the input file stream is open */
  if(inputFileStrem.is_open())
  {
    while (getline(inputFileStrem,this_line))
    {
      subString=this_line.substr(0,lengthofARGS);
      if(this_line.find("[")<=1)
      {
        found_after_this=false;
      }
      if(this_line.find(find_header)<this_line.length())
      {
        //trace("FOUND:"+find_header);
        found_after_this=true;
      }
      /** if found return it immediately */
      if(found_after_this)
      {
        if(this_line.find(line)<this_line.length())
        {
          unsigned int eq = this_line.find("=");
          if(eq<this_line.length())
          {
            this_line=this_line.substr(eq+1,std::string::npos);
          }
          return this_line;
        }
      }
    }
  }
  return "";
}

bool test_file(std::string file) {
  //if empty it doesn't exist
  if(file.compare("")==0)
    return false;
  
  
  std::string dir=file;
  unsigned int find = dir.rfind("/");
  
  //if there is no directory this isn't correct
  if(find>dir.length())
  {
    // try the PWD if we can
    const char* PWD= getenv("PWD");
    if(PWD==NULL)
      return false;
    dir=PWD;
    dir+="/";
    file=dir+file;
  }
  else
  {
    // get the directory
    dir=dir.substr(0,find);
  }
  
  //open the directory
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  
  //make sure there is a slash at the end
  if(dir.rfind('/')!=dir.length()-1){dir+="/";}
  
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        //get a pointer to the file in this directory
        std::string fullpath=entryPointer->d_name;
        fullpath=dir+fullpath;
        //is it the same as what we sent in?
        if(fullpath.compare(file)==0)
        {
          //close the directory
          closedir(mydir);
          return true;
        }
      }
    }
    //close the directory... apparently this didn't work :(
    closedir(mydir);
  }
  return false;
}

std::string get_syntax_file() {
  std::string base_name = "flpad/styles.flpad";
  if(SYNTAX_FILE.compare("")!=0)
    return SYNTAX_FILE;
  //testing
  std::string home_tester;
  const char* home_config = getenv("XDG_CONFIG_HOME");
  if(home_config == NULL)
  {
    home_config = getenv("HOME");
    if(home_config != NULL)
    {
      home_tester=home_config;
      home_tester =home_tester + "/.config/" + base_name;
    }
  }
  else
  {
    home_tester = home_config;
    home_tester = home_tester + "/" + base_name;
  }
  trace(home_tester);
  if(test_file(home_tester))
  {
    SYNTAX_FILE=home_tester;
  }
  else
  {
    std::string tester = "/usr/share/";
    if(test_file(tester+base_name))
    {
      SYNTAX_FILE=tester+base_name;
    }
    else
    {
      tester = "/usr/local/share/";
      if(test_file(tester+base_name))
        SYNTAX_FILE=tester+base_name;
    }
  }
  if(SYNTAX_FILE.compare("")==0)
    trace("No syntax file found...");
  return SYNTAX_FILE;
}

std::vector<std::string> comma_line(std::string lang,std::string field) {
  //get the line from the file
  std::string LINE=get(lang,field);
  //return a vector from the string delimited by commas
  return make_vec(LINE,",");
}

std::vector <std::string> keywords(std::string header) {
  return comma_line(header, "keywords");
}

std::vector <std::string> types(std::string header) {
  return comma_line(header, "types");
}

bool is_space(const char x) {
  return std::isspace(x);
}

std::string get_type(std::string fname) {
  if(!test_file(fname))
  {
    trace("No file sent in\n"+fname);
    return "";
  }
  
  const char* ext = fl_filename_ext(fname.c_str());
  
  /// get the shebang
  std::string thisLine;
  std::ifstream inputFileStream(fname.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    getline(inputFileStream,thisLine);
  }
  
  // shell scripts don't always constain an extention... but the shebang tells
  if(thisLine.find("#!")==0)
  {
    std::string tmp=thisLine;
    unsigned int find = tmp.rfind("/");
    if(find<tmp.length())
    {
      tmp=tmp.substr(find+1,std::string::npos);
      tmp="."+tmp;
      ext=tmp.c_str();
    }
  }
  
  //nothing?  lets leave then...
  if(ext == NULL)
    return "";
  
  std::string EXT=ext;
  unsigned int f_dot = EXT.find(".");
  if(f_dot<EXT.length())
    EXT=EXT.substr(f_dot+1,std::string::npos);
  //trace("extention="+EXT);
  //get the syntax highlighter file
  std::string filename = get_syntax_file();
  if(filename.compare("")==0){return "";}
  
  //this is the line we are looking for
  std::string line="ext=";
  
  //parse the syntax highlighter file
  std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
  /** check if the input file stream is open */
  if(inputFileStrem.is_open())
  {
    std::string this_line;
    std::string HEADER="";
    while (getline(inputFileStrem,this_line))
    {
      
      if(this_line.find("[")<=1)
      {
         unsigned int open_bracket=this_line.find("[");
         unsigned int close_bracket=this_line.find("]");
         HEADER=this_line.substr(open_bracket+1,close_bracket-1);
         //trace("["+HEADER+"]");
      }
      unsigned int eq = this_line.find("=");
      if(this_line.find(line)<this_line.length())
      {
        this_line=this_line.substr(eq+1,std::string::npos);
        trace(this_line+"::"+EXT);
        std::vector<std::string> V = make_vec(this_line,",");
        for( std::vector<std::string>::iterator itr = V.begin();
                                                itr!=V.end();
                                                ++itr)
        {
          std::string tmp=*itr;
          //trace(tmp+"=="+EXT);
          if(tmp.compare(EXT)==0)
            return HEADER;
        }
      }
    }
  }
  
  if(EXT.compare("bash")==0)
    return "sh";
  return "";
}
