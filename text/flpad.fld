# data file for the Fltk User Interface Designer (fluid)
version 1.0304
i18n_type 1
i18n_include <libintl.h>
i18n_function gettext
header_name {.h}
code_name {.cxx}
comment {copyright 2018 Israel Dahl
GPL 3
created from the FLTK tutorial using FLUID to design the UI
created as part of the ToriOS project} {in_source in_header
}

decl {\#include <netinet/in.h>} {public global
}

decl {\#include "lexertk.hpp"} {public global
}

decl {\#include "../include/toolbar_icons.h"} {public global
}

decl {\#include <algorithm>} {public global
}

decl {\#include <sstream>} {public global
}

decl {\#include <dirent.h>} {public global
}

decl {\#include <fstream>} {public global
}

decl {\#include <iostream>} {public global
}

decl {\#include <streambuf>} {public global
}

decl {\#include <FL/Fl_Color_Chooser.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <FL/Fl_Text_Editor.H>} {public global
}

decl {\#include <FL/Fl_Printer.H>} {public global
}

decl {\#include <FL/fl_ask.H>} {public global
}

decl {\#include <FL/Fl_RGB_Image.H>} {public global
}

decl {\#include <errno.h>} {public global
}

decl {\#include <vector>} {public global
}

decl {\#include <ctype.h>} {public global
}

decl {\#include <string.h>} {public global
}

decl {\#include <stdlib.h>} {public global
}

decl {\#include <stdio.h>} {public global
}

decl {\#include <cstdio>} {public global
}

decl {\#include <cstdlib>} {public global
}

decl {\#include <string>} {public global
}

decl {\#include <unistd.h>} {public global
}

decl {int ret_val;} {public global
}

decl {std::string return_value;} {public global
}

decl {unsigned int EDIT_COLOR;
unsigned int NORMAL_COLOR;} {public global
}

decl {unsigned int FOREGROUND_TEXT;
unsigned int BACKGROUND_TEXT;
unsigned int SELECTION_TEXT;
unsigned int COMMENT_TEXT;
unsigned int STRING_TEXT;
unsigned int DIRECTIVE_TEXT;
unsigned int NUMBER_TEXT;
unsigned int KEYWORD_TEXT;
unsigned int TYPE_TEXT;
int FONT_TEXT;
int SIZE_TEXT;
int LINE_NUMBERS;
int BUTTON_COLOR;
int HIGHLIGHT_PLAIN;} {public global
}

decl {std::string SYNTAX_FILE;} {public global
}

class SingletonProcess {} {
  Function {SingletonProcess(uint16_t port0): socket_fd(-1),rc(1),port(port0)} {open
  } {
    code {} {}
  }
  Function {~SingletonProcess()} {open
  } {
    code {if (socket_fd != -1)
{
  close(socket_fd);
}} {}
  }
  Function {operator()()} {return_type bool
  } {
    code {if (socket_fd == -1 || rc)
{
  socket_fd = -1;
  rc        =  1;
  if ((socket_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
  {
    throw std::runtime_error(std::string("Could not create socket: ") +  strerror(errno));
  }
  else
  {
    struct sockaddr_in name;
    name.sin_family = AF_INET;
    name.sin_port = htons (port);
    name.sin_addr.s_addr = htonl (INADDR_ANY);
    rc = bind (socket_fd, (struct sockaddr *) &name, sizeof (name));
  }
}
return (socket_fd != -1 && rc == 0);} {}
  }
  Function {GetLockFileName()} {return_type {std::string}
  } {
    code {return "port " + std::to_string(port);} {}
  }
  decl {int socket_fd = -1;
int rc;
uint16_t port;} {private local
  }
}

class Fl_Syntax_Text_Editor {open : {public Fl_Text_Editor}
} {
  Function {Fl_Syntax_Text_Editor(int x, int y, int w, int h, const char* label = 0):Fl_Text_Editor(x,y,w,h,label)} {open
  } {
    code {this->resize(x,y,w,h);
//this->label(label);
changed=0;
loading=0;
filename="";
RELEASE=false;
//std::cerr<<"Constructor: new Text Editor="<<this<<std::endl;
textbuffer = new Fl_Text_Buffer();
this->buffer(textbuffer);
char *style = new char[textbuffer->length() + 1];
char *text = textbuffer->text();
memset(style, 'A', textbuffer->length());
stylebuffer = new Fl_Text_Buffer(textbuffer->length());
style[textbuffer->length()] = '\\0';
init_highlight();
//style_parse(text, style, textbuffer->length(),12);
stylebuffer->text(style);
//std::cerr<<"stylebuffer="<<stylebuffer<<std::endl;
delete[] style;
free(text);
WRAPPED=false;
box(FL_FLAT_BOX);
//trace("editor colors");
theme_editor(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);
//trace("add modify callback");
textbuffer->add_modify_callback(changed_cb,(void *)this);
//textbuffer->call_modify_callbacks();} {}
  }
  Function {~Fl_Syntax_Text_Editor()} {} {
    code {buffer(0);
textbuffer->remove_modify_callback(style_update, this);
textbuffer->remove_modify_callback(changed_cb, this);} {}
  }
  decl {bool WRAPPED;} {public global
  }
  decl {bool RELEASE;} {public local
  }
  decl {Fl_Text_Display::Style_Table_Entry styletable[8];} {public global
  }
  decl {Fl_Text_Buffer * stylebuffer;} {public global
  }
  decl {Fl_Text_Buffer * textbuffer;} {public global
  }
  decl {std::string filename;} {public local
  }
  decl {std::string search;} {public local
  }
  decl {int changed;} {public global
  }
  decl {int loading;} {public global
  }
  decl {std::vector<std::string> KEYWORDS, TYPES;} {public global
  }
  decl {std::string STYLE_HEADER;} {public local
  }
  decl {lexertk::generator generator} {public local
  }
  decl {lexertk::helper::bracket_checker bracket_checker;} {public local
  }
  decl {lexertk::helper::symbol_replacer symbol_replacer;} {public local
  }
  Function {changed_cb(int, int nInserted, int nDeleted, int, const char*, void *v)} {return_type {static void}
  } {
    code {Fl_Syntax_Text_Editor * o = (Fl_Syntax_Text_Editor *)v;
//std::cerr<<"Editor object="<< o<<std::endl;
std::string f = o->filename;
if ((nInserted || nDeleted) && !o->loading)
{
  o->changed = 1;
}
((UI *)(o->parent()->user_data()))->set_title(o->parent());} {}
  }
  Function {file_string()} {return_type {std::string}
  } {
    code {if(filename.compare("")==0){return "";}
std::ifstream t(filename);
std::string str;

t.seekg(0, std::ios::end);   
str.reserve(t.tellg());
t.seekg(0, std::ios::beg);

str.assign((std::istreambuf_iterator<char>(t)),
            std::istreambuf_iterator<char>());
return str;} {}
  }
  Function {get_styletable(Fl_Text_Display::Style_Table_Entry &styles,int which)} {} {
    code {int font = FONT_TEXT;
int bold = font + 1;
int ital = bold + 1;
std::string whichtype="Plain";
switch(which)
{
  case 0:
    styles={ FOREGROUND_TEXT, font, FL_NORMAL_SIZE }; // A - Plain
    whichtype="Plain";
    break;
  case 1:
    styles={ COMMENT_TEXT, ital, FL_NORMAL_SIZE }; // B - Line comments
    whichtype="Line comments";
    break;
  case 2:
    styles={ COMMENT_TEXT, ital, FL_NORMAL_SIZE }; // C - Block comments
    whichtype="Block comments";
    break;
  case 3:
    styles={ STRING_TEXT, font, FL_NORMAL_SIZE }; // D - Strings
    whichtype="Strings";
    break;
  case 4:
    styles={ DIRECTIVE_TEXT, font, FL_NORMAL_SIZE }; // E - Directives
    whichtype="Directives";
    break;
  case 5:
    styles={ TYPE_TEXT, bold, FL_NORMAL_SIZE }; // F - Types
    whichtype="Types";
    break;
  case 6:
    styles={ KEYWORD_TEXT, bold, FL_NORMAL_SIZE }; // G - Keywords
    whichtype="Keywords";
    break;
  case 7:
    styles={ NUMBER_TEXT, font, FL_NORMAL_SIZE }; // H - numbers
    whichtype="numbers";
    break;
}
styletable[which] = styles; //  set
//std::cout<<"Got style table for: "<<whichtype<<"\\nFONT="<<styles.font<<"\\tCOLOR="<<styles.color<<std::endl;} {}
  }
  Function {handle(int event)} {protected return_type int
  } {
    code {UI* ui = ((UI*)(parent()->parent()->parent()->user_data()));
switch(event)
{
  case FL_PUSH:
  case FL_RELEASE:
    //trace("push/release!");
    if(Fl::event_button() == FL_RIGHT_MOUSE)
    {
      if(Fl::event_clicks())
      {
        break;
      }
      ui->make_popup(this);
      //trace("Right");
      return 1;
    }
    break;
  case FL_DND_DRAG:
  case FL_DND_LEAVE:
  break;
  case FL_DND_RELEASE:
    RELEASE=true;
    break;
  case FL_PASTE:
    if(RELEASE)
    {
      RELEASE=false;
      ui->dnd_file(Fl::event_text());
      return 1;
    }
}
return Fl_Text_Editor::handle(event);} {}
  }
  Function {init_highlight()} {} {
    code {Fl_Text_Display::Style_Table_Entry A; //  Plain
get_styletable(A,0);

Fl_Text_Display::Style_Table_Entry B; // Line comments
get_styletable(B,1);

Fl_Text_Display::Style_Table_Entry C; // Block comments
get_styletable(C,2);

Fl_Text_Display::Style_Table_Entry D; // Strings
get_styletable(D,3);

Fl_Text_Display::Style_Table_Entry E; // Directives
get_styletable(E,4);

Fl_Text_Display::Style_Table_Entry F; // Types
get_styletable(F,5);

Fl_Text_Display::Style_Table_Entry G;  // Keywords
get_styletable(G,6);

Fl_Text_Display::Style_Table_Entry H; // Numbers
get_styletable(H,7);

highlight_data(stylebuffer, styletable, sizeof(styletable) / sizeof(styletable[0]), 'A', style_unfinished_cb, 0);
textbuffer->add_modify_callback(style_update, (void*) this);} {}
  }
  Function {modify_cb(int pos=0, int nInserted=0, int nDeleted=0, int unused=0, const char * nada=NULL)} {return_type void
  } {
    code {std::string thisLine;
if ( (HIGHLIGHT_PLAIN==0)&& (STYLE_HEADER.compare("")==0) )
{
  char *style = new char[textbuffer->length() + 1];
  memset(style, 'A', textbuffer->length());
  style[textbuffer->length()] = '\\0';
  stylebuffer->text(style);
}
else
{
  char* buf = textbuffer->text();
  std::string out(buf);
  std::string res = style_line(out);
  char* RES = const_cast <char*> (res.c_str());
  stylebuffer->text(RES);
}
redisplay_range(0,stylebuffer->length());} {}
  }
  Function {set_type(std::string fname)} {} {
    code {std::string dir=fname;
unsigned int find = dir.rfind("/");

//if there is no directory this isn't correct
if(find>dir.length())
{
  // try the PWD if we can
  const char* PWD= getenv("PWD");
  if(PWD!=NULL)
  {
    dir=PWD;
    dir+="/";
    fname=dir+fname;
    filename=fname;
  }
}

if(fname.empty())
  return;
STYLE_HEADER = get_type(fname);
KEYWORDS=keywords(STYLE_HEADER);
TYPES=types(STYLE_HEADER);
generator.set_keywords(KEYWORDS);
generator.set_types(TYPES);
trace("set syntax type for: "+fname+" to:"+STYLE_HEADER);} {}
  }
  Function {style_line(std::string thisLine)} {return_type {std::string}
  } {
    code {if(!generator.process(thisLine))
  trace("error processing text:"+thisLine);
else
{
  std::string line =lexertk::helper::style_line(generator);
  if(line.compare("")==0)
  {
    //trace("adding newline!");
    line="\\n";
  }
  return line;
}
return "A";} {}
  }
  Function {style_update(int pos=0, int nInserted=0, int nDeleted=0, int unused=0, const char * nada=NULL, void *cbArg = NULL)} {return_type {static void}
  } {
    code {Fl_Syntax_Text_Editor * ED = (Fl_Syntax_Text_Editor *)cbArg;
if(ED==NULL)
{
  trace("Couldn't get text editor :(");
  return;
}
ED->modify_cb(pos, nInserted, nDeleted, unused, nada);} {}
  }
  Function {style_unfinished_cb(int, void*)} {return_type {static void}
  } {
    code {} {}
  }
  Function {theme_editor(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size,int linenum )} {} {
    code {textcolor(FG);
cursor_color(FG);
color(BG);
textfont(font);
textsize(size);
selection_color(selection);
linenumber_width(linenum);
linenumber_size(size);
///renew highlighter
Fl_Text_Display::Style_Table_Entry A; //  Plain
get_styletable(A,0);

Fl_Text_Display::Style_Table_Entry B; // Line comments
get_styletable(B,1);

Fl_Text_Display::Style_Table_Entry C; // Block comments
get_styletable(C,2);

Fl_Text_Display::Style_Table_Entry D; // Strings
get_styletable(D,3);

Fl_Text_Display::Style_Table_Entry E; // Directives
get_styletable(E,4);

Fl_Text_Display::Style_Table_Entry F; // Types
get_styletable(F,5);

Fl_Text_Display::Style_Table_Entry G;  // Keywords
get_styletable(G,6);

Fl_Text_Display::Style_Table_Entry H; // Numbers
get_styletable(H,7);

//highlight_data(stylebuffer, styletable, sizeof(styletable) / sizeof(styletable[0]), 'A', style_unfinished_cb, 0);
modify_cb();} {}
  }
  Function {refresh()} {} {
    code {style_update(0,0,0,0,NULL,this);
redisplay_range(0,textbuffer->length());
redraw();} {}
  }
}

class UI {open
} {
  decl {bool RELEASE;} {public local
  }
  Function {UI()} {} {
    code {get_preferences();
RELEASE=false;} {}
  }
  Function {about_window()} {} {
    Fl_Window about_win {
      label About
      xywh {100 148 250 240} type Double hide xclass flpad
    } {
      Fl_Button {} {
        label Close
        callback {about_win->hide();}
        xywh {160 205 80 30} box FLAT_BOX color 80 labelcolor 7
      }
      Fl_Box {} {
        label {Designed in FLUID, based on the FLTK tutorial
Copyright 1998-2005 by Bill Spitzak and others.

This version was built for ToriOS
copyright 2018 Israel Dahl}
        xywh {0 0 250 200} box FLAT_BOX color 7 align 128
      }
    }
  }
  Function {make_popup(Fl_Widget *o)} {} {
    code {Fl_Menu_Item rclick_menu[] = {
  { "Copy",  0, handle_menu, (void*)1 },
  { "Cut",  0, handle_menu, (void*)2 },
  { "Find",  0, handle_menu, (void*)3 },
  { "Paste",  0, handle_menu, (void*)4 },
  { "Undo",  0, handle_menu, (void*)5 },
  { 0 }
};
Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)o->user_data());
UI* ui = ((UI*)T->user_data());

const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, ui->menu);
if ( m )
{

  m->do_callback(o, m->user_data());
}
return;} {}
  }
  Function {make_replace()} {} {
    Fl_Window replace_dlg {
      label {Find and Replace} open
      xywh {100 148 375 100} type Double hide xclass flpad
    } {
      Fl_Input replace_find {
        label Find
        xywh {70 5 295 25} box FLAT_BOX
        code0 {replace_start();}
      }
      Fl_Input replace_with {
        label Replace
        xywh {70 35 295 25} box FLAT_BOX
      }
      Fl_Button replace_cancel {
        label Cancel
        callback {replace_dlg->hide();}
        xywh {295 65 70 30} box FLAT_BOX color 80 labelcolor 7
      }
      Fl_Button replace_all {
        label {Replace All}
        callback {replall_cb();}
        xywh {185 65 95 30} box FLAT_BOX color 94
      }
      Fl_Button replace_next {
        label {Replace Next}
        callback {replace2_cb();}
        xywh {70 65 100 30} box FLAT_BOX color 61 labelcolor 7
      }
    }
  }
  Function {make_window()} {} {
    Fl_Window win {
      label {FLTK Pad} open
      xywh {348 120 520 545} type Double color 47 hide
      code0 {//Fl::event_dispatch(handle);}
      code1 {o->size_range(o->w(), o->h(), 0, 0);}
      code2 {make_icon(o);} xclass flpad
    } {
      Fl_Menu_Bar menu {
        xywh {0 0 520 25} box FLAT_BOX down_box FLAT_BOX color 39 selection_color 80 labelsize 16 labelcolor 7 align 260 textsize 16 textcolor 7
      } {
        Submenu {} {
          label {&File}
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&New}
            callback {new_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'n');}
          }
          MenuItem {} {
            label {&Open}
            callback {open_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'o');}
          }
          MenuItem {} {
            label {&Insert}
            callback {insert_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'i');}
          }
          MenuItem {} {
            label {&Save}
            callback {save_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'s');}
          }
          MenuItem {} {
            label {Save &As...}
            callback {saveas_cb();}
            xywh {10 10 100 20}
            code0 {o->shortcut(FL_COMMAND+FL_SHIFT+'s');}
          }
          MenuItem {} {
            label {&Exit}
            callback {quit_cb();}
            xywh {0 0 100 20}
          }
        }
        Submenu {} {
          label {&Edit} open
          xywh {0 0 100 25} labelsize 16
        } {
          MenuItem {} {
            label {&Undo}
            callback {undo_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'z');}
          }
          MenuItem {} {
            label {&Cut}
            callback {cut_cb();}
            xywh {0 0 100 20} labelsize 16
            code0 {o->shortcut(FL_COMMAND+'x');}
          }
          MenuItem {} {
            label {&Copy}
            callback {copy_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'c');}
          }
          MenuItem {} {
            label {&Paste}
            callback {paste_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'v');}
          }
          MenuItem {} {
            label {Select &All}
            callback {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_select_all(0,textor);}
            xywh {10 10 100 20}
            code0 {o->shortcut(FL_COMMAND+'a');}
          }
          MenuItem {} {
            label {&Preferences}
            callback {pref_window()->show();}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {&Word Wrap Toggle}
            callback {wordwrap();}
            xywh {0 0 100 20}
          }
        }
        Submenu {} {
          label {&Search}
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&Find}
            callback {find_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'f');}
          }
          MenuItem {} {
            label {F&ind Next}
            callback {find2_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'g');}
          }
          MenuItem {} {
            label {&Replace}
            callback {replace_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'r');}
          }
          MenuItem {} {
            label {Re&place Next}
            callback {replace2_cb();}
            xywh {0 0 100 20}
            code0 {o->shortcut(FL_COMMAND+'t');}
          }
          MenuItem {} {
            label {&Go to Line}
            callback {goto_cb();}
            xywh {0 0 100 20} hide deactivate
          }
        }
        Submenu {} {
          label {&Help} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&About}
            callback {about_window()->show();}
            xywh {0 0 100 20}
          }
        }
      }
      Fl_Group buttons {
        xywh {0 25 520 30} box FLAT_BOX
      } {
        Fl_Button add_button {
          label {@+}
          callback {add_tab(false);}
          tooltip {Add a Tab} xywh {492 27 25 25} box FLAT_BOX color 23
        }
        Fl_Button remove_button {
          callback {close_tab();}
          tooltip {Remove current Tab} xywh {463 27 25 25} box FLAT_BOX color 23 labelfont 1 labelsize 18
          code0 {o->image(close_image);}
        }
        Fl_Button open_button {
          callback {open_cb();}
          tooltip Open xywh {5 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_open_image);}
        }
        Fl_Button save_button {
          callback {save_cb();}
          tooltip Save xywh {35 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_save_image);}
        }
        Fl_Button new_button {
          callback {new_cb();}
          tooltip New xywh {65 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_new_image);}
        }
        Fl_Button undo_button {
          callback {undo_cb();}
          tooltip Undo xywh {95 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_undo_image);}
        }
        Fl_Button find_button {
          callback {find_cb();}
          tooltip Find xywh {145 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_search_image);}
        }
        Fl_Button replace_button {
          callback {replace_cb();}
          tooltip Replace xywh {175 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_replace_image);}
        }
        Fl_Button cp_button {
          callback {copy_cb();}
          tooltip {Copy current selection} xywh {220 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_copy_image);}
        }
        Fl_Button p_button {
          callback {paste_cb();}
          tooltip {Paste current clipboard} xywh {250 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_paste_image);}
        }
        Fl_Button settings_button {
          callback {pref_window()->show();}
          tooltip Settings xywh {430 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(settings_image);}
        }
        Fl_Button cut_button {
          callback {cut_cb();}
          tooltip {Paste current clipboard} xywh {280 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_cut_image);}
        }
      }
      Fl_Tabs tabs {
        callback {set_title(o->value());} open
        xywh {0 55 520 485} box FLAT_BOX selection_color 23 when 3
        code0 {add_tab(false);}
        code1 {button_style(BUTTON_COLOR);}
      } {}
    }
  }
  Function {pref_window()} {} {
    Fl_Window pref_win {
      label Preferences open
      xywh {265 238 310 460} type Double color 46 hide xclass flpad
    } {
      Fl_Tabs pref_tabs {open
        xywh {0 0 310 420} box FLAT_BOX
      } {
        Fl_Group gen {
          label General open
          xywh {0 25 310 395} selection_color 43
        } {
          Fl_Browser font_b {
            label Font
            callback {int F = o->value();
font_save->value(F);
const char* fonty = o->text(F);
if(fonty==NULL){return;}
font_show->value(fonty);
font_show->textfont(F);
font_show->redraw();}
            tooltip {Browse system installed fonts} xywh {5 55 290 175} type Hold box FLAT_BOX selection_color 80 align 5
            code0 {font_populate(o);}
            code1 {o->value(FONT_TEXT);}
          }
          Fl_Output font_show {
            tooltip {Sample text to show font} xywh {5 240 255 30} box FLAT_BOX selection_color 80
            code0 {const char* F = font_b->text(font_b->value());}
            code1 {if( F!=NULL){o->value(F);}}
          }
          Fl_Value_Output font_save {
            tooltip {Font Numeric for use in config file} xywh {265 240 30 30} box BORDER_BOX color 35 textcolor 7
            code0 {o->value(font_b->value());}
          }
          Fl_Check_Button tool_color {
            label {Toolbar Button Color}
            callback {int val=o->value();
button_style(val);}
            tooltip {Use color in the tool bar icons?} xywh {5 270 175 30} down_box GTK_DOWN_BOX value 1 selection_color 63 align 52
            code0 {o->value(BUTTON_COLOR);}
          }
          Fl_Button tExt {
            label Color
            callback {choose_a_color(o);}
            tooltip {Text color} xywh {25 315 55 30} box BORDER_BOX color 23 align 1
            code0 {o->color(FOREGROUND_TEXT);}
          }
          Fl_Slider f_s {
            label {Font Size}
            callback {fsout->value(o->value());}
            tooltip {Size of the text} xywh {115 310 135 30} type Horizontal box GTK_DOWN_BOX color 38 align 1 minimum 2 maximum 128 step 1
            code0 {o->value( SIZE_TEXT );}
          }
          Fl_Value_Input fsout {
            callback {f_s->value(o->value());}
            tooltip {Size of the text} xywh {260 310 30 30} box FLAT_BOX selection_color 80
            code0 {o->value( SIZE_TEXT );}
          }
          Fl_Slider l_s {
            label {Line Number Size}
            callback {lsout->value(o->value());}
            tooltip {0 hides line numbers} xywh {115 355 135 30} type Horizontal box GTK_DOWN_BOX color 38 align 1 maximum 128 step 1
            code0 {o->value(LINE_NUMBERS);}
          }
          Fl_Value_Input lsout {
            callback {l_s->value(o->value());}
            tooltip {0 hides line numbers} xywh {260 355 30 30} box FLAT_BOX selection_color 80
            code0 {o->value(LINE_NUMBERS);}
          }
          Fl_Button bg {
            label {Background Color}
            callback {choose_a_color(o);}
            tooltip {Editor background color} xywh {25 380 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color(BACKGROUND_TEXT);}
          }
        }
        Fl_Group syntax {
          label {Syntax Highlighting} open
          xywh {0 25 310 395} selection_color 43 hide
        } {
          Fl_Button cm {
            label Comments
            callback {choose_a_color(o);}
            tooltip {The color of comments} xywh {25 65 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( COMMENT_TEXT );}
          }
          Fl_Button str {
            label Strings
            callback {choose_a_color(o);}
            tooltip {The color of strings} xywh {105 65 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( STRING_TEXT );}
          }
          Fl_Button directives {
            label Symbols
            callback {choose_a_color(o);}
            tooltip {The color of symbols} xywh {25 115 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( DIRECTIVE_TEXT );}
          }
          Fl_Button typezz {
            label Types
            callback {choose_a_color(o);}
            tooltip {The color of types} xywh {105 115 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( TYPE_TEXT );}
          }
          Fl_Button keywordz {
            label Keywords
            callback {choose_a_color(o);}
            tooltip {The color of keywords} xywh {25 170 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( KEYWORD_TEXT );}
          }
          Fl_Button numbers {
            label Numbers
            callback {choose_a_color(o);}
            tooltip {The color of numbers} xywh {105 170 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( NUMBER_TEXT );}
          }
          Fl_Menu_Button theme_button {
            label Theme open
            xywh {25 210 135 30} box BORDER_BOX color 23 selection_color 72
            code0 {make_theme_menu();}
          } {}
          Fl_Check_Button plain_text {
            label {Highlight Plain text?}
            tooltip {Highlight quotes, numbers, brackets, etc... on plain text} xywh {25 250 25 25} down_box GTK_DOWN_BOX color 55 selection_color 63
            code0 {o->value(HIGHLIGHT_PLAIN);}
          }
        }
      }
      Fl_Button {} {
        label Cancel
        callback {o->parent()->hide();}
        xywh {170 425 65 30} box FLAT_BOX color 80 labelcolor 7
      }
      Fl_Button {} {
        label SAVE
        callback {FOREGROUND_TEXT=tExt->color();
BACKGROUND_TEXT=bg->color();
SIZE_TEXT=f_s->value();
LINE_NUMBERS=l_s->value();
FONT_TEXT=font_save->value();
BUTTON_COLOR=tool_color->value();
COMMENT_TEXT=cm->color();
STRING_TEXT=str->color();
DIRECTIVE_TEXT=directives->color();
TYPE_TEXT=typezz->color();
KEYWORD_TEXT=keywordz->color();
NUMBER_TEXT=numbers->color();
HIGHLIGHT_PLAIN=plain_text->value();
if(!save_preferences())
{
  trace("Failed to save preferences");
}
refresh_all();
o->parent()->hide();}
        xywh {240 425 65 30} box FLAT_BOX color 62 labelcolor 7
      }
    }
  }
  Function {add_tab(bool LOAD=true, bool NEW = true)} {} {
    code {int y = menu->y()+tabs->y()+add_button->y();
int h = tabs->h();
int w = tabs->w();
int x = tabs->x();
Fl_Group* o = new Fl_Group(x, y, w, h);
o->copy_label("Untitled");
Fl_Syntax_Text_Editor* te = new Fl_Syntax_Text_Editor(x, y,w, h);
te->user_data(o);
o->user_data(this);
win->resizable(te);
//te->when(3);
o->end();
tabs->resizable(o);
tabs->add(o);
tabs->redraw();
tabs->value(o);
if(LOAD)
  open_file(NEW);
refresh_all();} {}
  }
  Function {ask(std::string MSG, std::string yes="Yes", std::string no="No", std::string other="")} {return_type int
  } {
    code {int w = 250;
int h = 90;
Fl_Double_Window* ask_win = new Fl_Double_Window(w, h);
Fl_Box* o = new Fl_Box(5, 5, 5, 5);
o->copy_label(MSG.c_str());
o->redraw();
Fl_Button* o1 = new Fl_Button(170, 55, 65, 30, yes.c_str());
o1->box(FL_FLAT_BOX);
o1->color((Fl_Color)62);
o1->labelcolor(FL_BACKGROUND2_COLOR);
o1->callback(ask_cb,1);
Fl_Button* o2 = new Fl_Button(100, 55, 65, 30, no.c_str());
o2->box(FL_FLAT_BOX);
o2->color((Fl_Color)80);
o2->labelcolor(FL_BACKGROUND2_COLOR);
o2->callback(ask_cb,0);
if(other.compare("")!=0)
{
  Fl_Button* o3 = new Fl_Button(30, 55, 65, 30, other.c_str());
  o3->box(FL_FLAT_BOX);
  o3->color((Fl_Color)94);
  o3->labelcolor(FL_BACKGROUND2_COLOR);
  o3->callback(ask_cb,2);
}
else
{
  o1->position(5,o1->y());
  o2->position(10+o1->w(),o1->y());
  
}
ask_win->end();
ask_win->show();
o->measure_label(w,h);
o->size(w+10,h);
if(other.compare("")!=0)
{
  if(w<ask_win->w())
     w=ask_win->w()+10;
  else
    w+=10;
  if(h<ask_win->h())
    h=ask_win->h();
  else
    h +=10;
}
else
{
  int W = o2->x()+o2->w()+5;
  if(w<W)
     w=W;
  else if (w < W +10)
    w=W+10;
  else
    w+=10;
  if(h<ask_win->h())
    h=ask_win->h();
  else
    h +=10;
}
ask_win->size(w,h);
while (ask_win->shown()) Fl::wait();
return ret_val;} {}
  }
  Function {ask_cb(Fl_Widget *o, long val)} {return_type {static void}
  } {
    code {ret_val = (int) val;
o->parent()->hide();} {}
  }
  Function {button_style(int style=0)} {} {
    code {if(style==0)
{
open_button->image(open_image);
save_button->image(save_image);
new_button->image(new_image);
undo_button->image(undo_image);
find_button->image(search_image);
replace_button->image(replace_image);
cp_button->image(copy_image);
p_button->image(paste_image);
cut_button->image(cut_image);
}
else
{
open_button->image(color_open_image);
save_button->image(color_save_image);
new_button->image(color_new_image);
undo_button->image(color_undo_image);
find_button->image(color_search_image);
replace_button->image(color_replace_image);
cp_button->image(color_copy_image);
p_button->image(color_paste_image);
cut_button->image(color_cut_image);
}

open_button->redraw();
save_button->redraw();
new_button->redraw();
undo_button->redraw();
find_button->redraw();
replace_button->redraw();
cp_button->redraw();
p_button->redraw();
cut_button->redraw();} {}
  }
  Function {change_theme(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size, int line)} {} {
    code {FOREGROUND_TEXT=FG;
BACKGROUND_TEXT=BG;
SELECTION_TEXT=selection;
FONT_TEXT=font;
SIZE_TEXT=size;
LINE_NUMBERS=line;
if(tabs==NULL)
  return;
for(int i = 0; i < tabs->children();i++)
{
  Fl_Group* tab = tabs->child(i)->as_group();
  Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
  e->theme_editor(FG,BG,selection,font,size,line);
}} {}
  }
  Function {check_save()} {return_type int
  } {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  return 1;
}
if (!E->changed)
  return 1;
int r = ask("The current file has not been saved.\\n" "Would you like to save it now?", "Save", "Cancel","Discard");
if (r == 1) {
  save_cb(); // Save the file...
  return !E->changed;
}
return (r == 2) ? 1 : 0;} {}
  }
  Function {choose_a_color(Fl_Widget *o)} {return_type {unsigned int}
  } {
    code {uchar r;
uchar g;
uchar b;
Fl::get_color((o->color()),r,g,b);
int c;
const char * label ="Choose a Color";
c= fl_color_chooser(label,r,g,b,2);
if(c!=1)
  return o->color();
unsigned int C = fl_rgb_color(r,g,b);
o->color(C);
o->redraw();
return o->color();} {}
  }
  Function {choose_doc(Fl_Widget* o, void* v)} {return_type {static void}
  } {
    code {Fl_Menu_Bar *m = (Fl_Menu_Bar*)o;
const Fl_Menu_Item *p = m->mvalue();
const char* txt=p->label();
if(txt==NULL)
  return;
trace(txt);
((UI*)(p->user_data()))->pick_tab(txt);} {}
  }
  Function {close_tab()} {} {
    code {Fl_Widget * E = tabs->value();
if(E==NULL)
{
  if(ask("Exit?", "Yes", "No"))
    exit(0);
}
Fl_Group* curr = tabs->value()->as_group();
if(!check_save())
  return;
trace("Looking for correct tab");
Fl_Syntax_Text_Editor *T = NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
  trace("found a text editor!");
    T = (Fl_Syntax_Text_Editor *) curr->child(i);
    std::string tmp = T->filename;
    tmp = "Documents/"+ tmp;
    trace("menu string ="+tmp);
    int val = menu->find_index(tmp.c_str());
    if(val != -1)
    {
      trace("removing document:"+tmp);
      menu->remove(val);
    }
    menu->redraw();
  }
}

tabs->remove(E);
if(tabs->children()<=0)
{
  tabs->clear();
  win->redraw();
}
else
  tabs->value(tabs->child(0));

tabs->redraw();} {}
  }
  Function {colorize_syntax_buttons()} {} {
    code {cm->color(COMMENT_TEXT);
cm->redraw();
str->color(STRING_TEXT);
str->redraw();
directives->color(DIRECTIVE_TEXT);
directives->redraw();
typezz->color(TYPE_TEXT);
typezz->redraw();
keywordz->color(KEYWORD_TEXT);
keywordz->redraw();
numbers->color(NUMBER_TEXT);
numbers->redraw();
pref_win->show();
pref_tabs->value(syntax);
tExt->color(FOREGROUND_TEXT);
bg->color(BACKGROUND_TEXT);
tExt->redraw();
bg->redraw();} {}
  }
  Function {copy_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_copy(0, textor);} {}
  }
  Function {current_editor()} {return_type {Fl_Syntax_Text_Editor *}
  } {
    code {if(tabs==NULL)
  return NULL;
//std::cerr<<"TABS="<<tabs<<std::endl;
if(tabs->value()==NULL)
  return NULL;
//std::cerr<<"tabs->value() [Group holding Text Editor]="<<tabs->value()<<std::endl;
if(tabs->children()<=0)
  return NULL;
Fl_Group * curr = tabs->value()->as_group();
if(curr==NULL)
  return NULL;
//std::cout<<curr->children()<<std::endl;
Fl_Syntax_Text_Editor * E=NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
    E = (Fl_Syntax_Text_Editor *) curr->child(i);
   // std::cerr<<"Current Text editor="<<E<<std::endl;
    return E;
  }
}
return E;} {}
  }
  Function {cut_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_cut(0,textor);} {}
  }
  Function {default_theme()} {} {
    code {FOREGROUND_TEXT=FL_FOREGROUND_COLOR;
BACKGROUND_TEXT=FL_BACKGROUND2_COLOR;
SELECTION_TEXT=80;
FONT_TEXT=FL_COURIER;
SIZE_TEXT=14;
HIGHLIGHT_PLAIN=0;
LINE_NUMBERS=0;
//syntax
COMMENT_TEXT=1077952512;
STRING_TEXT=2625372160;
DIRECTIVE_TEXT=2050717696;
NUMBER_TEXT=4280754176;
KEYWORD_TEXT=1045337344;
TYPE_TEXT=175444736;
BUTTON_COLOR=1;} {}
  }
  Function {delete_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
textor->buffer()->remove_selection();} {}
  }
  Function {dnd_file(const char* items, bool NEW=true)} {open
  } {
    code {if(items==NULL)
  return;
std::string tmp = items;
std::vector<std::string> V = dnd_vec(tmp);
for( std::vector<std::string>::iterator itr = V.begin();
                                        itr!=V.end();
                                      ++itr)
{
  std::string s = *itr;

  unsigned int URI = s.find("file:///");
  if(URI==0)
  {
    s = s.substr(7,std::string::npos);
  }
  URI = s.find("\\n");
  if(URI<s.length())
  {
    s=s.substr(0,URI);
  }
  char *ch = strdup(s.c_str());
  fl_decode_uri(ch);
  s=ch;

  load_file(s,-1,NEW);
  free(ch);
}} {selected
    }
  }
  Function {dnd_vec(std::string in)} {return_type {std::vector<std::string>}
  } {
    code {return make_vec(in,"\\n");} {}
  }
  Function {find_cb()} {} {
    code {std::string val;
Fl_Syntax_Text_Editor * E = current_editor();
std::string SRCH = "";
if(E==NULL)
  return;
SRCH = E->search;
char * tmp = E->textbuffer->selection_text();
if(tmp!=NULL)
{
  std::string t = tmp;
  if(t.compare("")!=0)
  {
    SRCH=tmp;
    E->search=SRCH;
  }
}
val = input("Search String:",SRCH.c_str());
if (val.compare("")!=0)
{
  // User entered a string - go find it!
  E->search=val;
  find2_cb();
}} {}
  }
  Function {find2_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
  return;
std::string SRCH = "";
SRCH = E->search;
if (SRCH.compare("")==0)
{
  // Search string is blank; get a new one...
  find_cb();
  return;
}
int pos = E->insert_position();
Fl_Text_Buffer * buff = E->buffer();
int found = buff->search_forward(pos, SRCH.c_str(), &pos);
if (found)
{
  // Found a match; select and update the position...
  buff->select(pos, pos+SRCH.length());
  E->search = buff->selection_text();
  E->insert_position(pos+SRCH.length());
  E->show_insert_position();
}
else
{
  if(buff->selected())
  {
    if(fl_choice("Do you want to search from the beginning?",fl_no,fl_yes,NULL))
    {
       E->insert_position(0);
       find2_cb();
    }
  }
  else
  {
    fl_alert("No occurrences of \\'%s\\' found!", SRCH.c_str());
  }
}} {}
  }
  Function {font_populate(Fl_Browser *o)} {} {
    code {Fl_Font a;a = Fl::set_fonts("-*");
std::string v;
Fl_Font i;
for (i=1;i!=a;++i){
  v = Fl::get_font_name(i,0);
  o->add(v.c_str());
}} {}
  }
  Function {get_filename()} {return_type {std::string}
  } {
    code {const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
std::string fname="";
if(xdg_config_home==NULL)
{
  const char* home = getenv("HOME");
  if(home==NULL)
    return "";
  fname=home;
  fname+="/.config";
}
else
  fname = xdg_config_home;
fname+="/flpad/flpad.config";
return fname;} {}
  }
  Function {get_preferences()} {} {
    code {std::string fname=get_filename();
if(fname.compare("")==0)
{
  trace("Filename was empty...");
  return;
}
default_theme();

std::string subString,line;
std::ifstream inputFileStrem (fname.c_str(), std::ifstream::in);
/** check if the input file stream is open */
unsigned int start = 3;
if(inputFileStrem.is_open())
{
  while (getline(inputFileStrem,line))
  {
    if(line.find("FG:")==0)
    {
      subString=line.substr(start,std::string::npos);
      FOREGROUND_TEXT=convert(subString);
    }
    if(line.find("BG:")==0)
    {
      subString=line.substr(start,std::string::npos);
      BACKGROUND_TEXT=convert(subString);
    }
    if(line.find("SC:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SELECTION_TEXT=convert(subString);
    }
    if(line.find("FT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      FONT_TEXT=convert(subString);
    }
    if(line.find("SZ:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SIZE_TEXT=convert(subString);
    }
    if(line.find("LN:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      LINE_NUMBERS=convert(subString);
    }
    if(line.find("CM:")==0)
    {
      subString=line.substr(start,std::string::npos);
      COMMENT_TEXT=convert(subString);
    }
    if(line.find("ST:")==0)
    {
      subString=line.substr(start,std::string::npos);
      STRING_TEXT=convert(subString);
    }
    if(line.find("DE:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      DIRECTIVE_TEXT=convert(subString);
    }
    if(line.find("NM:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      NUMBER_TEXT=convert(subString);
    }
    if(line.find("KY:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      KEYWORD_TEXT=convert(subString);
    }
    if(line.find("TT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      TYPE_TEXT=convert(subString);
    }
    if(line.find("BC:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      BUTTON_COLOR=convert(subString);
    }
    if(line.find("PT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      HIGHLIGHT_PLAIN=convert(subString);
    }
  }
}
else
{
  trace(fname+" does not exist yet");
}} {}
  }
  Function {goto_cb()} {} {
    code {const char * val;
val = fl_input("Go to line \#:","");
if(val)
{
  goto_line(convert(val));
}} {}
  }
  Function {goto_line(int pos)} {} {
    code {Fl_Text_Editor * E = current_editor();
E->insert_position(E->line_start(pos));} {}
  }
  Function {handle(int event, Fl_Window *o)} {protected return_type {static int}
  } {
    code {UI* ui = ((UI*)(o->user_data()));
bool RELEASE=ui->RELEASE;
switch(event)
{
  case FL_DND_DRAG:
  case FL_DND_LEAVE:
  break;
  case FL_DND_RELEASE:
    RELEASE=true;
    trace("FL_DND_RELEASE");
    //return 1;
    break;
  case FL_RELEASE:
    if(RELEASE)
    {
      RELEASE=false;
      //trace("Pasting complete!");
      std::cout<<Fl::event_text()<<std::endl;
      //ui->dnd_file(Fl::event_text());
      return 1;
    }
}
//trace("e=",event);
return Fl::handle_(event,o);} {}
  }
  Function {handle_menu(Fl_Widget *w, void *v)} {return_type {static void}
  } {
    code {if(!w || !v)
  return;
Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)w->user_data());
UI* ui = ((UI*)T->user_data());
switch(static_cast<int>(reinterpret_cast<long>(v)))
{
  case 1: //COPY
    ui->copy_cb();
    break;
  case 2:  //CUT
    ui->cut_cb();
    break;
  case 3:  //FIND
    ui->find_cb();
    break;
  case 4: //PASTE
    ui->paste_cb();
    break;
  case 5: //UNDO
    ui->undo_cb();
    break;
}} {}
  }
  Function {input(std::string MSG, std::string text, std::string ok="OK", std::string cancel="Cancel")} {return_type {std::string}
  } {
    code {Fl_Double_Window* w = new Fl_Double_Window(285, 75);
Fl_Input* o1 = new Fl_Input(125, 5, 150, 30);
o1->box(FL_FLAT_BOX);
o1->selection_color((Fl_Color)80);
o1->copy_label(MSG.c_str());
o1->value(text.c_str());
Fl_Button* o2 = new Fl_Button(200, 40, 75, 30);
o2->box(FL_FLAT_BOX);
o2->color((Fl_Color)62);
o2->labelcolor(FL_BACKGROUND2_COLOR);
o2->callback(ask_cb,1);
o2->copy_label(ok.c_str());
Fl_Button* o = new Fl_Button(115, 40, 75, 30);
o->box(FL_FLAT_BOX);
o->color((Fl_Color)80);
o->labelcolor(FL_BACKGROUND2_COLOR);
o->copy_label(cancel.c_str());
o->callback(ask_cb,0);
w->end();
w->show();
while (w->shown()) Fl::wait();
const char* v = o1->value();
if(v == NULL)
  return "";
std::string V=v;
if(ret_val)
  return V;
return "";} {}
  }
  Function {insert_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_insert(0,textor);} {}
  }
  Function {load_file(std::string newfile, int ipos,bool NEW=true)} {} {
    code {//trace("Loading file:"+newfile);
//todo 
//if(pick_tab(newfile)){return;}
if(NEW)
{
  add_tab(false);
  trace("added tab");
}
Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  std::cerr<<"Null editor"<<std::endl;
  return;
}
E->set_type(newfile);
E->loading = 1;
int insert = (ipos != -1);
E->changed = insert;
//E->textbuffer->call_modify_callbacks();
if (!insert)
  E->filename="";
int r = 0;
if (!insert)
{
  r = E->textbuffer->loadfile(newfile.c_str());
}
else
{
  r = E->textbuffer->insertfile(newfile.c_str(), ipos);
}
E->refresh();
E->textbuffer->call_modify_callbacks();

if (r)
  fl_alert("Error reading from file \\'%s\\':\\n%s.", newfile.c_str(), strerror(errno));
else if (!insert)
  E->filename=newfile;
E->loading = 0;
set_title(tabs->value());
std::string tmp = "Documents/"+E->filename;
menu->add(tmp.c_str(),0,choose_doc,this,0);
menu->redraw();} {}
  }
  Function {make_icon(Fl_Window *o)} {} {
    code {Fl_Pixmap f(flpad_xpm);
const Fl_Pixmap * flpad_xpm_icon = &f;
const Fl_RGB_Image *img = new Fl_RGB_Image(flpad_xpm_icon,FL_GRAY);
o->icon(img);} {}
  }
  Function {none_theme()} {} {
    code {FOREGROUND_TEXT=FL_FOREGROUND_COLOR;
BACKGROUND_TEXT=FL_BACKGROUND2_COLOR;
SELECTION_TEXT=80;
FONT_TEXT=FL_COURIER;
SIZE_TEXT=14;
LINE_NUMBERS=0;
HIGHLIGHT_PLAIN=0;
//syntax
COMMENT_TEXT=FL_FOREGROUND_COLOR;
STRING_TEXT=FL_FOREGROUND_COLOR;
DIRECTIVE_TEXT=FL_FOREGROUND_COLOR;
NUMBER_TEXT=FL_FOREGROUND_COLOR;
KEYWORD_TEXT=FL_FOREGROUND_COLOR;
TYPE_TEXT=FL_FOREGROUND_COLOR;
BUTTON_COLOR=1;} {}
  }
  Function {new_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if( (!check_save()) && (textor!=NULL) )
  return;
if (textor==NULL)
{
  add_tab();
  return;
}
if(textor->filename.compare("Untitled")!=0)
{
  add_tab(true,false);
  return;
}
textor->filename="";
Fl_Text_Buffer * buff = textor->buffer();
buff->select(0, buff->length());
buff->remove_selection();
textor->changed = 0;
buff->call_modify_callbacks();
if (!check_save())
  return;
textor->filename="";
buff->select(0, buff->length());
buff->remove_selection();
textor->changed = 0;
buff->call_modify_callbacks();} {}
  }
  Function {open_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  trace("No current editor");
  open_file();
  return;
}
std::string f = E->filename;

if(f.compare("")==0)
  open_file(false);
else
  open_file();} {}
  }
  Function {open_file(bool NEW=true)} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
//std::string newf="";
std::string init="";
if(E!=NULL)
{
  init= E->filename;
}
char *newfile = fl_file_chooser("Open File?", "*",init.c_str());
if(newfile!=NULL)
{
  load_file(newfile, -1,NEW);
}} {}
  }
  Function {paste_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_paste(0,textor);} {}
  }
  Function {pick_tab(std::string file)} {return_type bool
  } {
    code {if(file.compare("")==0)
  return false;
if(tabs==NULL)
  return false;  
Fl_Group * curr = tabs->as_group();
if(curr==NULL)
  return false;
Fl_Syntax_Text_Editor * E=NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
    E = (Fl_Syntax_Text_Editor *) curr->child(i)->as_group()->child(0);
    if(E->filename.compare(file)==0)
    {
      tabs->value(curr->child(i));
      win->redraw();
      return true;
    }
    const char* lbl = E->tooltip();
    if(lbl!=NULL)
    {
      if(file.compare(lbl)==0)
      {
        tabs->value(curr->child(i));
        return true;
      }
    }
  }
}
return false;} {}
  }
  Function {prefline(std::string LINE,unsigned int COLOR)} {return_type {std::string}
  } {
    code {std::string out=LINE+":";
std::string number;
std::stringstream OUT;
OUT << COLOR;
number = OUT.str();
out+=number;
out+="\\n";
return out;} {}
  }
  Function {print_cb()} {} {
    code {Fl_Printer *printer = new Fl_Printer();
if (printer->start_job(1) == 0)
{
  printer->start_page();
  //TODO
  printer->end_page();
  printer->end_job();
}
delete printer;} {}
  }
  Function {quit_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E!=NULL)
{
  if (E->changed && !check_save())
    return;
}
exit(0);} {}
  }
  Function {replace_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E!=NULL)
  make_replace()->show();} {}
  }
  Function {replace2_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
  return;
const char *find = replace_find->value();

const char *replace = replace_with->value();
if (find == NULL)
{
trace("NULL");
// Search string is blank; get a new one...
  replace_dlg->show();
  return;
}
replace_dlg->hide();
int pos = E->insert_position();
Fl_Text_Buffer * buff = E->buffer();
int found = buff->search_forward(pos, find, &pos);
if (found)
{
// Found a match; update the position and replace text...
  buff->select(pos, pos+strlen(find));
  buff->remove_selection();
  buff->insert(pos, replace);
  buff->select(pos, pos+strlen(replace));
  E->insert_position(pos+strlen(replace));
  E->show_insert_position();
}
else
  fl_alert("No occurrences of \\'%s\\' found!", find);} {}
  }
  Function {replall_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
  return;
const char *find = replace_find->value();
const char *replace = replace_with->value();
find = replace_find->value();
if (find == NULL)
{
trace("NULL");
// Search string is blank; get a new one...
  replace_dlg->show();
  return;
}

replace_dlg->hide();
E->insert_position(0);
int times = 0;
Fl_Text_Buffer * buff = E->buffer();
// Loop through the whole string
for (int found = 1; found;)
{
  int pos = E->insert_position();
  found = buff->search_forward(pos, find, &pos);
  if (found)
  {
  // Found a match; update the position and replace text...
    buff->select(pos, pos+strlen(find));
    buff->remove_selection();
    buff->insert(pos, replace);
    E->insert_position(pos+strlen(replace));
    E->show_insert_position();
    times++; 
  }
}
if (times)
  fl_message("Replaced %d occurrences.", times);
else
  fl_alert("No occurrences of \\'%s\\' found!", find);} {}
  }
  Function {replace_start()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string SRCH = "";
if(E!=NULL)
 SRCH = E->search;
char * tmp = E->textbuffer->selection_text();
if(tmp!=NULL)
{
  std::string t = tmp;
  if(t.compare("")!=0)
  {
    SRCH=tmp;
    E->search=SRCH;
  }
}

replace_find->value(SRCH.c_str());} {}
  }
  Function {resize(Fl_Widget* o)} {} {
    code {if(o==NULL)
  return;
int width = win->w();
int height = win->h() - (buttons->h() +buttons->x());
o->size(width,height);
o->redraw();} {}
  }
  Function {refresh_all()} {} {
    code {change_theme(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);} {}
  }
  Function {save_cb(void)} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string fname="";
if(E==NULL)
{
  return;
}
fname=E->filename;
if (fname.compare("")==0)
{
// No filename - get one!
  saveas_cb();
  return;
}
else
  save_file(fname);} {}
  }
  Function {saveas_cb(void)} {} {
    code {char *newfile;
Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
newfile = fl_file_chooser("Save File As?", "*", textor->filename.c_str());
if (newfile != NULL)
  save_file(newfile);} {}
  }
  Function {save_preferences()} {return_type bool
  } {
    code {std::string out=prefline("FG",FOREGROUND_TEXT);
out+=prefline("BG",BACKGROUND_TEXT);
out+=prefline("SC",SELECTION_TEXT);
out+=prefline("FT",FONT_TEXT);
out+=prefline("SZ",SIZE_TEXT);
out+=prefline("LN",LINE_NUMBERS);
out+=prefline("CM",COMMENT_TEXT);
out+=prefline("ST",STRING_TEXT);
out+=prefline("DE",DIRECTIVE_TEXT);
out+=prefline("NM",NUMBER_TEXT);
out+=prefline("KY",KEYWORD_TEXT);
out+=prefline("TT",TYPE_TEXT);
out+=prefline("BC",BUTTON_COLOR);
out+=prefline("PT",HIGHLIGHT_PLAIN);
std::ofstream dest;
std::string fname=get_filename();
dest.open(fname.c_str());
if(!dest.is_open()){
  fl_alert("Error writing to file \\'%s\\':\\n%s.", fname.c_str(), strerror(errno));
  return false;
}
dest << out;
dest.close();
return true;} {}
  }
  Function {save_file(std::string newfile)} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Buffer * buff = textor->buffer();
if (buff->savefile(newfile.c_str()))
  fl_alert("Error writing to file \\'%s\\':\\n%s.", newfile.c_str(), strerror(errno));
else
{
  textor->filename=newfile;
  textor->changed = 0;
  buff->call_modify_callbacks();
  set_title(textor->parent());
  ((Fl_Widget *)(textor->user_data()))->labelcolor(NORMAL_COLOR);
}} {}
  }
  Function {set_title(Fl_Widget* g)} {} {
    code {if(g==NULL)
  return;
std::string title;
Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
std::string fname = textor->filename;
std::string full = fname;

//Is the file name empty???  set it to Untitled!!
if (fname.compare("")==0)
{
  title="Untitled";
}
else
{
// get JUST the filename (remove the path... similare to fl_filename_name()
  unsigned int slash = fname.rfind('/');
  \#ifdef WIN32
  if (slash>fname.length())
    slash =fname.rfind('\\\\');
  \#endif
  if (slash <fname.length())
  {
    //FILENAME ONLY
    title=fname.substr(slash+1,std::string::npos);
    //PATH to file ONLY
    full = fname.substr(0,slash);
  }
  else
    title=fname;
    
}
textor->refresh();
//Has this been changed at all??
if (textor->changed)
{
  title+=" (modified)";
}
std::string Ti = title;

if(full.compare("")!=0)
{
  // is there a path???  add it!!
  Ti = Ti + "(" + full + ")";
}
win->copy_label(Ti.c_str());
g->copy_label(title.c_str());
g->copy_tooltip(fname.c_str());
g->redraw();
tabs->redraw();} {}
  }
  Function {show_line_numbers(int width=0)} {} {
    code {for(int i = 0;i< tabs->children();i++)
{
std::cout<<i<<std::endl;
  Fl_Group* tab = tabs->child(i)->as_group();
  Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
  e->linenumber_width(width);
}} {}
  }
  Function {undo_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_undo(0,textor);} {}
  }
  Function {wordwrap()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string fname="";
if(E==NULL)
{
  return;
}
if(E->WRAPPED)
{
  E->WRAPPED=false;
  E->wrap_mode(Fl_Text_Display::WRAP_NONE, 0);
}
else
{
  E->WRAPPED=true;
  E->wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
}} {}
  }
  Function {get_theme_from_config(std::string theme)} {} {
    code {trace("theme="+theme);
//COLORS
FOREGROUND_TEXT=get_theme(theme,"foreground");
BACKGROUND_TEXT=get_theme(theme,"background");
COMMENT_TEXT=get_theme(theme,"comments");
STRING_TEXT=get_theme(theme,"strings");
NUMBER_TEXT=get_theme(theme,"numbers");
KEYWORD_TEXT=get_theme(theme,"keywords");
DIRECTIVE_TEXT=get_theme(theme,"symbol");
TYPE_TEXT=get_theme(theme,"types");
SELECTION_TEXT=get_theme(theme,"selection");
//ETC
FONT_TEXT=get_theme(theme,"font");
SIZE_TEXT=get_theme(theme,"font_size");
LINE_NUMBERS=get_theme(theme,"line_number_size");
HIGHLIGHT_PLAIN=get_theme(theme,"highlight_plain_text");
BUTTON_COLOR=get_theme(theme,"button_color");

//modify the window
cm->color(COMMENT_TEXT);
cm->redraw();
str->color(STRING_TEXT);
str->redraw();
directives->color(DIRECTIVE_TEXT);
directives->redraw();
typezz->color(TYPE_TEXT);
typezz->redraw();
keywordz->color(KEYWORD_TEXT);
keywordz->redraw();
numbers->color(NUMBER_TEXT);
numbers->redraw();
plain_text->value(HIGHLIGHT_PLAIN);
bg->color(BACKGROUND_TEXT);
bg->redraw();
tExt->color(FOREGROUND_TEXT);
tExt->redraw();
f_s->value(SIZE_TEXT);
fsout->value(SIZE_TEXT);
l_s->value(LINE_NUMBERS);
lsout->value(LINE_NUMBERS);
tool_color->value(BUTTON_COLOR);} {}
  }
  Function {theme_menu_cb(Fl_Widget* o, void* v)} {return_type {static void}
  } {
    code {Fl_Menu_Button *m = (Fl_Menu_Button*)o;
const Fl_Menu_Item *p = m->mvalue();
const char* txt=p->label();
if(txt==NULL)
  return;
trace(txt);
((UI*)(p->user_data()))->get_theme_from_config(txt);} {}
  }
  Function {make_theme_menu()} {open
  } {
    code {std::vector<std::string> V = get_themes();
for( std::vector<std::string>::iterator itr = V.begin();
                                        itr!=V.end();
                                      ++itr)
{
  std::string tmp = *itr;
  theme_button->add(tmp.c_str(),0,theme_menu_cb,this,0);
}
theme_button->redraw();} {}
  }
}

Function {comma_line(std::string lang,std::string field)} {return_type {std::vector<std::string>}
} {
  code {//get the line from the file
std::string LINE=get(lang,field);
//return a vector from the string delimited by commas
return make_vec(LINE,",");} {}
}

Function {convert(std::string num)} {return_type {unsigned int}
} {
  code {unsigned int NUM=0;
try{NUM=std::stoul(num);}
catch(const std::invalid_argument e){return 0;}
catch(const std::out_of_range e){return 0;}
return NUM;} {}
}

Function {get(std::string header, std::string line)} {return_type {std::string}
} {
  code {if(line.compare("")==0){return "";}
if(header.compare("")==0){return "";}
std::string filename = get_syntax_file();
if(filename.compare("")==0){return "";}
if(!test_file(filename))
{
  trace("No file sent in\\n"+filename+","+line);
  return "";
}
std::string find_header=header;
unsigned int open=header.find("[");
unsigned int close=header.find("]");
unsigned int header_length=header.length();
if(open>header_length){find_header="["+find_header;}
if(close>header_length){find_header=find_header+"]";}

bool found_after_this=false;
std::string this_line;
int lengthofARGS = line.length();
std::string subString;
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  while (getline(inputFileStrem,this_line))
  {
    subString=this_line.substr(0,lengthofARGS);
    if(this_line.find("[")<=1)
    {
      found_after_this=false;
    }
    if(this_line.find(find_header)<this_line.length())
    {
      //trace("FOUND:"+find_header);
      found_after_this=true;
    }
    /** if found return it immediately */
    if(found_after_this)
    {
      if(this_line.find(line)<this_line.length())
      {
        unsigned int eq = this_line.find("=");
        if(eq<this_line.length())
        {
          this_line=this_line.substr(eq+1,std::string::npos);
        }
        return this_line;
      }
    }
  }
}
return "";} {}
}

Function {get_syntax_file()} {return_type {std::string}
} {
  code {std::string base_name = "flpad/styles.flpad";
if(SYNTAX_FILE.compare("")!=0)
  return SYNTAX_FILE;
//testing
std::string home_tester;
const char* home_config = getenv("XDG_CONFIG_HOME");
if(home_config == NULL)
{
  home_config = getenv("HOME");
  if(home_config != NULL)
  {
    home_tester=home_config;
    home_tester =home_tester + "/.config/" + base_name;
  }
}
else
{
  home_tester = home_config;
  home_tester = home_tester + "/" + base_name;
}
trace(home_tester);
if(test_file(home_tester))
{
  SYNTAX_FILE=home_tester;
}
else
{
  std::string tester = "/usr/share/";
  if(test_file(tester+base_name))
  {
    SYNTAX_FILE=tester+base_name;
  }
  else
  {
    tester = "/usr/local/share/";
    if(test_file(tester+base_name))
      SYNTAX_FILE=tester+base_name;
  }
}
if(SYNTAX_FILE.compare("")==0)
  trace("No syntax file found...");
return SYNTAX_FILE;} {}
}

Function {get_theme_file()} {return_type {std::string}
} {
  code {std::string base_name = "flpad/themes.flpad";
std::string tmp;
//testing
std::string home_tester;
const char* home_config = getenv("XDG_CONFIG_HOME");
if(home_config == NULL)
{
  home_config = getenv("HOME");
  if(home_config != NULL)
  {
    home_tester=home_config;
    home_tester =home_tester + "/.config/" + base_name;
  }
}
else
{
  home_tester = home_config;
  home_tester = home_tester + "/" + base_name;
}
trace(home_tester);
if(test_file(home_tester))
{
  tmp=home_tester;
}
else
{
  std::string tester = "/usr/share/";
  if(test_file(tester+base_name))
  {
    tmp=tester+base_name;
  }
  else
  {
    tester = "/usr/local/share/";
    if(test_file(tester+base_name))
      tmp=tester+base_name;
  }
}
if(tmp.compare("")==0)
  trace("No THEME file found...");
return tmp;} {}
}

Function {get_type(std::string fname)} {return_type {std::string}
} {
  code {if(!test_file(fname))
{
  trace("No file sent in\\n"+fname);
  return "";
}

const char* ext = fl_filename_ext(fname.c_str());

/// get the shebang
std::string thisLine;
std::ifstream inputFileStream(fname.c_str(), std::ifstream::in);
if(inputFileStream.is_open())
{
  getline(inputFileStream,thisLine);
}

// shell scripts don't always constain an extention... but the shebang tells
if(thisLine.find("\#!")==0)
{
  std::string tmp=thisLine;
  unsigned int find = tmp.rfind("/");
  if(find<tmp.length())
  {
    tmp=tmp.substr(find+1,std::string::npos);
    tmp="."+tmp;
    ext=tmp.c_str();
  }
}

//nothing?  lets leave then...
if(ext == NULL)
  return "";

std::string EXT=ext;
unsigned int f_dot = EXT.find(".");
if(f_dot<EXT.length())
  EXT=EXT.substr(f_dot+1,std::string::npos);
//trace("extention="+EXT);
//get the syntax highlighter file
std::string filename = get_syntax_file();
if(filename.compare("")==0){return "";}

//this is the line we are looking for
std::string line="ext=";

//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
       trace("["+HEADER+"]");
    }
    unsigned int eq = this_line.find("=");
    if(this_line.find(line)<this_line.length())
    {
      this_line=this_line.substr(eq+1,std::string::npos);
      trace(this_line+"::"+EXT);
      std::vector<std::string> V = make_vec(this_line,",");
      for( std::vector<std::string>::iterator itr = V.begin();
                                              itr!=V.end();
                                              ++itr)
      {
        std::string tmp=*itr;
        //trace(tmp+"=="+EXT);
        if(tmp.compare(EXT)==0)
          return HEADER;
      }
    }
  }
}

if(EXT.compare("bash")==0)
  return "sh";
return "";} {}
}

Function {get_themes()} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> THEMES;
std::string filename = get_theme_file();
if(filename.compare("")==0){return THEMES;}


//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
       THEMES.push_back(HEADER);
    }
  }
}
return THEMES;} {}
}

Function {get_theme(std::string theme, std::string item)} {return_type int
} {
  code {std::string filename = get_theme_file();
if(filename.compare("")==0){return 0;}

//this is the line we are looking for
std::string line=item;

trace(item);
//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
bool ready=false;
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
       if(theme.compare(HEADER)==0)
         ready=true;
    }
    if(ready)
    {
      unsigned int eq = this_line.find("=");
      if(this_line.find(line)<eq)
      {
        this_line=this_line.substr(eq+1,std::string::npos);
        trace("color="+this_line);
        return convert(this_line);
      }
    }
  }
}
return 0;} {}
}

Function {is_space(const char x)} {return_type bool
} {
  code {return std::isspace(x);} {}
}

Function {keywords(std::string header)} {return_type {std::vector <std::string>}
} {
  code {return comma_line(header, "keywords");} {}
}

Function {main(int argc, char **argv)} {return_type int
} {
  code {NORMAL_COLOR=FL_BLACK;
EDIT_COLOR=FL_RED;
SingletonProcess singleton(7777);
if (!singleton())
{
  std::cerr<< "process running already. See " << singleton.GetLockFileName() << std::endl;
  return 1;
}
UI *ui = new UI();
bool new_tab=false;
try
{
  ui->get_preferences();
  Fl::set_fonts();
  ui->make_window()->show();
  ui->win->wait_for_expose();
  if (argc > 1)
  {
    for (int i=1; i<argc; i++)
    {
      char* charchar1 = argv[i];
      if(charchar1 != NULL)
      {
        std::string fname = charchar1;
        ui->dnd_file(fname.c_str(),new_tab);
        new_tab=true;
      }
    }
  }
  return Fl::run();
}
catch (const std::exception& e)
{
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...)
{
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}} {}
}

Function {make_vec(std::string string_to_become_vector,std::string delimiter=" ")} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> Vector;
std::string original,preComma,postComma;
original=string_to_become_vector;
unsigned int found,finder;
finder=original.length();
if(original.find(delimiter)>original.length())
{
  Vector.push_back(original);
  return Vector;
}
for(found=original.find(delimiter);found<finder;found=original.find(delimiter))
{
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0)
  {
    preComma.erase( std::remove_if( preComma.begin(), preComma.end(), is_space)
                    ,preComma.end());
    //trace(preComma);
    Vector.push_back(preComma);
  }
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
}

Function {trace(std::string MSG, int n = 0)} {} {
  code {//return;
std::cout<<MSG;
if(n!=0)
  std::cout<<"-->"<<n;
std::cout<<std::endl;} {}
}

Function {test_file(std::string file)} {return_type bool
} {
  code {//if empty it doesn't exist
if(file.compare("")==0)
  return false;


std::string dir=file;
unsigned int find = dir.rfind("/");

//if there is no directory this isn't correct
if(find>dir.length())
{
  // try the PWD if we can
  const char* PWD= getenv("PWD");
  if(PWD==NULL)
    return false;
  dir=PWD;
  dir+="/";
  file=dir+file;
}
else
{
  // get the directory
  dir=dir.substr(0,find);
}

//open the directory
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());

//make sure there is a slash at the end
if(dir.rfind('/')!=dir.length()-1){dir+="/";}

if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      //get a pointer to the file in this directory
      std::string fullpath=entryPointer->d_name;
      fullpath=dir+fullpath;
      //is it the same as what we sent in?
      if(fullpath.compare(file)==0)
      {
        //close the directory
        closedir(mydir);
        return true;
      }
    }
  }
  //close the directory... apparently this didn't work :(
  closedir(mydir);
}
return false;} {}
}

Function {types(std::string header)} {return_type {std::vector <std::string>}
} {
  code {return comma_line(header, "types");} {}
}
