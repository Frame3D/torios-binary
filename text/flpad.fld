# data file for the Fltk User Interface Designer (fluid)
version 1.0304
i18n_type 1
i18n_include <libintl.h>
i18n_function gettext
header_name {.h}
code_name {.cxx}
decl {\#include <X11/Xlib.h>} {public global
}

comment {copyright 2018 Israel Dahl
GPL 3
created from the FLTK tutorial using FLUID to design the UI
created as part of the ToriOS project} {in_source in_header
}

decl {\#include "lexertk.hpp"} {public global
}

decl {\#include "../include/toolbar_icons.h"} {public global
}

decl {\#include <algorithm>} {public global
}

decl {\#include <sstream>} {public global
}

decl {\#include <dirent.h>} {public global
}

decl {\#include <fstream>} {public global
}

decl {\#include <iostream>} {public global
}

decl {\#include <streambuf>} {public global
}

decl {\#include <FL/Fl_Color_Chooser.H>} {public global
}

decl {\#include <FL/Fl_File_Chooser.H>} {public global
}

decl {\#include <FL/Fl_Text_Editor.H>} {public global
}

decl {\#include <FL/Fl_Printer.H>} {public global
}

decl {\#include <FL/fl_ask.H>} {public global
}

decl {\#include <FL/Fl_RGB_Image.H>} {public global
}

decl {\#include <errno.h>} {public global
}

decl {\#include <vector>} {public global
}

decl {\#include <ctype.h>} {public global
}

decl {\#include <string.h>} {public global
}

decl {\#include <stdlib.h>} {public global
}

decl {\#include <stdio.h>} {public global
}

decl {\#include <cstdio>} {public global
}

decl {\#include <cstdlib>} {public global
}

decl {\#include <string>} {public global
}

decl {\#include <sys/inotify.h>} {public global
}

decl {\#include <unistd.h>} {public global
}

decl {int ret_val;} {public global
}

decl {std::string return_value;} {public global
}

decl {unsigned int EDIT_COLOR, NORMAL_COLOR, MATCH_CASE, BACKWARD_SEARCH;} {public global
}

decl {unsigned int FOREGROUND_TEXT;
unsigned int BACKGROUND_TEXT;
unsigned int SELECTION_TEXT;
unsigned int COMMENT_TEXT;
unsigned int STRING_TEXT;
unsigned int DIRECTIVE_TEXT;
unsigned int NUMBER_TEXT;
unsigned int KEYWORD_TEXT;
unsigned int TYPE_TEXT;
unsigned int SYMBOLS_TEXT;
unsigned int SPECIAL_TEXT;
unsigned int BROKEN_TEXT;
int FONT_TEXT;
int SIZE_TEXT;
int LINE_NUMBERS;
int BUTTON_COLOR;
int HIGHLIGHT_PLAIN;
int INDENT_NEW_LINES;} {public global
}

decl {std::vector<std::string> SYNTAX_HEADERS;} {public global
}

decl {std::string SYNTAX_FILE;} {public global
}

class Fl_Syntax_Text_Editor {open : {public Fl_Text_Editor}
} {
  decl {int inotify_fd;} {public local
  }
  decl {int inotify_wd;} {public local
  }
  Function {Fl_Syntax_Text_Editor(int x, int y, int w, int h, const char* label = 0):Fl_Text_Editor(x,y,w,h,label)} {open
  } {
    code {IGNORE_SYNTAX_CASE = false;
SPACES             = false;
RELEASE            = false;
DND_START          = false;
WRAPPED            = false;
changed            = 0;
loading            = 0;
filename           = "";
textbuffer         = new Fl_Text_Buffer();

this->resize(x,y,w,h);
this->buffer(textbuffer);

char *style = new char[textbuffer->length() + 1];
char *text = textbuffer->text();

memset(style, 'A', textbuffer->length());
stylebuffer = new Fl_Text_Buffer(textbuffer->length());
style[textbuffer->length()] = '\\0';

init_highlight();

stylebuffer->text(style);

delete[] style;
free(text);

box(FL_FLAT_BOX);

theme_editor(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);

textbuffer->add_modify_callback(changed_cb,(void *)this);
/*if(!take_focus())
{
  trace("Failed to take focus for Text Editor");
}
*/
Fl::focus(this);} {}
  }
  Function {~Fl_Syntax_Text_Editor()} {} {
    code {buffer(0);
textbuffer->remove_modify_callback(style_update, this);
textbuffer->remove_modify_callback(changed_cb, this);
if(rm_inotify())
{
  trace("problem removing inotify watch");
}} {}
  }
  decl {bool SPACES;} {public global
  }
  decl {bool WRAPPED;} {public global
  }
  decl {bool IGNORE_SYNTAX_CASE;} {public local
  }
  decl {bool RELEASE, DND_START;} {public local
  }
  decl {Fl_Text_Display::Style_Table_Entry styletable[10];} {public global
  }
  decl {Fl_Text_Buffer * stylebuffer;} {public global
  }
  decl {Fl_Text_Buffer * textbuffer;} {public global
  }
  decl {std::string filename;} {public local
  }
  decl {std::string search;} {public local
  }
  decl {int changed;} {public global
  }
  decl {int loading;} {public global
  }
  decl {std::vector<std::string> KEYWORDS, TYPES;} {public global
  }
  decl {std::string STYLE_HEADER;} {protected local
  }
  decl {lexertk::generator generator} {private local
  }
  decl {lexertk::helper::bracket_checker bracket_checker;} {public local
  }
  decl {lexertk::helper::symbol_replacer symbol_replacer;} {public local
  }
  Function {changed_cb(int, int nInserted, int nDeleted, int, const char*, void *v)} {return_type {static void}
  } {
    code {Fl_Syntax_Text_Editor * o = (Fl_Syntax_Text_Editor *)v;
std::string f = o->filename;
if ((nInserted || nDeleted) && !o->loading)
{
  o->changed = 1;
}
((UI *)(o->parent()->user_data()))->set_title(o->parent());} {}
  }
  Function {enter_kf(int, Fl_Text_Editor *e)} {open return_type {static int}
  } {
    code {kill_selection(e);
Fl_Syntax_Text_Editor* E = (Fl_Syntax_Text_Editor*)e;
std::string SPACES = E->count_spaces();
std::string t = "\\n";
t+=SPACES;
e->insert(t.c_str());
e->show_insert_position();
e->set_changed();
if (e->when()&FL_WHEN_CHANGED) e->do_callback();
return 1;} {}
  }
  Function {file_string()} {return_type {std::string}
  } {
    code {if(filename.compare("")==0){return "";}
std::ifstream t(filename);
std::string str;

t.seekg(0, std::ios::end);   
str.reserve(t.tellg());
t.seekg(0, std::ios::beg);

str.assign((std::istreambuf_iterator<char>(t)),
            std::istreambuf_iterator<char>());
return str;} {}
  }
  Function {get_styletable(Fl_Text_Display::Style_Table_Entry &styles,int which)} {} {
    code {int font = FONT_TEXT;
int bold = font + 1;
int ital = bold + 1;
std::string whichtype="Plain";
switch(which)
{
  case 0:
    styles={ FOREGROUND_TEXT, font, FL_NORMAL_SIZE }; // A - Plain
    whichtype="Plain";
    break;
  case 1:
    styles={ COMMENT_TEXT, ital, FL_NORMAL_SIZE }; // B - Line comments
    whichtype="Line comments";
    break;
  case 2:
    styles={ DIRECTIVE_TEXT, ital, FL_NORMAL_SIZE }; // C -Directives
    whichtype="Directives";
    break;
  case 3:
    styles={ STRING_TEXT, font, FL_NORMAL_SIZE }; // D - Strings
    whichtype="Strings";
    break;
  case 4:
    styles={ SYMBOLS_TEXT, font, FL_NORMAL_SIZE }; // E - Symbols
    whichtype="Symbols";
    break;
  case 5:
    styles={ TYPE_TEXT, bold, FL_NORMAL_SIZE }; // F - Types
    whichtype="Types";
    break;
  case 6:
    styles={ KEYWORD_TEXT, bold, FL_NORMAL_SIZE }; // G - Keywords
    whichtype="Keywords";
    break;
  case 7:
    styles={ NUMBER_TEXT, font, FL_NORMAL_SIZE }; // H - numbers
    whichtype="numbers";
    break;
  case 8:
    styles={ SPECIAL_TEXT, font, FL_NORMAL_SIZE }; // I - special
    break;
  case 9:
    styles={ BROKEN_TEXT, font, FL_NORMAL_SIZE }; // J - Broken :(
    break;
}
styletable[which] = styles; //  set} {}
  }
  Function {handle(int event)} {open protected return_type int
  } {
    code {UI* ui = ((UI*)(parent()->parent()->parent()->user_data()));
switch(event)
{
  case FL_PUSH:
  case FL_RELEASE:
    if(Fl::event_button() == FL_RIGHT_MOUSE)
    {
      if(Fl::event_clicks())
      {
        break;
      }
      ui->make_popup(this);
      return 1;
    }
    break;
  case FL_DND_DRAG:
  case FL_DND_LEAVE:
  case FL_DND_RELEASE:
    RELEASE = true;
    break;
  case FL_PASTE:
    if(RELEASE)
    {
      RELEASE   = false;
      ui->dnd_file(Fl::event_text());
      return 1;
    }
    break;
}
//    check_inotify();

return Fl_Text_Editor::handle(event);} {}
  }
  Function {init_highlight()} {} {
    code {update_styletable();

highlight_data(stylebuffer, styletable, sizeof(styletable) / sizeof(styletable[0]), 'A', style_unfinished_cb, 0);
textbuffer->add_modify_callback(style_update, (void*) this);} {}
  }
  Function {kill_selection(Fl_Text_Editor* e)} {return_type {static void}
  } {
    code {if (e->buffer()->selected())
{
  e->insert_position(e->buffer()->primary_selection()->start());
  e->buffer()->remove_selection();
}} {}
  }
  Function {modify_cb(int pos=0, int nInserted=0, int nDeleted=0, int unused=0, const char * nada=NULL)} {open return_type void
  } {
    code {if(stylebuffer->selected()!=0)
{
   stylebuffer->unselect();
   return;
}

std::string thisLine;
if ( (HIGHLIGHT_PLAIN==0)&& (STYLE_HEADER.compare("")==0) )
{
  char *style = new char[textbuffer->length() + 1];
  memset(style, 'A', textbuffer->length());
  style[textbuffer->length()] = '\\0';
  stylebuffer->text(style);
}
else
{
  char* buf = this->textbuffer->text();
  if(buf == NULL)
    return;
  std::string out(buf);
  std::string res = style_line(out);
  char* RES = const_cast <char*> (res.c_str());
  if (RES == NULL)
    return;
  stylebuffer->text(RES);
}
redisplay_range(0,textbuffer->length());} {}
  }
  Function {refresh()} {} {
    code {set_syntax();
modify_cb(0,0,0,0,NULL);
redisplay_range(0,textbuffer->length());
redraw();} {}
  }
  Function {set_syntax()} {} {
    code {set_type(filename);} {}
  }
  Function {set_type(std::string fname)} {} {
    code {std::string dir=fname;
unsigned int find = dir.rfind("/");

//if there is no directory this isn't correct
if(find>dir.length())
{
  // try the PWD if we can
  const char* PWD= getenv("PWD");
  if(PWD!=NULL)
  {
    dir=PWD;
    dir+="/";
    fname=dir+fname;
    this->filename=fname;
  }
}

if( (fname.empty()) || (fname.compare("")==0) )
  return;
this->filename=fname;
this->STYLE_HEADER = get_type(this->filename);
//trace(STYLE_HEADER);
std::string ignore_case   = get(this->STYLE_HEADER, "ignore_case");
if(ignore_case.compare("")!=0)
{
  //trace("ignore_case="+ignore_case);
  std::transform(ignore_case.begin(), ignore_case.end(), ignore_case.begin(), ::tolower);
  if(ignore_case.compare("true")==0)
    this->IGNORE_SYNTAX_CASE=true;
  if(this->IGNORE_SYNTAX_CASE)
    trace("ignoring syntax case for "+this->STYLE_HEADER+" files");
}

this->KEYWORDS     = keywords(this->STYLE_HEADER, this->IGNORE_SYNTAX_CASE);
this->TYPES        = types(this->STYLE_HEADER, this->IGNORE_SYNTAX_CASE);

//comments
std::string c_open        = get(this->STYLE_HEADER,"blockopen");
std::string c_close       = get(this->STYLE_HEADER,"blockclose");
std::string c_single      = get(this->STYLE_HEADER,"comments");
//define
std::string def           = get(this->STYLE_HEADER,"defines");
//special
std::string special_open  = get(this->STYLE_HEADER,"special_open");
std::string special_close = get(this->STYLE_HEADER,"special_close");


//Set everything in the generator
this->generator.set_comments(c_open,c_close,c_single);
this->generator.set_defines(def.c_str());
this->generator.set_special(special_open,special_close);
this->generator.set_keywords(this->KEYWORDS);
this->generator.set_types(this->TYPES);

//trace("set syntax type for: "+fname+" to:"+STYLE_HEADER);} {}
  }
  Function {style_line(std::string thisLine)} {return_type {std::string}
  } {
    code {if(!generator.process(thisLine))
  trace("error processing text:"+thisLine);
else
{
  std::string line = lexertk::helper::style_line(generator);
  if(line.compare("")==0)
  {
    //trace("adding newline!");
    line="\\n";
  }
  return line;
}
return "A";} {}
  }
  Function {style_update(int pos=0, int nInserted=0, int nDeleted=0, int unused=0, const char * nada=NULL, void *cbArg = NULL)} {return_type {static void}
  } {
    code {Fl_Syntax_Text_Editor * ED = (Fl_Syntax_Text_Editor *)cbArg;
if(ED==NULL)
{
  trace("Couldn't get text editor :(");
  return;
}
ED->modify_cb(pos, nInserted, nDeleted, unused, nada);} {}
  }
  Function {style_unfinished_cb(int, void*)} {return_type {static void}
  } {
    code {} {}
  }
  Function {theme_editor(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size,int linenum )} {} {
    code {textcolor(FG);
cursor_color(FG);
color(BG);
textfont(font);
textsize(size);
selection_color(selection);
linenumber_width(linenum);
linenumber_size(size);

///renew highlighter
update_styletable();
modify_cb();} {}
  }
  Function {update_styletable()} {} {
    code {Fl_Text_Display::Style_Table_Entry A; //  Plain
get_styletable(A,0);

Fl_Text_Display::Style_Table_Entry B; // Line comments
get_styletable(B,1);

Fl_Text_Display::Style_Table_Entry C; // Block comments
get_styletable(C,2);

Fl_Text_Display::Style_Table_Entry D; // Strings
get_styletable(D,3);

Fl_Text_Display::Style_Table_Entry E; // Directives
get_styletable(E,4);

Fl_Text_Display::Style_Table_Entry F; // Types
get_styletable(F,5);

Fl_Text_Display::Style_Table_Entry G;  // Keywords
get_styletable(G,6);

Fl_Text_Display::Style_Table_Entry H; // Numbers
get_styletable(H,7);

Fl_Text_Display::Style_Table_Entry I; // Special
get_styletable(I,8);

Fl_Text_Display::Style_Table_Entry J; // Broken
get_styletable(J,9);

use_spaces();} {}
  }
  Function {use_spaces()} {} {
    code {remove_key_binding(FL_Enter,FL_TEXT_EDITOR_ANY_STATE);
if(SPACES)
{
//use my function
  add_key_binding(FL_Enter,FL_TEXT_EDITOR_ANY_STATE,enter_kf);
}
else
{
//use default function
  add_key_binding(FL_Enter,FL_TEXT_EDITOR_ANY_STATE,kf_enter);
}} {}
  }
  Function {count_spaces()} {return_type {std::string}
  } {
    code {int pos = insert_position();
//std::cout<<pos<<"<--position"<<std::endl;
std::string spaces;
int Pos = textbuffer->line_start(pos);
if(Pos == pos)
  return "";

if(SPACES)
{
  int start = textbuffer->line_start(pos);
  int end   = textbuffer->line_end(pos);
  int init = 0;
  for(int i = start; i < end; i++)
  {
    char A = textbuffer->char_at(i);
    if ( (' ' == A) || ( '\\t' == A) )
    {
      spaces+=A;
      init++;
    }
    else
      break;
  }
}
return spaces;} {}
  }
  Function {init_inotify(std::string file)} {} {
    code {//int event_buf_len = ( 1024 * ( (sizeof (struct inotify_event)) + 16 ) );

inotify_fd = inotify_init();
inotify_wd = inotify_add_watch (inotify_fd, file.c_str(), IN_MODIFY | IN_CREATE | IN_DELETE);

if ( inotify_wd < 0 )
{
  perror("inotify_add_watch failed");
}} {}
  }
  Function {rm_inotify()} {return_type int
  } {
    code {return inotify_rm_watch (inotify_fd, inotify_wd);} {}
  }
  Function {check_inotify()} {return_type bool
  } {
    code {if(filename.compare("")==0)
  return false;
//Took this directly from an old linux journal article
struct timeval time;
fd_set rfds;
int ret;

/* timeout after five seconds */
time.tv_sec = 5;
time.tv_usec = 0;

/* zero-out the fd_set */
FD_ZERO (&rfds);

/*
 * add the inotify fd to the fd_set -- of course,
 * your application will probably want to add
 * other file descriptors here, too
 */
FD_SET (inotify_fd, &rfds);

std::string File_was_modified = gettext(" was modified,\\ndo you want to reload it?");

ret = select (inotify_fd + 1, &rfds, NULL, NULL, &time);

if( (ret !=0) && (FD_ISSET (inotify_fd, &rfds)) )
{
  if(ask(filename + File_was_modified)==1)
  {
    //they want to reload it
    rm_inotify();
    textbuffer->loadfile(filename.c_str());
    init_inotify(filename.c_str());
    modify_cb();
  }
  return true;
}
return false;} {}
  }
}

class UI {open
} {
  decl {bool RELEASE;} {public local
  }
  decl {Fl_Text_Buffer *about_buffer;} {public global
  }
  Function {UI()} {} {
    code {get_preferences();
RELEASE=false;} {}
  }
  Function {about_window()} {} {
    Fl_Window about_win {
      label About open
      xywh {744 141 305 370} type Double hide resizable
      code0 {about_buffer = new Fl_Text_Buffer();}
      code1 {make_icon(o);} xclass flpad
    } {
      Fl_Text_Display about_dialog {
        xywh {0 0 305 320} box FLAT_BOX selection_color 72 resizable
      }
      Fl_Button {} {
        label Close
        callback {o->parent()->hide();}
        xywh {220 330 80 30} box FLAT_BOX color 80 labelcolor 7
      }
    }
  }
  Function {make_popup(Fl_Widget *o)} {} {
    code {Fl_Menu_Item rclick_menu[] = {
  { "Copy",  0, handle_menu, (void*)1 },
  { "Cut",  0, handle_menu, (void*)2 },
  { "Find",  0, handle_menu, (void*)3 },
  { "Paste",  0, handle_menu, (void*)4 },
  { "Undo",  0, handle_menu, (void*)5 },
  { 0 }
};
Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)o->user_data());
UI* ui = ((UI*)T->user_data());

const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, ui->menu);
if ( m )
{

  m->do_callback(o, m->user_data());
}
return;} {}
  }
  Function {find_window()} {} {
    Fl_Window find_win {open
      xywh {298 104 270 150} type Double hide
    } {
      Fl_Input finder {
        callback {int match = match_case->value();
int backward   = search_bwd->value();
const char* va = finder->value();
if(va==NULL)
  return;
std::string term = va;
find2_cb(match, backward,term);}
        xywh {40 5 185 25} box FLAT_BOX selection_color 80 when 8
        code0 {std::string init = find_selection();}
        code1 {o->value(init.c_str());}
      }
      Fl_Check_Button match_case {
        label {Match Case}
        callback {MATCH_CASE = o->value();}
        xywh {40 40 115 25} down_box GTK_DOWN_BOX color 55 selection_color 63
        code0 {o->value(MATCH_CASE);}
      }
      Fl_Button {} {
        label Search
        callback {int match = match_case->value();
int backward   = search_bwd->value();
const char* va = finder->value();
if(va==NULL)
  return;
std::string term = va;
find2_cb(match, backward,term);}
        xywh {180 110 80 25} box FLAT_BOX color 62 selection_color 68 labelcolor 7
      }
      Fl_Check_Button search_bwd {
        label {Backward Search}
        callback {BACKWARD_SEARCH = o->value();}
        xywh {40 65 145 25} down_box GTK_DOWN_BOX color 55 selection_color 63
        code0 {o->value(BACKWARD_SEARCH);}
      }
      Fl_Button {} {
        label Cancel
        callback {o->parent()->hide();}
        xywh {95 110 75 25} box FLAT_BOX color 80 selection_color 64 labelcolor 7
      }
    }
  }
  Function {make_replace()} {} {
    Fl_Window replace_dlg {
      label {Find and Replace} open
      xywh {100 148 375 100} type Double hide
      code0 {make_icon(o);} xclass flpad
    } {
      Fl_Input replace_find {
        label Find
        xywh {70 5 295 25} box FLAT_BOX
        code0 {replace_start();}
      }
      Fl_Input replace_with {
        label Replace
        xywh {70 35 295 25} box FLAT_BOX
      }
      Fl_Button replace_cancel {
        label Cancel
        callback {replace_dlg->hide();}
        xywh {295 65 70 30} box FLAT_BOX color 80 labelcolor 7
      }
      Fl_Button replace_all {
        label {Replace All}
        callback {replall_cb();}
        xywh {185 65 95 30} box FLAT_BOX color 94
      }
      Fl_Button replace_next {
        label {Replace Next}
        callback {replace2_cb();}
        xywh {70 65 100 30} box FLAT_BOX color 61 labelcolor 7
      }
    }
  }
  Function {make_window()} {open
  } {
    Fl_Window win {
      label flpad open
      xywh {348 120 520 545} type Double color 47 hide
      code1 {o->size_range(o->w(), o->h(), 0, 0);}
      code2 {make_icon(o);} xclass flpad
    } {
      Fl_Group buttons {
        xywh {0 25 520 30} box FLAT_BOX
      } {
        Fl_Button add_button {
          label {@+}
          callback {add_tab(false);}
          tooltip {Add a Tab} xywh {492 27 25 25} box FLAT_BOX color 23
        }
        Fl_Button remove_button {
          callback {close_tab();}
          tooltip {Remove current Tab} xywh {463 27 25 25} box FLAT_BOX color 23 labelfont 1 labelsize 18
          code0 {o->image(close_image);}
        }
        Fl_Button open_button {
          callback {open_cb();}
          tooltip Open xywh {5 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_open_image);}
        }
        Fl_Button save_button {
          callback {save_cb();}
          tooltip Save xywh {35 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_save_image);}
        }
        Fl_Button new_button {
          callback {new_cb();}
          tooltip New xywh {65 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_new_image);}
        }
        Fl_Button undo_button {
          callback {undo_cb();}
          tooltip Undo xywh {95 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_undo_image);}
        }
        Fl_Button find_button {
          callback {find_cb();}
          tooltip Find xywh {145 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_search_image);}
        }
        Fl_Button replace_button {
          callback {replace_cb();}
          tooltip Replace xywh {175 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_replace_image);}
        }
        Fl_Button cp_button {
          callback {copy_cb();}
          tooltip {Copy current selection} xywh {220 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_copy_image);}
        }
        Fl_Button p_button {
          callback {paste_cb();}
          tooltip {Paste current clipboard} xywh {250 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_paste_image);}
        }
        Fl_Button settings_button {
          callback {pref_window()->show();}
          tooltip Settings xywh {430 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(settings_image);}
        }
        Fl_Button cut_button {
          callback {cut_cb();}
          tooltip {Paste current clipboard} xywh {280 27 25 25} box FLAT_BOX labelfont 1
          code0 {o->image(color_cut_image);}
        }
      }
      Fl_Menu_Bar menu {open
        xywh {0 0 520 25} box FLAT_BOX down_box FLAT_BOX color 39 selection_color 80 labelsize 16 labelcolor 7 align 260 textsize 16 textcolor 7
      } {
        Submenu {} {
          label {&File}
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&New}
            callback {new_cb();}
            xywh {0 0 100 20} shortcut 0x4006e
          }
          MenuItem {} {
            label {&Open}
            callback {open_cb();}
            xywh {0 0 100 20} shortcut 0x4006f
          }
          MenuItem {} {
            label {&Insert}
            callback {insert_cb();}
            xywh {0 0 100 20} shortcut 0x50069
          }
          MenuItem {} {
            label {&Save}
            callback {save_cb();}
            xywh {0 0 100 20} shortcut 0x40073
          }
          MenuItem {} {
            label {Save &As...}
            callback {saveas_cb();}
            xywh {10 10 100 20} shortcut 0x50073
          }
          MenuItem {} {
            label {&Exit}
            callback {quit_cb();}
            xywh {0 0 100 20} shortcut 0x40071
          }
        }
        Submenu {} {
          label {&Edit}
          xywh {0 0 100 25} labelsize 16
        } {
          MenuItem {} {
            label {&Undo}
            callback {undo_cb();}
            xywh {0 0 100 20} shortcut 0x4007a
          }
          MenuItem {} {
            label {&Cut}
            callback {cut_cb();}
            xywh {0 0 100 20} shortcut 0x40078 labelsize 16
          }
          MenuItem {} {
            label {&Copy}
            callback {copy_cb();}
            xywh {0 0 100 20} shortcut 0x40063
          }
          MenuItem {} {
            label {&Paste}
            callback {paste_cb();}
            xywh {0 0 100 20} shortcut 0x40076
          }
          MenuItem {} {
            label {Select &All}
            callback {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_select_all(0,textor);}
            xywh {10 10 100 20} shortcut 0x40061
          }
          MenuItem {} {
            label {&Preferences}
            callback {pref_window()->show();}
            xywh {0 0 100 20} shortcut 0xffbe
          }
          MenuItem {} {
            label {&Word Wrap Toggle}
            callback {wordwrap();}
            xywh {0 0 100 20} shortcut 0x4006a
          }
        }
        Submenu {} {
          label {&Search} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&Find}
            callback {find_window()->show();}
            xywh {0 0 100 20} shortcut 0x40066
          }
          MenuItem {} {
            label {F&ind Next}
            callback {find2_cb();}
            xywh {0 0 100 20} shortcut 0x40067
          }
          MenuItem {} {
            label {&Replace}
            callback {replace_cb();}
            xywh {0 0 100 20} shortcut 0x40068
          }
          MenuItem {} {
            label {Re&place Next}
            callback {replace2_cb();}
            xywh {0 0 100 20} shortcut 0x40074
          }
          MenuItem {} {
            label {&Go to Line}
            callback {goto_cb();}
            xywh {0 0 100 20} shortcut 0x40069
          }
        }
        Submenu {} {
          label {&Tools} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&Color Chooser}
            callback {color_tool();}
            xywh {0 0 100 20} shortcut 0x5006a
          }
        }
        Submenu {} {
          label {&Help} open
          xywh {0 0 100 20}
        } {
          MenuItem {} {
            label {&About}
            callback {check_file("about");}
            xywh {0 0 100 20}
          }
          MenuItem {} {
            label {&Syntax Highlighter}
            callback {check_file("syntax.help","Syntax Highlighter");}
            xywh {10 10 100 20}
          }
          MenuItem {} {
            label {&Theme Creation}
            callback {check_file("styles.help","Theme Creation");}
            xywh {20 20 100 20}
          }
        }
      }
      Fl_Tabs tabs {
        callback {set_title(o->value());
Fl_Group* g = o->child(o->find(o->value()))->as_group();
Fl::focus(g->child(0));} open
        xywh {0 55 520 490} box FLAT_BOX selection_color 23 when 3
        code0 {add_tab(false);}
        code1 {button_style(BUTTON_COLOR);}
      } {}
    }
  }
  Function {pref_window()} {} {
    Fl_Window pref_win {
      label Preferences
      xywh {265 238 310 460} type Double color 46 hide
      code0 {make_icon(o);} xclass flpad
    } {
      Fl_Tabs pref_tabs {open
        xywh {0 0 310 420} box FLAT_BOX
      } {
        Fl_Group gen {
          label General
          xywh {0 25 310 395} selection_color 43
        } {
          Fl_Browser font_b {
            label Font
            callback {int F = o->value();
font_save->value(F);
const char* fonty = o->text(F);
if(fonty==NULL){return;}
font_show->value(fonty);
font_show->textfont(F);
font_show->redraw();}
            tooltip {Browse system installed fonts} xywh {5 55 290 175} type Hold box FLAT_BOX selection_color 80 align 5
            code0 {font_populate(o);}
            code1 {o->value(FONT_TEXT);}
          }
          Fl_Output font_show {
            tooltip {Sample text to show font} xywh {5 240 255 30} box FLAT_BOX selection_color 80
            code0 {const char* F = font_b->text(font_b->value());}
            code1 {if( F!=NULL){o->value(F);}}
          }
          Fl_Value_Output font_save {
            tooltip {Font Numeric for use in config file} xywh {265 240 30 30} box BORDER_BOX color 35 textcolor 7
            code0 {o->value(font_b->value());}
          }
          Fl_Check_Button tool_color {
            label {Toolbar Button Color}
            callback {int val=o->value();
button_style(val);}
            tooltip {Use color in the tool bar icons?} xywh {5 270 175 30} down_box GTK_DOWN_BOX value 1 selection_color 63 align 52
            code0 {o->value(BUTTON_COLOR);}
          }
          Fl_Button tExt {
            label Color
            callback {choose_a_color(o);}
            tooltip {Text color} xywh {25 315 55 30} box BORDER_BOX color 23 align 1
            code0 {o->color(FOREGROUND_TEXT);}
          }
          Fl_Slider f_s {
            label {Font Size}
            callback {fsout->value(o->value());}
            tooltip {Size of the text} xywh {115 310 135 30} type Horizontal box GTK_DOWN_BOX color 38 align 1 minimum 2 maximum 128 step 1
            code0 {o->value( SIZE_TEXT );}
          }
          Fl_Value_Input fsout {
            callback {f_s->value(o->value());}
            tooltip {Size of the text} xywh {260 310 30 30} box FLAT_BOX selection_color 80
            code0 {o->value( SIZE_TEXT );}
          }
          Fl_Slider l_s {
            label {Line Number Size}
            callback {lsout->value(o->value());}
            tooltip {0 hides line numbers} xywh {115 355 135 30} type Horizontal box GTK_DOWN_BOX color 38 align 1 maximum 128 step 1
            code0 {o->value(LINE_NUMBERS);}
          }
          Fl_Value_Input lsout {
            callback {l_s->value(o->value());}
            tooltip {0 hides line numbers} xywh {260 355 30 30} box FLAT_BOX selection_color 80
            code0 {o->value(LINE_NUMBERS);}
          }
          Fl_Button bg {
            label {Background Color}
            callback {choose_a_color(o);}
            tooltip {Editor background color} xywh {25 380 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color(BACKGROUND_TEXT);}
          }
        }
        Fl_Group syntax {
          label {Syntax Highlighting} open
          xywh {0 25 310 395} selection_color 43 hide
        } {
          Fl_Button cm {
            label Comments
            callback {choose_a_color(o);}
            tooltip {The color of comments} xywh {25 65 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( COMMENT_TEXT );}
          }
          Fl_Button str {
            label Strings
            callback {choose_a_color(o);}
            tooltip {The color of strings} xywh {105 65 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( STRING_TEXT );}
          }
          Fl_Button symbols {
            label Symbols
            callback {choose_a_color(o);}
            tooltip {The color of symbols} xywh {25 115 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( SYMBOLS_TEXT );}
          }
          Fl_Button typezz {
            label Types
            callback {choose_a_color(o);}
            tooltip {The color of types} xywh {105 115 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( TYPE_TEXT );}
          }
          Fl_Button keywordz {
            label Keywords
            callback {choose_a_color(o);}
            tooltip {The color of keywords} xywh {25 170 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( KEYWORD_TEXT );}
          }
          Fl_Button numbers {
            label Numbers
            callback {choose_a_color(o);}
            tooltip {The color of numbers} xywh {105 170 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( NUMBER_TEXT );}
          }
          Fl_Menu_Button theme_button {
            label Theme
            xywh {25 210 135 30} box BORDER_BOX color 23 selection_color 72
            code0 {make_theme_menu();}
          } {}
          Fl_Check_Button plain_text {
            label {Enable Highlighting Plain text}
            tooltip {Highlight quotes, numbers, brackets, etc... on plain text} xywh {25 250 25 25} down_box GTK_DOWN_BOX color 55 selection_color 63
            code0 {o->value(HIGHLIGHT_PLAIN);}
          }
          Fl_Button directives {
            label Directives
            callback {choose_a_color(o);}
            tooltip {The color of strings} xywh {185 65 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( DIRECTIVE_TEXT );}
          }
          Fl_Button special {
            label Special
            callback {choose_a_color(o);}
            tooltip {This could be something like elements for XML, for <> in includes in c/++} xywh {185 115 55 30} box BORDER_BOX color 23 align 129
            code0 {o->color( SPECIAL_TEXT );}
          }
          Fl_Button broken {
            label Broken
            callback {choose_a_color(o);}
            tooltip {Broken brackets} xywh {185 170 55 30} box BORDER_BOX color 23 align 129 deactivate
            code0 {o->color( BROKEN_TEXT );}
          }
          Fl_Check_Button indentor {
            label {Enable Auto Indentation}
            tooltip {This will save the initial spacing from the current line for the next ENTER} xywh {25 285 25 25} down_box GTK_DOWN_BOX color 55 selection_color 63
            code0 {o->value(INDENT_NEW_LINES);}
          }
        }
      }
      Fl_Button {} {
        label Cancel
        callback {o->parent()->hide();}
        xywh {170 425 65 30} box FLAT_BOX color 80 labelcolor 7
      }
      Fl_Button {} {
        label SAVE
        callback {FOREGROUND_TEXT  = tExt->color();
BACKGROUND_TEXT  = bg->color();
SIZE_TEXT        = f_s->value();
LINE_NUMBERS     = l_s->value();
FONT_TEXT        = font_save->value();
BUTTON_COLOR     = tool_color->value();
COMMENT_TEXT     = cm->color();
STRING_TEXT      = str->color();
SYMBOLS_TEXT     = symbols->color();
DIRECTIVE_TEXT   = directives->color();
TYPE_TEXT        = typezz->color();
KEYWORD_TEXT     = keywordz->color();
NUMBER_TEXT      = numbers->color();
HIGHLIGHT_PLAIN  = plain_text->value();
SPECIAL_TEXT     = special->color();
BROKEN_TEXT      = broken->color();
INDENT_NEW_LINES = indentor->value();
if(!save_preferences())
{
  trace("Failed to save preferences");
}

refresh_all();
o->parent()->hide();}
        xywh {240 425 65 30} box FLAT_BOX color 62 labelcolor 7
      }
    }
  }
  Function {add_tab(bool LOAD=true, bool NEW = true)} {} {
    code {int y = menu->y()+tabs->y()+add_button->y();
int h = tabs->h();
int w = tabs->w();
int x = tabs->x();
tabs->client_area(x,y,w,h);
Fl_Group* o = new Fl_Group(x, y, w, h);
o->copy_label("Untitled");

Fl_Syntax_Text_Editor* te = new Fl_Syntax_Text_Editor(x,y,w,h);
te->user_data(o);
if(INDENT_NEW_LINES>0)
{
  te->SPACES=true;
  te->use_spaces();
}
o->user_data(this);
win->resizable(te);
o->end();

tabs->resizable(o);
tabs->add(o);
tabs->redraw();
tabs->value(o);

if(LOAD)
  open_file(NEW);

refresh_all();} {}
  }
  Function {button_style(int style=0)} {} {
    code {if(style==0)
{
open_button->image(open_image);
save_button->image(save_image);
new_button->image(new_image);
undo_button->image(undo_image);
find_button->image(search_image);
replace_button->image(replace_image);
cp_button->image(copy_image);
p_button->image(paste_image);
cut_button->image(cut_image);
}
else
{
open_button->image(color_open_image);
save_button->image(color_save_image);
new_button->image(color_new_image);
undo_button->image(color_undo_image);
find_button->image(color_search_image);
replace_button->image(color_replace_image);
cp_button->image(color_copy_image);
p_button->image(color_paste_image);
cut_button->image(color_cut_image);
}

open_button->redraw();
save_button->redraw();
new_button->redraw();
undo_button->redraw();
find_button->redraw();
replace_button->redraw();
cp_button->redraw();
p_button->redraw();
cut_button->redraw();} {}
  }
  Function {change_theme(unsigned int FG,unsigned int BG, unsigned int selection, int font, int size, int line)} {} {
    code {FOREGROUND_TEXT=FG;
BACKGROUND_TEXT=BG;
SELECTION_TEXT=selection;
FONT_TEXT=font;
SIZE_TEXT=size;
LINE_NUMBERS=line;
if(tabs==NULL)
  return;
for(int i = 0; i < tabs->children();i++)
{
  Fl_Group* tab = tabs->child(i)->as_group();
  Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
  e->theme_editor(FG,BG,selection,font,size,line);
}} {}
  }
  Function {check_file(std::string file,std::string title="About")} {} {
    code {about_window()->show();
about_win->wait_for_expose();
std::string tmp = get_flpad_dir(file);
//trace("got:"+tmp);
about_win->wait_for_expose();
about_win->copy_label(title.c_str());
if(tmp.compare("")==0)
{
  std::string res = "Designed in FLUID, based on the FLTK tutorial\\
Copyright 1998-2005 by Bill Spitzak and others.\\
\\
lexertk.hpp was created by Arash Partow, and\\
heavily modified to provide syntax highlighting.\\
\\
colored icons were inspired by:\\
numixproject/numix-icon-theme-circle\\
though all were hand coded xpm files.\\
\\
This version was built for ToriOS\\
copyright 2018 Israel Dahl";
  char* RES = const_cast <char*> (res.c_str());
  about_win->wait_for_expose();
  about_buffer->text(RES);
}
else
{
  //return;
  about_buffer->loadfile(file.c_str());
}

about_dialog->buffer(about_buffer);} {}
  }
  Function {check_save()} {return_type int
  } {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  return 1;
}
if (!E->changed)
  return 1;
int r = ask("The current file has not been saved.\\n" "Would you like to save it now?", "Save", "Cancel","Discard");
if (r == 1) {
  save_cb(); // Save the file...
  return !E->changed;
}
return (r == 2) ? 1 : 0;} {}
  }
  Function {choose_a_color(Fl_Widget *o)} {open return_type {unsigned int}
  } {
    code {uchar r;
uchar g;
uchar b;
Fl::get_color((o->color()),r,g,b);
int c;
const char * label ="Choose a Color";
c= fl_color_chooser(label,r,g,b,2);
if(c!=1)
  return o->color();
unsigned int C = fl_rgb_color(r,g,b);
o->color(C);
o->redraw();
return o->color();} {}
  }
  Function {choose_doc(Fl_Widget* o, void* v)} {return_type {static void}
  } {
    code {Fl_Menu_Bar *m = (Fl_Menu_Bar*)o;
const Fl_Menu_Item *p = m->mvalue();
const char* txt=p->label();
if(txt==NULL)
  return;
trace(txt);
((UI*)(p->user_data()))->pick_tab(txt);} {}
  }
  Function {close_tab()} {} {
    code {Fl_Widget * E = tabs->value();
if(E==NULL)
{
  if(ask("Exit?", "Yes", "No"))
    exit(0);
}
Fl_Group* curr = tabs->value()->as_group();
if(!check_save())
  return;
//trace("Looking for correct tab");
Fl_Syntax_Text_Editor *T = NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
  //trace("found a text editor!");
    T = (Fl_Syntax_Text_Editor *) curr->child(i);
    std::string tmp = T->filename;
    tmp = "Documents/"+ tmp;
    //trace("menu string ="+tmp);
    int val = menu->find_index(tmp.c_str());
    if(val != -1)
    {
      //trace("removing document:"+tmp);
      menu->remove(val);
    }
    menu->redraw();
  }
}

tabs->remove(E);
if(tabs->children()<=0)
{
  tabs->clear();
  win->redraw();
  win->copy_label("flpad");
}
else
{
  tabs->value(tabs->child(0));
  set_title(tabs->value());
}
tabs->redraw();} {}
  }
  Function {color_tool()} {open
  } {
    code {std::string val;
Fl_Syntax_Text_Editor * E = current_editor();

if(E==NULL)
{
  return;
}

char *       tmp = E->textbuffer->selection_text();

if(tmp!=NULL)
{
  std::string t = tmp;

  if(t.compare("")!=0)
  {
    uchar r;
    uchar g;
    uchar b;
    unsigned int color = get_fl_color(t);
    Fl::get_color(color,r,g,b);
    int c;
    const char * label ="Choose a Color";
    c= fl_color_chooser(label,r,g,b,2);
    if(c!=1)
    {
      return;
    }
    unsigned int C = fl_rgb_color(r,g,b);
    uchar r1;
    uchar g1;
    uchar b1;
    Fl::get_color(C,r1,g1,b1);
    double* colors = new double[4];
    colors[0] = int(r1); 
    colors[1] = int(g1);
    colors[2] = int(b1);
    colors[3] = 0;
    std::string out_color = color_to_string(colors);
    trace(out_color);
    const char* replace = out_color.c_str();
    Fl_Text_Buffer * buff = E->textbuffer;
    int pos = buff->primary_selection()->start();
    buff->remove_selection();
    buff->insert(pos, replace);
    buff->select(pos, pos+strlen(replace));
    E->insert_position(pos+strlen(replace));
    E->show_insert_position();
  }
}} {selected
    }
  }
  Function {colorize_syntax_buttons()} {} {
    code {cm->color(COMMENT_TEXT);
cm->redraw();

str->color(STRING_TEXT);
str->redraw();

symbols->color(SYMBOLS_TEXT);
symbols->redraw();

directives->color(DIRECTIVE_TEXT);
directives->redraw();

typezz->color(TYPE_TEXT);
typezz->redraw();

keywordz->color(KEYWORD_TEXT);
keywordz->redraw();

numbers->color(NUMBER_TEXT);
numbers->redraw();

bg->color(BACKGROUND_TEXT);
bg->redraw();

tExt->color(FOREGROUND_TEXT);
tExt->redraw();

broken->color(BROKEN_TEXT);
broken->redraw();

special->color(SPECIAL_TEXT);
special->redraw();

tExt->redraw();
bg->redraw();} {}
  }
  Function {copy_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_copy(0, textor);} {}
  }
  Function {current_editor()} {return_type {Fl_Syntax_Text_Editor *}
  } {
    code {if(tabs==NULL)
  return NULL;
//std::cerr<<"TABS="<<tabs<<std::endl;
if(tabs->value()==NULL)
  return NULL;
//std::cerr<<"tabs->value() [Group holding Text Editor]="<<tabs->value()<<std::endl;
if(tabs->children()<=0)
  return NULL;
Fl_Group * curr = tabs->value()->as_group();
if(curr==NULL)
  return NULL;
//std::cout<<curr->children()<<std::endl;
Fl_Syntax_Text_Editor * E=NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
    E = (Fl_Syntax_Text_Editor *) curr->child(i);
   // std::cerr<<"Current Text editor="<<E<<std::endl;
    return E;
  }
}
return E;} {}
  }
  Function {cut_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_cut(0,textor);} {}
  }
  Function {default_theme()} {} {
    code {FOREGROUND_TEXT = FL_FOREGROUND_COLOR;
BACKGROUND_TEXT = FL_BACKGROUND2_COLOR;
SELECTION_TEXT  = 80;
FONT_TEXT       = FL_COURIER;
SIZE_TEXT       = 14;
HIGHLIGHT_PLAIN = 0;
LINE_NUMBERS    = 0;

//syntax
COMMENT_TEXT    = 1077952512;
STRING_TEXT     = 2625372160;
DIRECTIVE_TEXT  = 2050717696;
NUMBER_TEXT     = 4280754176;
KEYWORD_TEXT    = 1045337344;
TYPE_TEXT       = 175444736;
SYMBOLS_TEXT    = FL_FOREGROUND_COLOR;
SPECIAL_TEXT    = FL_FOREGROUND_COLOR;
BROKEN_TEXT     = FL_RED;
BUTTON_COLOR    = 1;} {}
  }
  Function {delete_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
textor->buffer()->remove_selection();} {}
  }
  Function {dnd_file(const char* items, bool NEW=true)} {} {
    code {if(items==NULL)
  return;
std::string tmp = items;
std::vector<std::string> V = dnd_vec(tmp);
for( std::vector<std::string>::iterator itr = V.begin();
                                        itr!=V.end();
                                      ++itr)
{
  std::string s = *itr;

  unsigned int URI = s.find("file:///");
  if(URI==0)
  {
    s = s.substr(7,std::string::npos);
  }
  URI = s.find("\\n");
  if(URI<s.length())
  {
    s=s.substr(0,URI);
  }
  char *ch = strdup(s.c_str());
  fl_decode_uri(ch);
  s=ch;

  load_file(s,-1,NEW);
  free(ch);
}} {}
  }
  Function {dnd_vec(std::string in)} {return_type {std::vector<std::string>}
  } {
    code {return make_vec(in,"\\n");} {}
  }
  Function {find_cb()} {open
  } {
    code {std::string val;
Fl_Syntax_Text_Editor * E = current_editor();
std::string SRCH = "";
if(E==NULL)
  return;
SRCH = E->search;
char * tmp = E->textbuffer->selection_text();
if(tmp!=NULL)
{
  std::string t = tmp;
  if(t.compare("")!=0)
  {
    SRCH=tmp;
    E->search=SRCH;
  }
}
val = input("Search String:",SRCH.c_str());
if (val.compare("")!=0)
{
  // User entered a string - go find it!
  E->search=val;
  find2_cb();
}} {}
  }
  Function {find2_cb(int match_case=0, int backward = 1, std::string term="")} {open
  } {
    code {Fl_Syntax_Text_Editor * E = current_editor();

if(E==NULL)
{
  return;
}

int pos = E->insert_position();

int found = 0;

if(backward)
{
  int init = E->textbuffer->line_start(pos);
  init--;
   E->textbuffer->line_start(init);
  found = E->textbuffer->search_backward(init, term.c_str(), &pos, match_case);
}
else
{
  found = E->textbuffer->search_forward(pos, term.c_str(), &pos, match_case);
}

if (found)
{
  // Found a match; select and update the position...
  E->textbuffer->select(pos, pos+term.length());
  E->search = E->textbuffer->selection_text();
  E->insert_position(pos+term.length());
  E->show_insert_position();
}
else
{
  if(E->textbuffer->selected())
  {
    std::string begend = "beginning";

    if(backward)
      begend = "end";

    if(ask("Do you want to search from the "+begend +"?")==1)
    {
      if(backward)
      {
        E->insert_position(E->textbuffer->length());
      }
      else
      {
        E->insert_position(0);
      }
      E->textbuffer->unselect();
      find2_cb(match_case,backward,term);
    }
  }
  else
  {
    fl_alert("No occurrences of \\'%s\\' found!", term.c_str());
  }
}} {}
  }
  Function {font_populate(Fl_Browser *o)} {} {
    code {Fl_Font a;a = Fl::set_fonts("-*");
std::string v;
Fl_Font i;
for (i=1;i!=a;++i){
  v = Fl::get_font_name(i,0);
  o->add(v.c_str());
}} {}
  }
  Function {get_filename()} {return_type {std::string}
  } {
    code {const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
std::string fname="";
if(xdg_config_home==NULL)
{
  const char* home = getenv("HOME");
  if(home==NULL)
    return "";
  fname=home;
  fname+="/.config";
}
else
  fname = xdg_config_home;
fname+="/flpad/flpad.config";
return fname;} {}
  }
  Function {get_preferences()} {} {
    code {std::string fname=get_filename();
if(fname.compare("")==0)
{
  trace("Filename was empty...");
  return;
}
default_theme();

std::string subString,line;
std::ifstream inputFileStrem (fname.c_str(), std::ifstream::in);
/** check if the input file stream is open */
unsigned int start = 3;
if(inputFileStrem.is_open())
{
  while (getline(inputFileStrem,line))
  {
    if(line.find("FG:")==0)
    {
      subString=line.substr(start,std::string::npos);
      FOREGROUND_TEXT=convert(subString);
    }
    if(line.find("BG:")==0)
    {
      subString=line.substr(start,std::string::npos);
      BACKGROUND_TEXT=convert(subString);
    }
    if(line.find("SC:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SELECTION_TEXT=convert(subString);
    }
    if(line.find("FT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      FONT_TEXT=convert(subString);
    }
    if(line.find("SZ:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SIZE_TEXT=convert(subString);
    }
    if(line.find("LN:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      LINE_NUMBERS=convert(subString);
    }
    if(line.find("CM:")==0)
    {
      subString=line.substr(start,std::string::npos);
      COMMENT_TEXT=convert(subString);
    }
    if(line.find("ST:")==0)
    {
      subString=line.substr(start,std::string::npos);
      STRING_TEXT=convert(subString);
    }
    if(line.find("DE:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      DIRECTIVE_TEXT=convert(subString);
    }
    if(line.find("SY:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SYMBOLS_TEXT=convert(subString);
    }
    if(line.find("NM:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      NUMBER_TEXT=convert(subString);
    }
    if(line.find("KY:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      KEYWORD_TEXT=convert(subString);
    }
    if(line.find("TT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      TYPE_TEXT=convert(subString);
    }
    if(line.find("BC:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      BUTTON_COLOR=convert(subString);
    }
    if(line.find("PT:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      HIGHLIGHT_PLAIN=convert(subString);
    }
    if(line.find("BR:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      BROKEN_TEXT=convert(subString);
    }
    if(line.find("SP:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      SPECIAL_TEXT=convert(subString);
    }
    if(line.find("IL:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      INDENT_NEW_LINES=convert(subString);
    }
    if(line.find("MC:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      MATCH_CASE=convert(subString);
    }
    if(line.find("BW:")<line.length())
    {
      subString=line.substr(start,std::string::npos);
      BACKWARD_SEARCH=convert(subString);
    }
  }
}
else
{
  trace(fname+" does not exist yet");
}} {}
  }
  Function {get_theme_from_config(std::string theme)} {} {
    code {//COLORS
FOREGROUND_TEXT = get_theme( theme, "foreground",           FOREGROUND_TEXT );
BACKGROUND_TEXT = get_theme( theme, "background",           BACKGROUND_TEXT );
COMMENT_TEXT    = get_theme( theme, "comments",             COMMENT_TEXT );
STRING_TEXT     = get_theme( theme, "strings",              STRING_TEXT );
NUMBER_TEXT     = get_theme( theme, "numbers",              NUMBER_TEXT );
KEYWORD_TEXT    = get_theme( theme, "keywords",             KEYWORD_TEXT );
SYMBOLS_TEXT    = get_theme( theme, "symbol",               SYMBOLS_TEXT );
DIRECTIVE_TEXT  = get_theme( theme, "directives",           DIRECTIVE_TEXT );
TYPE_TEXT       = get_theme( theme, "types",                TYPE_TEXT );
SELECTION_TEXT  = get_theme( theme, "selection",            SELECTION_TEXT );
SPECIAL_TEXT    = get_theme( theme, "special_color",        SPECIAL_TEXT );
BROKEN_TEXT     = get_theme( theme, "broken_color",         BROKEN_TEXT );
//ETC
FONT_TEXT       = get_theme( theme, "font",                 FONT_TEXT );
SIZE_TEXT       = get_theme( theme, "font_size",            SIZE_TEXT );
LINE_NUMBERS    = get_theme( theme, "line_number_size",     LINE_NUMBERS );
HIGHLIGHT_PLAIN = get_theme( theme, "highlight_plain_text", HIGHLIGHT_PLAIN );
BUTTON_COLOR    = get_theme( theme, "button_color",         BUTTON_COLOR );

///modify the window

//colors
colorize_syntax_buttons();

//etc
f_s->value(SIZE_TEXT);
fsout->value(SIZE_TEXT);

l_s->value(LINE_NUMBERS);
lsout->value(LINE_NUMBERS);

tool_color->value(BUTTON_COLOR);

plain_text->value(HIGHLIGHT_PLAIN);} {}
  }
  Function {goto_cb()} {} {
    code {std::string val;
val = input("Go to line \#:");
if(val.compare("")!=0)
{
  goto_line(convert(val));
}} {}
  }
  Function {goto_line(int pos)} {} {
    code {Fl_Text_Editor * E = current_editor();
E->scroll(pos,0);
E->take_focus();
std::cout<<E->insert_position()<<std::endl;} {}
  }
  Function {handle(int event, Fl_Window *o)} {protected return_type {static int}
  } {
    code {UI* ui = ((UI*)(o->user_data()));
bool RELEASE=ui->RELEASE;
switch(event)
{
  case FL_DND_DRAG:
  case FL_DND_LEAVE:
  break;
  case FL_DND_RELEASE:
    RELEASE=true;
    trace("FL_DND_RELEASE");
    //return 1;
    break;
  case FL_RELEASE:
    if(RELEASE)
    {
      RELEASE=false;
      //trace("Pasting complete!");
      std::cout<<Fl::event_text()<<std::endl;
      //ui->dnd_file(Fl::event_text());
      return 1;
    }
}
//trace("e=",event);
return Fl::handle_(event,o);} {}
  }
  Function {handle_menu(Fl_Widget *w, void *v)} {return_type {static void}
  } {
    code {if(!w || !v)
  return;
Fl_Syntax_Text_Editor* T = ((Fl_Syntax_Text_Editor*)w->user_data());
UI* ui = ((UI*)T->user_data());
switch(static_cast<int>(reinterpret_cast<long>(v)))
{
  case 1: //COPY
    ui->copy_cb();
    break;
  case 2:  //CUT
    ui->cut_cb();
    break;
  case 3:  //FIND
    ui->find_cb();
    break;
  case 4: //PASTE
    ui->paste_cb();
    break;
  case 5: //UNDO
    ui->undo_cb();
    break;
}} {}
  }
  Function {input(std::string MSG, std::string text="", std::string ok="OK", std::string cancel="Cancel")} {return_type {std::string}
  } {
    code {Fl_Double_Window* w = new Fl_Double_Window(285, 75);
Fl_Input* o1 = new Fl_Input(125, 5, 150, 30);
o1->box(FL_FLAT_BOX);
o1->selection_color((Fl_Color)80);
o1->copy_label(MSG.c_str());
o1->value(text.c_str());
o1->callback(ask_cb,1);
o1->when(FL_WHEN_ENTER_KEY);
Fl_Button* o2 = new Fl_Button(200, 40, 75, 30);
o2->box(FL_FLAT_BOX);
o2->color((Fl_Color)62);
o2->labelcolor(FL_BACKGROUND2_COLOR);
o2->callback(ask_cb,1);
o2->copy_label(ok.c_str());
Fl_Button* o = new Fl_Button(115, 40, 75, 30);
o->box(FL_FLAT_BOX);
o->color((Fl_Color)80);
o->labelcolor(FL_BACKGROUND2_COLOR);
o->copy_label(cancel.c_str());
o->callback(ask_cb,0);
w->end();
w->show();
while (w->shown()) Fl::wait();
const char* v = o1->value();
if(v == NULL)
  return "";
std::string V=v;
if(ret_val)
  return V;
return "";} {}
  }
  Function {insert_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_insert(0,textor);} {}
  }
  Function {load_file(std::string newfile, int ipos,bool NEW=true)} {open
  } {
    code {//trace("Loading file:"+newfile);
//todo 
//if(pick_tab(newfile)){return;}
if(NEW)
{
  add_tab(false);
  //trace("added tab");
}
Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  std::cerr<<"Null editor"<<std::endl;
  return;
}
E->loading = 1;
int insert = (ipos != -1);
E->changed = insert;
//E->textbuffer->call_modify_callbacks();
if (!insert)
  E->filename="";
int r = 0;
if (!insert)
{
  r = E->textbuffer->loadfile(newfile.c_str());
  E->init_inotify(newfile.c_str());
}
else
{
  r = E->textbuffer->insertfile(newfile.c_str(), ipos);
}
E->refresh();
E->textbuffer->call_modify_callbacks();

if (r)
  fl_alert("Error reading from file \\'%s\\':\\n%s.", newfile.c_str(), strerror(errno));
else
  E->filename=newfile;
E->set_syntax();
E->loading = 0;
set_title(tabs->value());
std::string tmp = "Documents/"+E->filename;
menu->add(tmp.c_str(),0,choose_doc,this,0);
menu->redraw();} {}
  }
  Function {make_icon(Fl_Window *o)} {} {
    code {Fl_Pixmap f(flpad_xpm);
const Fl_Pixmap * flpad_xpm_icon = &f;
const Fl_RGB_Image *img = new Fl_RGB_Image(flpad_xpm_icon,FL_GRAY);
o->icon(img);} {}
  }
  Function {none_theme()} {} {
    code {FOREGROUND_TEXT=FL_FOREGROUND_COLOR;
BACKGROUND_TEXT=FL_BACKGROUND2_COLOR;
SELECTION_TEXT=80;
FONT_TEXT=FL_COURIER;
SIZE_TEXT=14;
LINE_NUMBERS=0;
HIGHLIGHT_PLAIN=0;
//syntax
COMMENT_TEXT=FL_FOREGROUND_COLOR;
STRING_TEXT=FL_FOREGROUND_COLOR;
DIRECTIVE_TEXT=FL_FOREGROUND_COLOR;
NUMBER_TEXT=FL_FOREGROUND_COLOR;
KEYWORD_TEXT=FL_FOREGROUND_COLOR;
TYPE_TEXT=FL_FOREGROUND_COLOR;
BUTTON_COLOR=1;} {}
  }
  Function {make_theme_menu()} {} {
    code {std::vector<std::string> V = get_themes();
for( std::vector<std::string>::iterator itr = V.begin();
                                        itr!=V.end();
                                      ++itr)
{
  std::string tmp = *itr;
  theme_button->add(tmp.c_str(),0,theme_menu_cb,this,0);
}
theme_button->redraw();} {}
  }
  Function {new_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if( (!check_save()) && (textor!=NULL) )
  return;
if (textor==NULL)
{
  add_tab();
  return;
}
if(textor->filename.compare("Untitled")!=0)
{
  add_tab(true,false);
  return;
}
textor->filename="";
Fl_Text_Buffer * buff = textor->buffer();
buff->select(0, buff->length());
buff->remove_selection();
textor->changed = 0;
buff->call_modify_callbacks();
if (!check_save())
  return;
textor->filename="";
buff->select(0, buff->length());
buff->remove_selection();
textor->changed = 0;
buff->call_modify_callbacks();} {}
  }
  Function {open_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
{
  trace("No current editor");
  open_file();
  return;
}
std::string f = E->filename;

if(f.compare("")==0)
  open_file(false);
else
  open_file();} {}
  }
  Function {open_file(bool NEW=true)} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
//std::string newf="";
std::string init="";
if(E!=NULL)
{
  init= E->filename;
}
char *newfile = fl_file_chooser("Open File?", "*",init.c_str());
if(newfile!=NULL)
{
  load_file(newfile, -1,NEW);
}} {}
  }
  Function {paste_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_paste(0,textor);} {}
  }
  Function {pick_tab(std::string file)} {return_type bool
  } {
    code {if(file.compare("")==0)
  return false;
if(tabs==NULL)
  return false;  
Fl_Group * curr = tabs->as_group();
if(curr==NULL)
  return false;
Fl_Syntax_Text_Editor * E=NULL;
for ( int i = 0;i<=curr->children();i++)
{
  if(curr->child(i)!=NULL)
  {
    E = (Fl_Syntax_Text_Editor *) curr->child(i)->as_group()->child(0);
    if(E->filename.compare(file)==0)
    {
      tabs->value(curr->child(i));
      win->redraw();
      return true;
    }
    const char* lbl = E->tooltip();
    if(lbl!=NULL)
    {
      if(file.compare(lbl)==0)
      {
        tabs->value(curr->child(i));
        return true;
      }
    }
  }
}
return false;} {}
  }
  Function {prefline(std::string LINE,unsigned int COLOR)} {return_type {std::string}
  } {
    code {std::string out=LINE+":";
std::string number;
std::stringstream OUT;
OUT << COLOR;
number = OUT.str();
out+=number;
out+="\\n";
return out;} {}
  }
  Function {print_cb()} {} {
    code {Fl_Printer *printer = new Fl_Printer();
if (printer->start_job(1) == 0)
{
  printer->start_page();
  //TODO
  printer->end_page();
  printer->end_job();
}
delete printer;} {}
  }
  Function {quit_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E!=NULL)
{
  if (E->changed && !check_save())
    return;
}
exit(0);} {}
  }
  Function {replace_cb()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E!=NULL)
  make_replace()->show();} {}
  }
  Function {replace2_cb()} {open
  } {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
  return;
const char *find = replace_find->value();

const char *replace = replace_with->value();
if (find == NULL)
{
trace("NULL");
// Search string is blank; get a new one...
  replace_dlg->show();
  return;
}
replace_dlg->hide();
int pos = E->insert_position();
Fl_Text_Buffer * buff = E->buffer();
int found = buff->search_forward(pos, find, &pos);
if (found)
{
// Found a match; update the position and replace text...
  buff->select(pos, pos+strlen(find));
  buff->remove_selection();
  buff->insert(pos, replace);
  buff->select(pos, pos+strlen(replace));
  E->insert_position(pos+strlen(replace));
  E->show_insert_position();
}
else
  fl_alert("No occurrences of \\'%s\\' found!", find);} {}
  }
  Function {replall_cb()} {open
  } {
    code {Fl_Syntax_Text_Editor * E = current_editor();
if(E==NULL)
  return;
const char *find = replace_find->value();
const char *replace = replace_with->value();
find = replace_find->value();
if (find == NULL)
{
trace("NULL");
// Search string is blank; get a new one...
  replace_dlg->show();
  return;
}

replace_dlg->hide();
E->insert_position(0);

int times = 0;
Fl_Text_Buffer * buff = E->buffer();
const char* text = buff->text();
std::string T = text;

//This function is WAY faster
std::string res = replace_all_strings(T, find, replace, times);

buff->text(res.c_str());
E->modify_cb();

if (times)
  fl_message("Replaced %d occurrences.", times);
else
  fl_alert("No occurrences of \\'%s\\' found!", find);} {}
  }
  Function {replace_start()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string SRCH = "";
if(E!=NULL)
 SRCH = E->search;
char * tmp = E->textbuffer->selection_text();
if(tmp!=NULL)
{
  std::string t = tmp;
  if(t.compare("")!=0)
  {
    SRCH=tmp;
    E->search=SRCH;
  }
}

replace_find->value(SRCH.c_str());} {}
  }
  Function {resize(Fl_Widget* o)} {} {
    code {if(o==NULL)
  return;
int width = win->w();
int height = win->h() - (buttons->h() +buttons->x());
o->size(width,height);
o->redraw();} {}
  }
  Function {refresh_all()} {} {
    code {change_theme(FOREGROUND_TEXT,BACKGROUND_TEXT,SELECTION_TEXT,FONT_TEXT,SIZE_TEXT,LINE_NUMBERS);} {}
  }
  Function {save_cb(void)} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string fname="";
if(E==NULL)
{
  return;
}
fname=E->filename;
if (fname.compare("")==0)
{
// No filename - get one!
  saveas_cb();
  return;
}
else
  save_file(fname);} {}
  }
  Function {saveas_cb(void)} {} {
    code {char *newfile;
Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
newfile = fl_file_chooser("Save File As?", "*", textor->filename.c_str());
if (newfile != NULL)
  save_file(newfile);} {}
  }
  Function {save_preferences()} {open return_type bool
  } {
    code {std::string out=prefline("FG",FOREGROUND_TEXT);
out+=prefline("BG",BACKGROUND_TEXT);
out+=prefline("SC",SELECTION_TEXT);
out+=prefline("FT",FONT_TEXT);
out+=prefline("SZ",SIZE_TEXT);
out+=prefline("LN",LINE_NUMBERS);
out+=prefline("CM",COMMENT_TEXT);
out+=prefline("ST",STRING_TEXT);
out+=prefline("DE",DIRECTIVE_TEXT);
out+=prefline("NM",NUMBER_TEXT);
out+=prefline("KY",KEYWORD_TEXT);
out+=prefline("TT",TYPE_TEXT);
out+=prefline("BC",BUTTON_COLOR);
out+=prefline("PT",HIGHLIGHT_PLAIN);
out+=prefline("SY",SYMBOLS_TEXT);
out+=prefline("SP",SPECIAL_TEXT);
out+=prefline("BR",BROKEN_TEXT);
out+=prefline("IL",INDENT_NEW_LINES);
out+=prefline("MC",MATCH_CASE);
out+=prefline("BW",BACKWARD_SEARCH);
std::ofstream dest;
std::string fname=get_filename();
dest.open(fname.c_str());
if(!dest.is_open()){
  fl_alert("Error writing to file \\'%s\\':\\n%s.", fname.c_str(), strerror(errno));
  return false;
}
dest << out;
dest.close();
return true;} {}
  }
  Function {save_file(std::string newfile)} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Buffer * buff = textor->buffer();
if (buff->savefile(newfile.c_str()))
  fl_alert("Error writing to file \\'%s\\':\\n%s.", newfile.c_str(), strerror(errno));
else
{
  textor->filename=newfile;
  textor->changed = 0;
  buff->call_modify_callbacks();
  set_title(textor->parent());
  ((Fl_Widget *)(textor->user_data()))->labelcolor(NORMAL_COLOR);
}} {}
  }
  Function {set_title(Fl_Widget* g)} {} {
    code {if(g==NULL)
  return;
Fl_Group* gg = (Fl_Group*)g;
std::string title;

Fl_Syntax_Text_Editor* textor = ((Fl_Syntax_Text_Editor*)gg->child(0));//current_editor();
if(textor==NULL)
  return;
std::string fname = textor->filename;
std::string full = fname;

//Is the file name empty???  set it to Untitled!!
if (fname.compare("")==0)
{
  title="Untitled";
}
else
{
// get JUST the filename (remove the path... similare to fl_filename_name()
  unsigned int slash = fname.rfind('/');
  \#ifdef WIN32
  if (slash>fname.length())
    slash =fname.rfind('\\\\');
  \#endif
  if (slash <fname.length())
  {
    //FILENAME ONLY
    title=fname.substr(slash+1,std::string::npos);
    //PATH to file ONLY
    full = fname.substr(0,slash);
  }
  else
    title=fname;
    
}
textor->refresh();
//Has this been changed at all??
if (textor->changed)
{
  title+=" (modified)";
}
std::string Ti = title;

if(full.compare("")!=0)
{
  // is there a path???  add it!!
  Ti = Ti + "(" + full + ")";
}
//trace("Title="+title);
win->copy_label(Ti.c_str());
g->copy_label(title.c_str());
g->copy_tooltip(fname.c_str());
g->redraw();
tabs->redraw();} {}
  }
  Function {show_line_numbers(int width=0)} {} {
    code {for(int i = 0;i< tabs->children();i++)
{
std::cout<<i<<std::endl;
  Fl_Group* tab = tabs->child(i)->as_group();
  Fl_Syntax_Text_Editor * e = (Fl_Syntax_Text_Editor *)tab->child(0);
  e->linenumber_width(width);
}} {}
  }
  Function {theme_menu_cb(Fl_Widget* o, void* v)} {return_type {static void}
  } {
    code {Fl_Menu_Button *m = (Fl_Menu_Button*)o;
const Fl_Menu_Item *p = m->mvalue();
const char* txt=p->label();
if(txt==NULL)
  return;
((UI*)(p->user_data()))->get_theme_from_config(txt);} {}
  }
  Function {undo_cb()} {} {
    code {Fl_Syntax_Text_Editor * textor = current_editor();
if(textor==NULL)
  return;
Fl_Text_Editor::kf_undo(0,textor);} {}
  }
  Function {wordwrap()} {} {
    code {Fl_Syntax_Text_Editor * E = current_editor();
std::string fname="";
if(E==NULL)
{
  return;
}
if(E->WRAPPED)
{
  E->WRAPPED=false;
  E->wrap_mode(Fl_Text_Display::WRAP_NONE, 0);
}
else
{
  E->WRAPPED=true;
  E->wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
}} {}
  }
  Function {replace_all_strings(std::string str, const std::string& old, const std::string& new_s, int &counter)} {open return_type {std::string}
  } {
    code {if(!old.empty())
{
  size_t pos = str.find(old);
  while ((pos = str.find(old, pos)) != std::string::npos)
  {
    counter++;
    str=str.replace(pos, old.length(), new_s);
    pos += new_s.length();
  }
}
return str;} {}
  }
  Function {find_selection()} {open return_type {std::string}
  } {
    code {std::string val;
Fl_Syntax_Text_Editor * E = current_editor();

if(E==NULL)
{
  return "";
}

std::string SRCH = E->search;
char *       tmp = E->textbuffer->selection_text();

if(tmp!=NULL)
{
  std::string t = tmp;

  if(t.compare("")!=0)
  {
    SRCH      = tmp;
    E->search = SRCH;
  }
}

return SRCH;} {}
  }
}

Function {comma_line(std::string lang,std::string field, bool ignore_case = false)} {return_type {std::vector<std::string>}
} {
  code {//get the line from the file
std::string LINE=get(lang,field);
if(ignore_case)
{
  std::string lower  = LINE;
  std::string upper = LINE;
  std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
  std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
  LINE=lower+","+upper;
}
//return a vector from the string delimited by commas
return make_vec(LINE,",");} {}
}

Function {convert(std::string num, int default_value=0)} {return_type {unsigned int}
} {
  code {unsigned int NUM = default_value;
if(num.find("\#")==0)
{
  return get_fl_color(num,default_value);
}
try{NUM=std::stoul(num);}
catch(const std::invalid_argument e){return default_value;}
catch(const std::out_of_range e){return default_value;}
return NUM;} {}
}

Function {dir_vector(std::string DIRECTORY)} {return_type {std::vector<std::string>}
} {
  code {//trace("dir_vector:"+DIRECTORY);
std::vector<std::string> myVector;
if(!fl_filename_isdir(DIRECTORY.c_str()))
  return myVector;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(DIRECTORY.c_str());
if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      //trace(fullpath);
      myVector.push_back(fullpath);
    }
  }
}
std::vector<std::string>::iterator it;
std::sort (myVector.begin(), myVector.end());
it = std::unique (myVector.begin(), myVector.end());
myVector.resize( std::distance(myVector.begin(),it) );
return myVector;} {}
}

Function {get(std::string header, std::string line)} {return_type {std::string}
} {
  code {if(line.compare("")==0){return "";}
if(header.compare("")==0){return "";}
std::string filename = get_syntax_file();
if(filename.compare("")==0){return "";}
if(!test_file(filename))
{
  trace("No file sent in\\n"+filename+","+line);
  return "";
}
std::string find_header=header;
unsigned int open=header.find("[");
unsigned int close=header.find("]");
unsigned int header_length=header.length();
if(open>header_length){find_header="["+find_header;}
if(close>header_length){find_header=find_header+"]";}

bool found_after_this=false;
std::string this_line="";
int lengthofARGS = line.length();
std::string subString;
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  while (getline(inputFileStrem,this_line))
  {
    subString=this_line.substr(0,lengthofARGS);
    if(this_line.find("[")<=1)
    {
      found_after_this=false;
    }
    if(this_line.find(find_header)<this_line.length())
    {
      found_after_this=true;
    }
    /** if found return it immediately */
    if(found_after_this)
    {
      if(this_line.find(line)==0)
      {
        unsigned int eq = this_line.find("=");
        if(eq<this_line.length())
        {
          this_line=this_line.substr(eq+1,std::string::npos);
        }
        return this_line;
      }
    }
  }
}
return "";} {}
}

Function {get_flpad_dir( std::string base_name)} {return_type {std::string}
} {
  code {std::string tester = "/usr/share/flpad/";
std::string res="";
if(test_file(tester+base_name))
{
  res=tester+base_name;
}
else
{
  tester = "/usr/local/share/flpad/";
  if(test_file(tester+base_name))
    res=tester+base_name;
}
return res;} {}
}

Function {get_flpad_home_dir( std::string base_name)} {return_type {std::string}
} {
  code {//testing
std::string home_tester;
const char* home_config = getenv("XDG_CONFIG_HOME");
if(home_config == NULL)
{
  home_config = getenv("HOME");
  if(home_config != NULL)
  {
    home_tester=home_config;
    home_tester =home_tester + "/.config/flpad/" + base_name;
  }
}
else
{
  home_tester = home_config;
  home_tester = home_tester + "/flpad/" + base_name;
}

if(test_file(home_tester))
{
  return home_tester;
}
return "";} {}
}

Function {get_syntax_file()} {return_type {std::string}
} {
  code {std::string base_name = "styles.flpad";
if(SYNTAX_FILE.compare("")!=0)
  return SYNTAX_FILE;
//testing
std::string home_tester=get_flpad_home_dir(base_name);
if(home_tester.compare("")!=0)
{
  SYNTAX_FILE=home_tester;
}
else
{
  std::string tester = get_flpad_dir(base_name);
  if(tester.compare("")!=0)
  {
    SYNTAX_FILE=tester;
  }
}
if(SYNTAX_FILE.compare("")==0)
  trace("No syntax file found...");
return SYNTAX_FILE;} {}
}

Function {get_syntax_headers()} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> V;
std::string filename = get_syntax_file();
if(filename.compare("")==0){return V;}


//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string h="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       h=this_line.substr(open_bracket+1,close_bracket-1);
       V.push_back(h);
    }
  }
}
return V;} {}
}

Function {get_theme_file()} {return_type {std::string}
} {
  code {std::string base_name = "themes.flpad";
std::string tmp;
std::string home_tester=get_flpad_home_dir(base_name);
if(home_tester.compare("")!=0)
{
  tmp=home_tester;
}
else
{
  std::string tester = get_flpad_dir(base_name);
  if(tester.compare("")!=0)
  {
    tmp=tester;
  }
}
return tmp;} {}
}

Function {get_type(std::string fname)} {open return_type {std::string}
} {
  code {SYNTAX_HEADERS=get_syntax_headers();
if(!test_file(fname))
{
  trace("No file sent in\\n"+fname);
  return "";
}

std::string ext;

unsigned int dot = fname.rfind(".");
if(dot<fname.length())
{
  std::string tmp=fname;
  tmp=tmp.substr(dot,std::string::npos);
  ext=tmp;
}
std::string tmp = syntax_type_from_filename(fname);
if (tmp.compare("")!=0)
  return tmp;
/// get the shebang
std::string thisLine;
std::ifstream inputFileStream(fname.c_str(), std::ifstream::in);
if(inputFileStream.is_open())
{
  getline(inputFileStream,thisLine);
}

// shell scripts don't always constain an extention... but the shebang tells
if(thisLine.find("\#!")==0)
{
  std::string tmp=thisLine;
  unsigned int find = tmp.rfind("/");
  if(find<tmp.length())
  {
    tmp=tmp.substr(find+1,std::string::npos);
    tmp="."+tmp;
    ext=tmp;
  }
}
if( (thisLine.find("<?xml")<thisLine.length()))
{
  for( std::vector<std::string>::iterator itr = SYNTAX_HEADERS.begin();
                                              itr!=SYNTAX_HEADERS.end();
                                              ++itr)
  {
    std::string tmp=*itr;
    std::string c="."+tmp;
    if(c.compare(ext)==0)
    {
      return tmp;
      
    }
  }
  ext="xml";
}
if(thisLine.find("<!DOCTYPE html>")<thisLine.length())
{
  ext="html";
}
//nothing?  lets leave then...
if(ext.compare("")==0)
  return "";

std::string EXT=ext;
std::transform(EXT.begin(), EXT.end(), EXT.begin(), ::tolower);
unsigned int f_dot = EXT.find(".");
if(f_dot<EXT.length())
  EXT=EXT.substr(f_dot+1,std::string::npos);

//get the syntax highlighter file
std::string filename = get_syntax_file();
if(filename.compare("")==0){return "";}

//this is the line we are looking for
std::string line="ext=";

//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
    }
    unsigned int eq = this_line.find("=");
    if(this_line.find("filename=")<this_line.length())
    {
      std::string temp_fname = fname;
      std::transform(temp_fname.begin(), temp_fname.end(), temp_fname.begin(), ::tolower);
      this_line=this_line.substr(eq+1,std::string::npos);
      std::vector<std::string> V = make_vec(this_line,",");
      for( std::vector<std::string>::iterator itr = V.begin();
                                              itr!=V.end();
                                              ++itr)
      {
        std::string tmp=*itr;
        std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
        if(tmp.compare(fname)==0)
          return HEADER;
      }
    }

    if(this_line.find(line)<this_line.length())
    {
      this_line=this_line.substr(eq+1,std::string::npos);
      std::vector<std::string> V = make_vec(this_line,",");
      for( std::vector<std::string>::iterator itr = V.begin();
                                              itr!=V.end();
                                              ++itr)
      {
        std::string tmp=*itr;
        std::transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
        if(tmp.compare(EXT)==0)
          return HEADER;
      }
    }
  }
}

if(EXT.compare("bash")==0)
  return "sh";
return "";} {}
}

Function {get_themes()} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> THEMES;
std::string filename = get_theme_file();
if(filename.compare("")==0){return THEMES;}


//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
       THEMES.push_back(HEADER);
    }
  }
}
return THEMES;} {}
}

Function {get_theme(std::string theme, std::string item, int default_value=0)} {open return_type int
} {
  code {std::string filename = get_theme_file();
if(filename.compare("")==0){return default_value;}

//this is the line we are looking for
std::string line=item;

//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
bool ready=false;
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
       if(theme.compare(HEADER)==0)
         ready=true;
    }
    if(ready)
    {
      unsigned int eq = this_line.find("=");
      if(this_line.find(line)<eq)
      {
        this_line=this_line.substr(eq+1,std::string::npos);
        return convert(this_line,default_value);
      }
    }
  }
}
return 0;} {}
}

Function {is_space(const char x)} {return_type bool
} {
  code {return std::isspace(x);} {}
}

Function {join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB)} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> bothVectors;
bothVectors.reserve(vectorA.size()+vectorB.size());
bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
return bothVectors;} {}
}

Function {keywords(std::string header, bool ignore_case = false)} {return_type {std::vector <std::string>}
} {
  code {return comma_line(header, "keywords", ignore_case);} {}
}

Function {main(int argc, char **argv)} {return_type int
} {
  code {//Set some default colors
NORMAL_COLOR = FL_BLACK;
EDIT_COLOR   = FL_RED;
UI  *ui      = new UI();
bool new_tab = false;
try
{
  ui->get_preferences();
  Fl::set_fonts();
  ui->make_window()->show();
  ui->win->wait_for_expose();
  if (argc > 1)
  {
    for (int i=1; i<argc; i++)
    {
      char* charchar1 = argv[i];
      if(charchar1 != NULL)
      {
        std::string fname = charchar1;
        ui->dnd_file(fname.c_str(),new_tab);
        new_tab=true;
      }
    }
  }
  ui->about_window()->show();
  ui->about_win->hide();
  return Fl::run();
}
catch (const std::exception& e)
{
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...)
{
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}} {}
}

Function {make_vec(std::string string_to_become_vector,std::string delimiter=" ")} {return_type {std::vector<std::string>}
} {
  code {std::vector<std::string> Vector;
std::string original,preComma,postComma;
original=string_to_become_vector;
unsigned int found,finder;
finder=original.length();
if(original.find(delimiter)>original.length())
{
  Vector.push_back(original);
  return Vector;
}
for(found=original.find(delimiter);found<finder;found=original.find(delimiter))
{
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0)
  {
    preComma.erase( std::remove_if( preComma.begin(), preComma.end(), is_space)
                    ,preComma.end());
    //trace(preComma);
    Vector.push_back(preComma);
  }
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
}

Function {syntax_type_from_filename(std::string fname)} {return_type {std::string}
} {
  code {unsigned int dot = fname.rfind("/");
if(dot<fname.length())
{
  fname=fname.substr(dot+1,std::string::npos);
}
std::string filename = get_syntax_file();
//parse the syntax highlighter file
std::ifstream inputFileStrem (filename.c_str(), std::ifstream::in);
/** check if the input file stream is open */
if(inputFileStrem.is_open())
{
  std::string this_line;
  std::string HEADER="";
  while (getline(inputFileStrem,this_line))
  {
    
    if(this_line.find("[")<=1)
    {
       unsigned int open_bracket=this_line.find("[");
       unsigned int close_bracket=this_line.find("]");
       HEADER=this_line.substr(open_bracket+1,close_bracket-1);
    }
    unsigned int eq = this_line.find("=");
    if(this_line.find("filename=")==0)
    {
      this_line=this_line.substr(eq+1,std::string::npos);
      std::vector<std::string> V = make_vec(this_line,",");
      for( std::vector<std::string>::iterator itr = V.begin();
                                              itr!=V.end();
                                              ++itr)
      {
        std::string tmp=*itr;
        if(tmp.compare(fname)==0)
          return HEADER;
      }
    }
  }
}
return "";} {}
}

Function {trace(std::string MSG, int n = 0)} {} {
  code {//return;
std::cout<<MSG;
if(n!=0)
  std::cout<<"-->"<<n;
std::cout<<std::endl;} {}
}

Function {test_file(std::string file)} {return_type bool
} {
  code {//if empty it doesn't exist
if(file.compare("")==0)
  return false;


std::string dir=file;
unsigned int find = dir.rfind("/");

//if there is no directory this isn't correct
if(find>dir.length())
{
  // try the PWD if we can
  const char* PWD= getenv("PWD");
  if(PWD==NULL)
    return false;
  dir=PWD;
  dir+="/";
  file=dir+file;
}
else
{
  // get the directory
  dir=dir.substr(0,find);
}

//open the directory
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());

//make sure there is a slash at the end
if(dir.rfind('/')!=dir.length()-1){dir+="/";}

if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      //get a pointer to the file in this directory
      std::string fullpath=entryPointer->d_name;
      fullpath=dir+fullpath;
      //is it the same as what we sent in?
      if(fullpath.compare(file)==0)
      {
        //close the directory
        closedir(mydir);
        return true;
      }
    }
  }
  //close the directory... apparently this didn't work :(
  closedir(mydir);
}
return false;} {}
}

Function {types(std::string header, bool ignore_case = false)} {return_type {std::vector <std::string>}
} {
  code {std::vector<std::string> V = comma_line(header, "types", ignore_case);
if(V.empty())
  return V;
std::string a = V[0];
std::vector<std::string> DIR_LIST;
if(a[0] == '/')
{
  if(fl_filename_isdir(a.c_str())!=0)
  {
    for( std::vector<std::string>::iterator it = V.begin();
    it!=V.end();
    ++it)
    {
      std::string tmp=*it;
      std::vector <std::string> T = dir_vector(tmp);
      DIR_LIST=join_string_vectors(DIR_LIST,T);
    }
  }
  V=DIR_LIST;
}
return V;} {}
}

Function {ask(std::string MSG, std::string yes="Yes", std::string no="No", std::string other="")} {open return_type int
} {
  code {int w = 450;
int h = 90;
Fl_Double_Window* ask_win = new Fl_Double_Window(w, h);
Fl_Box* o = new Fl_Box(5, 5, 5, 5);
o->copy_label(MSG.c_str());
o->redraw();
Fl_Button* o1 = new Fl_Button(170, 55, 65, 30, yes.c_str());
o1->box(FL_FLAT_BOX);
o1->color((Fl_Color)62);
o1->labelcolor(FL_BACKGROUND2_COLOR);
o1->callback(ask_cb,1);
Fl_Button* o2 = new Fl_Button(100, 55, 65, 30, no.c_str());
o2->box(FL_FLAT_BOX);
o2->color((Fl_Color)80);
o2->labelcolor(FL_BACKGROUND2_COLOR);
o2->callback(ask_cb,0);
if(other.compare("")!=0)
{
  Fl_Button* o3 = new Fl_Button(30, 55, 65, 30, other.c_str());
  o3->box(FL_FLAT_BOX);
  o3->color((Fl_Color)94);
  o3->labelcolor(FL_BACKGROUND2_COLOR);
  o3->callback(ask_cb,2);
}
else
{
  o1->position(5,o1->y());
  o2->position(10+o1->w(),o1->y());
  
}
ask_win->end();
ask_win->show();
o->measure_label(w,h);
o->size(w+10,h);
if(other.compare("")!=0)
{
  if(w<ask_win->w())
     w=ask_win->w()+10;
  else
    w+=10;
  if(h<ask_win->h())
    h=ask_win->h();
  else
    h +=10;
}
else
{
  int W = o2->x()+o2->w()+5;
  if(w<W)
     w=W;
  else if (w < W +10)
    w=W+10;
  else
    w+=10;
  if(h<ask_win->h())
    h=ask_win->h();
  else
    h +=10;
}
ask_win->size(w,h);
while (ask_win->shown()) Fl::wait();
return ret_val;} {}
}

Function {ask_cb(Fl_Widget *o, long val)} {open return_type {static void}
} {
  code {ret_val = (int) val;
o->parent()->hide();} {}
}

Function {get_fl_color(std::string color, unsigned int default_value=0)} {return_type {unsigned int}
} {
  code {if(color.compare("")==0){return default_value;}
std::string::size_type validator = color.find('\#');

if(validator==0)
{
  std::string c1 = color.substr (1,6);
  c1="0x"+c1+"00";

  try
  {
    unsigned int flColor = strtoul(c1.c_str(),0,16);
    return flColor;
  }
  catch(const std::invalid_argument e){return default_value;}
  catch(const std::out_of_range e){return default_value;}
}
std::string value = color_from_name(color.c_str());
return get_fl_color(value, default_value);} {}
}

Function {color_to_string(const double *rgb)} {return_type {std::string}
} {
  code {char tmp[8];
std::snprintf(tmp, sizeof(tmp), "\#%02x%02x%02x", int(rgb[0]), int(rgb[1]), int(rgb[2]));
return tmp;} {}
}

Function {color_from_name(const char* colorName)} {
  comment {Paul Sladen, 2014-08-13, Public Domain
XLookupColor() -> RGB colour value example, per request on
http://irclogs.ubuntu.com/2014/08/13/%23ubuntu-devel.html\#t19:52
grep MistyRose /usr/share/X11/rgb.txt | awk '{printf("%02x%02x%02x\\n",$1,$2,$3);}'
http://manpages.ubuntu.com/manpages/man3/XQueryColor.3.html
gcc xlookupcolour.c -o xlookupcolour -lX11 && ./xlookupcolour red yellow blue
modified for use in this program by Israel <israeldahl@gmail.com>
Thanks Sladen for the quick help!!!!} return_type {std::string}
} {
  code {Display *dpy = XOpenDisplay(NULL);
int scr = XDefaultScreen(dpy);
Colormap map = DefaultColormap(dpy, scr);
XColor rgb, nearest_rgb;
XLookupColor(dpy, map, colorName, &rgb, &nearest_rgb);
int red = (int)rgb.red>>8;
int green = (int)rgb.green>>8;
int blue = (int)rgb.blue>>8;
char tmp[8];
std::snprintf(tmp, sizeof(tmp), "\#%02x%02x%02x", red, green, blue);
std::string output = tmp;
return output;} {}
}
