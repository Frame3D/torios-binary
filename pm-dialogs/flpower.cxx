// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <libintl.h>
#include "flpower.h"
#define NANOSVG_ALL_COLOR_KEYWORDS
#define NANOSVG_IMPLEMENTATION
#include "../include/nanosvg.h"
#define NANOSVGRAST_IMPLEMENTATION
#include "../include/nanosvgrast.h"

void UI::cb_Cancel_i(Fl_Button*, void*) {
  win->hide();
}
void UI::cb_Cancel(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void UI::cb_OK_i(Fl_Button*, void*) {
  decide();
}
void UI::cb_OK(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

UI::UI() {
  SHUTDOWN_TEXT  = gettext("Shutdown");
  REBOOT_TEXT    = gettext("Reboot");
  SUSPEND_TEXT   = gettext("Suspend");
  HIBERNATE_TEXT = gettext("Hibernate");
  LOGOUT_TEXT    = gettext("Log Out");
  //  = gettext("")
}

Fl_Double_Window* UI::make_window() {
  { win = new Fl_Double_Window(183, 110, gettext("Power"));
    win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(10, 70, 65, 30, gettext("Cancel"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Cancel);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(95, 70, 65, 30, gettext("OK"));
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)62);
      o->selection_color(FL_DARK_GREEN);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Button* o
    { icon = new Fl_Box(15, 7, 48, 48);
    } // Fl_Box* icon
    { Fl_Box* o = label = new Fl_Box(65, 15, 115, 35, gettext("Shutdown"));
      o->label(win->label());
    } // Fl_Box* label
    win->end();
    win->resizable(win);
  } // Fl_Double_Window* win
  return win;
}

void UI::decide() {
  switch(type)
  {
    case 0:
      shutdown();
      break;
    case 1:
      suspend();
      break;
    case 2:
      hibernate();
      break;
    case 3:
      leave();
      break;
    case 4:
      restart();
      break;
    default:
      exit(0);
  }
}

std::string UI::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string UI::get_shell_for_C() {
  std::string shell=term_out("which bash");
  if(shell.compare("")==0){
    if(!test_exec(shell)){
    shell=term_out("which sh");
    if(!test_exec(shell)){return "";}
    //TODO make this work for others
    }
  }
  shell=shell+" -c '";
  return shell;
}

int UI::hibernate() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" hibernate";
    return run(test);
  }
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Hibernate";
    return run(test);
  }
  return -1;
}

unsigned int UI::items_in_path() {
  const char* path =getenv("PATH");
  std::string::size_type pathPosition =0;
  if(path==NULL){return 1;}
  std::string stringPATH = path;
  unsigned int howmany;
  for(howmany=1;(pathPosition!=std::string::npos);howmany++)
  {
    pathPosition=stringPATH.find(':', pathPosition+1);
  }
  return howmany;
}

int UI::leave() {
  std::string LOGOUT = "loginctl terminate-session $XDG_SESSION_ID";
  /*if(test_file("/etc/default/nodm"))
  {
    std::string tmp=file_to_string("/etc/default/nodm");
    unsigned int finder=tmp.find("NODM_ENABLED=true");
    if(finder<tmp.length())
    {
      LOGOUT="jwm -reload";
    }
  }*/
  return run(LOGOUT);
}

int UI::run(std::string program) {
  std::string shell=get_shell_for_C();
  if(shell.compare("")!=0)
  {
    shell+=program;
    shell+="'";
  }
  else{shell=program;}
  trace("run_program::"+shell);
  return system(shell.c_str());
}

void UI::setup(int TYPE,bool YES) {
  type=TYPE;
  if(YES)
  {
    decide();
    exit(0);
  }
  make_window()->show();
  std::string TITLE=SHUTDOWN_TEXT;
  switch(TYPE)
  {
    case 0:
      icon->image(shutdown_icon);
      break;
    case 1:
      TITLE=SUSPEND_TEXT;
      icon->image(suspend_icon);
      break;
    case 2:
      TITLE=HIBERNATE_TEXT;
      icon->image(hibernate_icon);
      break;
    case 3:
      TITLE=LOGOUT_TEXT;
      icon->image(logout_icon);
      break;
    case 4:
      TITLE=REBOOT_TEXT;
      icon->image(restart_icon);
      break;
    default:
      break;
  }
  win->copy_label(TITLE.c_str());
  label->copy_label(TITLE.c_str());
}

int UI::shutdown() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" poweroff";
    return run(test);
  }
  
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop";
    return run(test);
  }
  return -1;
}

int UI::restart() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" reboot";
    return run(test);
  }
  
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Restart";
    return run(test);
  }
  return -1;
}

int UI::suspend() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" suspend";
    return run(test);
  }
  
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend";
    return run(test);
  }
  return -1;
}

bool UI::test_dir(std::string dirToTest) {
  if(dirToTest.compare("")==0){return false;}
  DIR *dir = NULL;
  dir = opendir(dirToTest.c_str());
  if (dir!=NULL)
  {
    closedir(dir);
    return true;
  }
  return false;
}

bool UI::test_exec(std::string execToTest) {
  if(execToTest.compare("")==0){return false;}
  /** the list of directories it might check*/
  /** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
  std::string stringEXEC;
  std:: string testPATH, testExec;
  bool result = false;
  unsigned int numofpaths = items_in_path();
  for (unsigned int i = 1; i <= numofpaths; i++)
  {
    stringEXEC = execToTest;
    testPATH = current_path(i);
    stringEXEC = testPATH + "/" + stringEXEC;
    if(test_file(stringEXEC.c_str())){return true;}
  }
  return result;
}

bool UI::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

std::string UI::term_out(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  std::string result="";
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
    pclose(command_p);
  }
  else{ return "";}
  if (result.compare("")==0){return "";}
  int end = result.length();
  if((end-1) == 0){return "";}
  if((end) == 0){return "";}
  return result.erase(end-1,1);
}

std::string UI::current_path(int iter) {
  const char* path =getenv("PATH");
  if(path==NULL){return "";}
  std::string stringPATH = path;
  std::string tmp = stringPATH;
  unsigned int find=0;
  unsigned int itera=0;
  std::string howmany;
  for(std::string::size_type pathPosition =0;(pathPosition!=std::string::npos);pathPosition=stringPATH.find(':', pathPosition+1))
  {
    tmp = stringPATH.substr(pathPosition+1,std::string::npos);
    find=tmp.find(':');
    if(find<tmp.length())
    {  
       howmany = tmp;
       howmany = howmany.substr(0,find);
    }
  }
  return howmany;
}

int main(int argc, char *argv[]) {
  std::string command;
  Fl::visual(FL_RGB);
  unsigned int TYPE=0;
  bool YES=false;
  UI* ui = new UI();
  try
  {
    if(argc>0)
    {
      for (int i = 1;i<argc;++i)
      {
        command=argv[i];
        for (int i=0;i<argc;i++)
        {
          if (command.compare("--shutdown")==0)
            TYPE=0;
          else if (command.compare("--suspend")==0)
            TYPE=1;
          else if (command.compare("--hibernate")==0)
            TYPE=2;
          else if (command.compare("--exit")==0)
            TYPE=3;
          else if (command.compare("--restart")==0)
            TYPE=4;
          else if ( (command.compare("--yes")==0) ||
                    (command.compare("-y")==0) ||
                    (command.compare("-f")==0) ||
                    (command.compare("--force")==0)
                  )
           YES=true;
          else
          {
            return usage(argv[0]);
          }
        }
      }
      ui->setup(TYPE,YES);
    }
    return Fl::run();
  }
  catch (const std::exception& e)
  {
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...)
  {
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
  return -1;
}

void trace(std::string msg) {
  //std::cout<<msg<<std::endl;
}

int usage(char* name) {
  std::cout<<name<<std::endl<<
  "USAGE:"<<std::endl<<
  "[--shutdown|--suspend|--hibernate|--restart|--exit|-y|--yes|-f|--force]"<<std::endl<<
  "  --shutdown shutdown computer"<<std::endl<<
  "  --suspend suspend computer"<<std::endl<<
  "  --hibernate hibernate computer"<<std::endl<<
  "  --restart restart computer"<<std::endl<<
  "  --exit exit JWM\n"<<std::endl<<
  "  --yes | -y | -f | --force Do not show dialog"<<std::endl;
}
