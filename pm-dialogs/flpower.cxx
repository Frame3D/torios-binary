// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "flpower.h"
#define NANOSVG_ALL_COLOR_KEYWORDS
#define NANOSVG_IMPLEMENTATION
#include "../include/nanosvg.h"
#define NANOSVGRAST_IMPLEMENTATION
#include "../include/nanosvgrast.h"

void UI::cb_Cancel_i(Fl_Button*, void*) {
  win->hide();
}
void UI::cb_Cancel(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void UI::cb_OK_i(Fl_Button*, void*) {
  decide();
}
void UI::cb_OK(Fl_Button* o, void* v) {
  ((UI*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

Fl_Double_Window* UI::make_window() {
  { win = new Fl_Double_Window(213, 110, "About");
    win->user_data((void*)(this));
    { Fl_Button* o = new Fl_Button(45, 70, 65, 30, "Cancel");
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)80);
      o->selection_color(FL_DARK_RED);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_Cancel);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(130, 70, 65, 30, "OK");
      o->box(FL_FLAT_BOX);
      o->color((Fl_Color)62);
      o->selection_color(FL_DARK_GREEN);
      o->labelcolor(FL_BACKGROUND2_COLOR);
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Button* o
    { icon = new Fl_Box(10, 7, 48, 48);
    } // Fl_Box* icon
    { Fl_Box* o = label = new Fl_Box(85, 15, 115, 35, "Shutdown");
      o->label(win->label());
    } // Fl_Box* label
    win->end();
    win->resizable(win);
  } // Fl_Double_Window* win
  return win;
}

void UI::changeWidgetIcon(std::string icon_file, Fl_Widget * widget,bool save) {
  if(save)
  {
    if(OLD_ICON==icon_file)
      return;
    OLD_ICON=icon_file;
  }
  int h = widget->w();
  int w = widget->h();
  if(w>h)
    h=w;
  int iconW=24;
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetIcon::Icon file is empty");
    return;
  }
  widget->align(FL_ALIGN_CENTER);
  widget->copy_label("");
  widget->image(NULL);
  widget->redraw();
  widget->label(0L);
  if(m_ICON_PATHS.empty())
    m_ICON_PATHS=IconPaths(iconW);
  std::cout<<"changeWidgetIcon:: w="<<w<<" h="<<h<<std::endl;
  if(!test_file(icon_file))
  {
    std::string tmp=icon_file;
    unsigned int ext=icon_file.rfind(".");
    if(ext>icon_file.length())
    {
      tmp=icon_file+".svg";
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")==0)
      {
        tmp=icon_file+".png";
        tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
        if(tmp.compare("")!=0)
        {
          trace("changeWidgetIcon::RESULT="+tmp);
          icon_file=tmp;
        }
      }
      else
      {
        trace("changeWidgetIcon::RESULT="+tmp);
        icon_file=tmp;
      }
    }
    else
    {
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")==0)
      {
        trace("changeWidgetIcon::looking for icon file");
        tmp=look_for_icon_file(icon_file);
        
      }
      if(tmp.compare("")!=0)
      {
        icon_file=tmp;
        trace("changeWidgetIcon::RESULT="+tmp);
      }
    }
  }
  else
  {
    trace("changeWidgetIcon::"+icon_file+" is a file!");
  }
  
  if(icon_file.compare("")==0)
  {
    trace("changeWidgetIcon::Icon file is empty");
    return;
  }
  
  Fl_Image* image2=widget->image();//new Fl_Image(w,h,4);
  
  if(has_file_extention_at_end(icon_file,".png"))
  {
    Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xpm"))
  {
    Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".xbm"))
  {
    Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".svg"))
  {
    NSVGimage *svg_image = NULL;
    NSVGrasterizer *rast = NULL;
    unsigned char* img_data = NULL;
    int width;
    int height;
    const int depth = 4;
    svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
    if (svg_image == NULL)
    {
      trace("changeWidgetIcon::Could not open SVG image:"+icon_file);
      return;
    }
    width = (int)svg_image->width;
    height = (int)svg_image->height;
    rast = nsvgCreateRasterizer();
    if (rast == NULL)
    {
      trace("changeWidgetIcon::Could not init rasterizer.");
      return;
    }
    img_data = (unsigned char*)malloc(width * height * depth);
    if (img_data == NULL)
    {
      trace("changeWidgetIcon::Could not alloc image buffer.\n");
      return;
    }
    nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
    Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
    image2 = image->copy();
    delete(image);
    nsvgDeleteRasterizer(rast);
    nsvgDelete(svg_image);
  }
  else if((has_file_extention_at_end(icon_file,".jpg"))||
  (has_file_extention_at_end(icon_file,".jpeg"))||
  (has_file_extention_at_end(icon_file,".face")))
  {
    Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else if(has_file_extention_at_end(icon_file,".gif"))
  {
    Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
    image2 = image->copy(w,h);
    delete(image);
  }
  else{return;}
  
  widget->image(image2->copy());
  delete(image2);
  widget->show();
}

std::vector<std::string> UI::comma_vector(std::string LINE,std::vector<std::string> Vector) {
  std::string original,preComma,postComma;
  original=LINE;
  unsigned int found,finder;
  finder=original.length();
  for(found=original.find(",");found<finder;found=original.find(",")){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

std::string UI::convert_num_to_string(int num) {
  std::string number;
  std::stringstream out;
  out << num;
  number = out.str();
  return number;
}

unsigned int UI::convert_string_to_number(std::string num) {
  if(num.compare("")==0){return 0;}
  std::stringstream out;
  out << num;
  unsigned int integer;
  out >> integer;
  return integer;
}

std::string UI::current_path(int whichPath) {
  unsigned int lastPath = 0;
  std::string result;
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  const char* path =getenv("PATH");
  std::string stringPATH;
  if(path == NULL){stringPATH = "/usr/bin";}
  else{stringPATH = path;}
  std::string::size_type firstPosition = stringPATH.find(':');
  if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
  std::string::size_type position = firstPosition;
  for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
  result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
  return result;
}

std::vector<std::string> UI::delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter) {
  std::vector<std::string> Vector;
  std::string original,preComma,postComma;
  original=string_to_become_vector;
  unsigned int found,finder;
  finder=original.length();
  if(original.find(delimiter)>original.length()){
    Vector.push_back(original);
    return Vector;
  }
  for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
    preComma=original;
    postComma=original;
    preComma=preComma.erase(found,std::string::npos);
    if(preComma.compare("")!=0){Vector.push_back(preComma);}
    postComma=postComma.erase(0,found+1);
    original=postComma;
    finder=original.length();
  }
  if(postComma.compare("")!=0){Vector.push_back(postComma);}
  return Vector;
}

void UI::decide() {
  switch(type)
  {
    case 0:
      shutdown();
      break;
    case 1:
      suspend();
      break;
    case 2:
      hibernate();
      break;
    case 3:
      leave();
      break;
    default:
      exit(0);
  }
}

std::vector<std::string> UI::desktop_dirs() {
  std::string envVar ="XDG_DATA_DIRS";
  std::string incasenothingexists="/usr/local/share/:/usr/share/";
  std::vector<std::string> thisPath;
  std::vector<std::string>::iterator it;
  std::string thisXDG;
  const char* datadirs=getenv(envVar.c_str());
  if (datadirs == NULL)
  {
    thisXDG=incasenothingexists;
  }
  else
  {
    thisXDG=datadirs;
  }
  unsigned int numberOfPaths;
  std::string tempXDG = thisXDG;
  unsigned int tryer=0;
  unsigned int xdgLen=0;
  xdgLen=thisXDG.length();
  for (numberOfPaths=0;tryer<xdgLen;)
  {
    tryer = tempXDG.find(":");
    tempXDG=tempXDG.erase(0,tryer+1);
    xdgLen=tempXDG.length();
    numberOfPaths++;
  }
  unsigned int lastPath = 0;
  std::string result;
  for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
  {
    if (whichPath >=1){lastPath = whichPath - 1;}
    else {lastPath = 0;}
    std::string::size_type firstPosition = thisXDG.find_first_of(':');
    std::string::size_type position = thisXDG.find(':');
    for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
    for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
    result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
    thisPath.push_back(result);    
  }
  std::sort (thisPath.begin(), thisPath.end());
  it = std::unique (thisPath.begin(), thisPath.end());
  thisPath.resize( std::distance(thisPath.begin(),it) );
  return thisPath;
}

std::string UI::file_to_string(std::string filename) {
  if(filename.compare("")==0){return "";}
  /** make sure it is actually a file */
  if(!test_file(filename)){trace("No file sent in: "+filename);}
  std::string thisLine;
  std::string fullString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(fullString.compare("")==0){fullString=thisLine;}
      else{fullString=fullString+"\n"+thisLine;}
    }
  }
  return fullString;
}

std::string UI::find_xdg_data_dir_subdir(std::string subdir) {
  std::vector<std::string> xdgDataDirs = desktop_dirs();
  std::string dirToOpen;
  for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
  it!=xdgDataDirs.end();
  ++it)
  {
    dirToOpen=*it;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
    else
    {
      dirToOpen+="/";
      dirToOpen+=subdir;
    }
    if(test_dir(dirToOpen))
    {
      if(finder+1==dirToOpen.length()){return dirToOpen;}
      else
      {
        dirToOpen+="/";
        return dirToOpen;
      }
    }
    else{trace(dirToOpen+" does not exist");}
  }
  return "";
}

std::string UI::get_directory_from_filename(std::string filename) {
  unsigned int finder=filename.rfind("/");
  if(finder<filename.length())
  {
    filename=filename.erase(finder,std::string::npos);
  }
  else{return "";} /**return empty if there is no directory*/
  return filename;
}

std::string UI::get_equal_value(std::string INTERNAL_LINE) {
  std::string subString;
  unsigned int found =INTERNAL_LINE.find("=");
  if(found < INTERNAL_LINE.length())
  {
   subString=INTERNAL_LINE.substr(found+1,std::string::npos);
   return subString;
  }
  return "";
}

std::vector<std::string> UI::get_file_vector(std::string DIRECTORY,std::string file) {
  std::vector<std::string> myVector;
  if(!test_dir(DIRECTORY)){return myVector;}
  if(DIRECTORY.compare("")==0){return myVector;}
  if(file.compare("")==0){return myVector;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(DIRECTORY.c_str());
  if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        unsigned int findIT = fullpath.find(file);
        if(findIT<=fullpath.length()){myVector.push_back(fullpath);}
  
      }
      if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        fullpath=DIRECTORY+fullpath;
        if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
        std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          std::string temp=fullpath+file;
          myVector.push_back(temp);
        }
      }
    }
  }
  myVector=sort_array(myVector);
  return myVector;
}

std::string UI::get_gtk_icon_theme() {
  if(m_gtk_theme.compare("")!=0)
    return m_gtk_theme;
  std::string itemToGet="icon";
  std::string defaultTheme="hicolor";
  std::string gtkrc2_result, gtkrc3_result,gtk2;
  if((itemToGet.compare("icon")!=0)&&(itemToGet.compare("")!=0))
  {
    itemToGet="";
  }
  std::string item=itemToGet;
  std::string GSETTINGS=term_out("which gsettings");
  std::string GCONF2=term_out("which gconftool-2");
  if(GSETTINGS.find("gsettings")<GSETTINGS.length())
  {
    std::string temp=item;
    if(item.compare("")==0)temp="gtk";
    gtkrc3_result=term_out(GSETTINGS+" get org.gnome.desktop.interface "+temp+"-theme");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\'");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\'");
    m_gtk_theme = gtkrc3_result;
    return gtkrc3_result;
  }
  if(GCONF2.find("gconftool-2")<GCONF2.length())
  {
    std::string temp="gtk";
    if(item.compare("")!=0)temp=item;
    gtk2=term_out(GCONF2+" --get /desktop/gnome/interface/"+temp+"_theme");
    m_gtk_theme = gtk2;
    return gtk2;
  }
  const char* home = getenv("HOME");
  if(home==NULL){return defaultTheme;}
  std::string HOME=home;
  //CHECK/SET GTKRC FILES
  std::string GTKRC2=HOME + "/.gtkrc-2.0";
  const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
  std::string XDG_CONFIG_HOME;
  if (xdg_config_home!=NULL)
  {
    XDG_CONFIG_HOME=xdg_config_home;
  }
  else
  {
    XDG_CONFIG_HOME=HOME +"/.config";
  }
  std::string GTKRC3=XDG_CONFIG_HOME + "/gtk-3.0/settings.ini";
  if(test_file(GTKRC3.c_str()))
  {
    std::string temp;
    if(item.compare("")!=0)temp=item+"-";
    temp="gtk"+temp+"-theme-name=";
    gtkrc3_result=get_line_with_equal(GTKRC3,temp);
    gtkrc3_result=remove_cruft(gtkrc3_result,temp);
    gtkrc3_result=remove_cruft(gtkrc3_result,"\"");
    gtkrc3_result=remove_cruft(gtkrc3_result,"\"");
    m_gtk_theme = gtkrc3_result;
    return gtkrc3_result;
  }
  if(test_file(GTKRC2.c_str()))
  {
    std::string temp;
    if(item.compare("")!=0)temp=item+"-";
    temp="gtk"+temp+"-theme-name=";
    gtkrc2_result=get_line_with_equal(GTKRC2,temp);
    gtkrc2_result=remove_cruft(gtkrc2_result,"\"");
    gtkrc2_result=remove_cruft(gtkrc2_result,"\"");
    m_gtk_theme = gtkrc2_result;
    return gtkrc2_result;
  }
  return defaultTheme;
}

std::string UI::get_line_with_delim(std::string filename, std::string line,std::string delim) {
  if(line.compare("")==0){return "";}
  if(filename.compare("")==0){return "";}
  if(!test_file(filename)){trace("get_line_with_delim::No file sent in\n"+filename+","+line);}
  std::string thisLine;
  std::string subString;
  std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
  std::string hash="#";
  std::string itemToFind=line+delim;
  unsigned int len=itemToFind.length();
  if(inputFileStream.is_open())
  {
    while (getline(inputFileStream,thisLine))
    {
      if(thisLine.find(hash)<=1){}
      else
      {
        unsigned int found=thisLine.find(itemToFind);
        if(found<thisLine.length())
        {
          found+=len;
          subString=thisLine.substr(found,std::string::npos);
          return subString;
        }
      }
    }
  }
  return "";
}

std::string UI::get_line_with_equal(std::string filename, std::string line) {
  return get_line_with_delim(filename,line,"=");
}

std::string UI::get_shell_for_C() {
  std::string shell=term_out("which bash");
  if(shell.compare("")==0){
    if(!test_exec(shell)){
    shell=term_out("which sh");
    if(!test_exec(shell)){return "";}
    //TODO make this work for others
    }
  }
  shell=shell+" -c '";
  return shell;
}

std::string UI::get_symlinkpath(std::string symlink) {
  struct stat statinfo;
  if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
  if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
  {
    std::vector<char> buf(400);
    size_t len;
    do
    {
      buf.resize(buf.size() + 100);
      len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
    }
    while(buf.size() == len);
    if (len > 0)
    {
      buf[len] = '\0';
      return (std::string(&(buf[0])));
    }
  }
  else
  {
    return symlink;
  }
  return symlink;
}

bool UI::has_file_extention_at_end(std::string filename,std::string extention) {
  std::string extention_check;
  std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
  std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
  unsigned int found=filename.find(extention);
  unsigned int ext_len=extention.length();
  unsigned int file_len=filename.length();
  if(found<file_len)
  {
    if(found==(file_len-ext_len))
    {
      return true;
    }
  }
  return false;
}

int UI::hibernate() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" hibernate";
    return run(test);
  }
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Hibernate";
    return run(test);
  }
  return -1;
}

unsigned int UI::items_in_path() {
  const char* path =getenv("PATH");
  std::string::size_type pathPosition =0;
  if(path==NULL){return 1;}
  std::string stringPATH = path;
  unsigned int howmany;
  for(howmany=1;(pathPosition!=std::string::npos);howmany++)
  {
    pathPosition=stringPATH.find(':', pathPosition+1);
  }
  return howmany;
}

std::vector<std::string> UI::IconPaths(int size_to_use) {
  std::vector<std::string> ret;
  if(m_themesVector.empty())
    m_themesVector=icon_themefiles_vector();
  
  std::string gtk_theme=get_gtk_icon_theme();
  gtk_theme=sed_i(gtk_theme,"-"," ");
  
  trace("IconPaths::Look for this="+gtk_theme);
  if(m_themesVector.empty())
  {
    trace("IconPaths::Didn't find any Icon themes");
    return ret;
  }
  return IconPathsForTheme(gtk_theme,size_to_use);
}

std::vector<std::string> UI::IconPathsForTheme(std::string theme,int size_to_use) {
  std::vector<std::string> ret;
  std::string themefile;
  for( std::vector<std::string>::iterator it = m_themesVector.begin();
  it!=m_themesVector.end();
  ++it)
  {
    std::string THEME=*it;
    std::string theme_name=get_line_with_equal(THEME,"Name");
    if(theme_name.compare(theme)==0)
    {
      trace("IconPathsForTheme::File="+THEME);
      ret=join_string_vectors(ret,list_icon_dirs_in_themefile(THEME,size_to_use));
      //std::reverse(ret.begin(),ret.end());
      std::string inherits=get_line_with_equal(THEME,"Inherits");
      std::vector<std::string> inheritsVec = delimiter_vector_from_string(inherits,",");
  
      for( std::vector<std::string>::iterator iter = inheritsVec.begin();
        iter!=inheritsVec.end();
        ++iter)
      {
        std::string item = *iter;
        ret=join_string_vectors(ret,IconPathsForTheme(item,size_to_use));
      }
    }
  }
  //std::reverse(ret.begin(),ret.end());
  return ret;
}

std::vector<std::string> UI::icon_themefiles_vector() {
  std::string DIRECTORY=find_xdg_data_dir_subdir("icons");
  std::vector<std::string> thisISmyVector;
  if(DIRECTORY.compare("")==0){trace("Icon directory NOT found");}
  else{thisISmyVector=get_file_vector(DIRECTORY,"index.theme");}
  if(thisISmyVector.empty()){trace("Didn't find and Icon themes");}
  return thisISmyVector;
}

std::vector<std::string> UI::join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB) {
  std::vector<std::string> bothVectors;
  bothVectors.reserve(vectorA.size()+vectorB.size());
  bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
  bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
  return bothVectors;
}

int UI::leave() {
  std::string LOGOUT = "loginctl terminate-session $XDG_SESSION_ID";
  if(test_file("/etc/default/nodm"))
  {
    std::string tmp=file_to_string("/etc/default/nodm");
    unsigned int finder=tmp.find("NODM_ENABLED=true");
    if(finder<tmp.length())
    {
      LOGOUT="jwm -reload";
    }
  }
  return run(LOGOUT);
}

std::vector<std::string> UI::list_icon_dirs_in_themefile(std::string themefile,int size_to_use) {
  std::vector<std::string> ListOfIconDirs;
  std::string SIZE_TO_USE=convert_num_to_string(size_to_use);
  std::string INTERNAL_LINE;
  std::string subString;
  std::string basedir=get_directory_from_filename(themefile);
  std::string THEME_DIR=basedir;
  if(!test_file(themefile))
       return ListOfIconDirs;
  std::ifstream inputFileStrem (themefile.c_str(), std::ifstream::in);
  std::string INHERITS;
  std::string tmpDIRi="/usr/share/pixmaps/";
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  
  tmpDIRi="/usr/share/icons/hicolor/48x48/apps/";
  
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  
  tmpDIRi="/usr/share/icons/hicolor/scalable/apps/";
  
  if(test_dir(tmpDIRi))
    ListOfIconDirs.push_back(tmpDIRi);
  if(inputFileStrem.is_open())
  {
    std::string DIRS,MIN,MAX,SIZE,TYPE,THRESH,CONTEXT,HEADER;
    int size=0;
    int tresh=0;
    int max=0;
    int min=0;
    std::string LINE=get_equal_value(INTERNAL_LINE);
    while (getline(inputFileStrem,INTERNAL_LINE))
    {
         if(INTERNAL_LINE.find('[')<INTERNAL_LINE.length())
         {
           HEADER=INTERNAL_LINE;
           HEADER=remove_cruft(HEADER,"[");
           HEADER=remove_cruft(HEADER,"]");
           HEADER="/"+HEADER;
         }
         else if(INTERNAL_LINE.find("Inherits=")<INTERNAL_LINE.length())
         {
           INHERITS=LINE;
         }
         else if(INTERNAL_LINE.find("Directories=")<INTERNAL_LINE.length())
         {
           DIRS=LINE;
         }
         else if(INTERNAL_LINE.find("MinSize=")<INTERNAL_LINE.length())
         {
           MIN=LINE;
           min=convert_string_to_number(MIN);
         }
         else if(INTERNAL_LINE.find("MaxSize=")<INTERNAL_LINE.length())
         {
           MAX=LINE;
           max=convert_string_to_number(MAX);
         }
         else if(INTERNAL_LINE.find("Size=")<INTERNAL_LINE.length())
         {
           SIZE=LINE;
           size=convert_string_to_number(SIZE);
         }
         else if(INTERNAL_LINE.find("Type=")<INTERNAL_LINE.length())
         {
           TYPE=LINE;
         }
         else if(INTERNAL_LINE.find("Threshold=")<INTERNAL_LINE.length())
         {
           THRESH=LINE;
           tresh=convert_string_to_number(THRESH);
         }
         else if(INTERNAL_LINE.find("Context=")<INTERNAL_LINE.length())
         {
           CONTEXT=LINE;
         }
         if((CONTEXT.compare("Animations")!=0)
         &&(CONTEXT.compare("Stock")!=0)
         &&(CONTEXT.compare("Status")!=0)
         &&(CONTEXT.compare("Emblems")!=0)
         &&(CONTEXT.compare("Emotes")!=0)
         &&(CONTEXT.compare("International")!=0) )
         {
           if((SIZE.compare(SIZE_TO_USE))||
           ((tresh-size)==(size_to_use))||
           ((tresh+size)==(size_to_use)) )
           {
              if(HEADER.find(SIZE)<HEADER.length())
              {
                std::string testDIR=THEME_DIR+HEADER;
                if(test_dir(testDIR))
                {
                  if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                    ListOfIconDirs.push_back(testDIR);
                }
              }
         }
         else{
              if(TYPE.compare("Scalable")==0)
              {
                if((max>=size)&&(min<=size))
                {
                  std::string testDIR=THEME_DIR+HEADER;
                  if(test_dir(testDIR))
                  {
                       if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                         ListOfIconDirs.push_back(testDIR);
                  }
                }
              }
         }
         }
       }
  }
  trace("list_icon_dirs_in_themefile::Done parsing themefile "+themefile);
  if(INHERITS.compare("")!=0)
  {
    std::string inheritThemeFileDIR=find_xdg_data_dir_subdir("icons");
    std::string inheritThemeFile=inheritThemeFileDIR;
    if(INHERITS.find(",")<INHERITS.length())
    {
      std::vector<std::string> InheritFileVector=comma_vector(INHERITS,InheritFileVector);
      std::vector<std::string> IconFileVector=list_icon_dirs_in_themefile( themefile, size_to_use);
      for( std::vector<std::string>::iterator it = InheritFileVector.begin();
         it!=InheritFileVector.end();
         ++it)
      {
         std::string thisTheme=*it;
         inheritThemeFile+=thisTheme;
         std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
         if(temp.compare("")==0)
         {
              trace("list_icon_dirs_in_themefile::Couldn't find theme file in:"+inheritThemeFile);
         }
         else{
              std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
              if(!ListOfInheritIconDirs.empty())
              {
                ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
              }
         }
         }
       }
       else
       {
         inheritThemeFile+=INHERITS;
         std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
         if(temp.compare("")==0)
         {
           trace("list_icon_dirs_in_themefileCouldn't find theme file in:"+inheritThemeFile);
         }
         else{
           std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
           if(!ListOfInheritIconDirs.empty())
           {
              ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
           }
         }
       }
  }
  return ListOfIconDirs;
}

std::string UI::look_for_icon_file(std::string fileWITHOUTpath) {
  std::string dir=find_xdg_data_dir_subdir("icons");
  trace("std::string look_for_icon_file(std::string "+fileWITHOUTpath+")");
  std::string gtktheme=get_gtk_icon_theme();
  
  if(dir.rfind('/')!=dir.length()-1){dir+="/";}
  
  std::string testingDIR=dir+gtktheme;
  
  if(testingDIR.rfind('/')!=testingDIR.length()-1){testingDIR+="/";}
  if(test_dir(testingDIR)){dir=testingDIR;}
  
  if(fileWITHOUTpath.compare("")==0)
  {
    trace("look_for_icon_file::(std::string "+fileWITHOUTpath+") requires non empty variables to work\nMUST EXIT");
    return "";
  }
  trace("look_for_icon_file::GTKtheme="+gtktheme+"\nDir="+dir);
  if(!test_dir(dir))
  {
    trace("look_for_icon_file::"+dir+" is not a directory\nTrying to look in icons directories");
    dir=find_xdg_data_dir_subdir("icons");
    if(!test_dir(dir))
    {
      trace("look_for_icon_file::"+dir+" is not a directory\nMUST EXIT");
      return "";
    }
    return look_for_first_file_in_subdirs(fileWITHOUTpath,dir);
  }
  
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  std::string finalAnswer;
  
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string fullpath=entryPointer->d_name;
  
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
  
      fullpath=dir+fullpath;
  
      if((entryPointer->d_type == DT_REG)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string tempFINDER="/"+fileWITHOUTpath;
        unsigned int findIT = fullpath.find(tempFINDER);
        if(findIT<=fullpath.length())
        {
          closedir(mydir);
          finalAnswer=fullpath;
          return fullpath;
        }
      }
  
      if((entryPointer->d_type==DT_DIR)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(test_file(thisAnswer))
          {
            closedir(mydir);
            finalAnswer=thisAnswer;
            return thisAnswer;
          }
        }
      }
    }
    closedir(mydir);
  }
  else
  {
    trace("look_for_icon_file::"+dir+" cannot be opened\nMUST EXIT");
  }
  
  if(finalAnswer.compare("")!=0)
    trace("look_for_icon_file::Final Answer="+finalAnswer);
  
  return finalAnswer;
}

std::string UI::look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
    return "";
  
  /** if it is not a directory return empty */
  if(!test_dir(dir))
    return "";
  
  /** remove the preceding path*/
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  
  /** open the directory */
  if(mydir!=NULL){
    while ((entryPointer=readdir(mydir))!=NULL)
    {
    /** find out if it is a symlink or regular file that is not hidden*/
      if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        unsigned int findIT = fullpath.find(fileWITHOUTpath);
        if(findIT<=fullpath.length())
        {
      /** add a comma at the end if there isn't one already*/
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
          ANSWERS+=fullpath;
        }
      }
      /** find out if it is a directory that is not hidden*/
      if((entryPointer->d_type==DT_DIR)
      &&(entryPointer->d_name[0]!='.'))
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
          {
            ANSWERS+=",";
          }
          ANSWERS+=thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
  if(ANSWERS.compare("")!=0)
  {
    return ANSWERS;
  }
  return "";
}

std::string UI::look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) {
  if((dir.compare("")==0)
  ||(fileWITHOUTpath.compare("")==0))
  {
    trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\nMUST EXIT");
    return "";
  }
  if(!test_dir(dir))
  {
    trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\nMUST EXIT");
    return "";
  }
  unsigned int found=fileWITHOUTpath.rfind('/');
  if(found<fileWITHOUTpath.length())
  {
    unsigned int len=fileWITHOUTpath.length()-found;
    fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
  }
  std::string ANSWERS;
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  std::string finalAnswer;
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
    /** if it is a symlink or file check it */
      if(((entryPointer->d_type == DT_LNK)
        ||(entryPointer->d_type == DT_REG))
        &&(entryPointer->d_name[0]!='.'))
      {
        std::string tempFINDER="/"+fileWITHOUTpath;
        trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\nfullpath="+fullpath);
        unsigned int findIT = fullpath.find(tempFINDER);
        if(findIT<=fullpath.length())
        {
          if(entryPointer->d_type == DT_LNK)
          {
      /** if it is a symlink get the actual file */
            std::string temporary=get_symlinkpath(fullpath);
            trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\nFile="+temporary);
            if(temporary.compare("")!=0)
            {
              closedir(mydir);
              if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
              trace("look_for_first_file_in_subdirs::Symlink="+temporary);
              finalAnswer=temporary;
              return temporary;
            }
          }
          else
          {
            closedir(mydir);
            finalAnswer=fullpath;
            return fullpath;
          }
        }
      }
    /** if it is a directory look inside recursively */
      if((entryPointer->d_type==DT_DIR)
       &&(entryPointer->d_name[0]!='.'))
      {
        std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
        if(thisAnswer.compare("")!=0)
        {
          if(test_file(thisAnswer))
          {
            closedir(mydir);
            finalAnswer=thisAnswer;
            return thisAnswer;
          }
        }
      }
    }
    closedir(mydir);
  }
  else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\nMUST EXIT");}
  trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
  return finalAnswer;
}

bool UI::look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find) {
  for( std::vector<std::string>::iterator it = vector_to_check.begin();
  it!=vector_to_check.end();
  ++it){
    std::string tmp=*it;
    if(tmp.compare(item_to_find)==0){return true;}
  }
  return false;
}

std::string UI::remove_cruft(std::string StringInput, std::string CruftToRemove) {
  if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
  unsigned int found=0;
  unsigned int cruftLength=CruftToRemove.length();
  found=StringInput.find(CruftToRemove);
  if(found>StringInput.length()){return StringInput;}
  std::string temp=StringInput;
  temp=temp.erase(0,found+cruftLength);
  if(temp.compare("")!=0){return temp;}
  std::string temp2=StringInput;
  temp2=temp2.erase(found,std::string::npos);
  if(temp2.compare("")!=0){return temp2;}
  trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
  return StringInput;
}

int UI::run(std::string program) {
  std::string shell=get_shell_for_C();
  if(shell.compare("")!=0)
  {
    shell+=program;
    shell+="'";
  }
  else{shell=program;}
  trace("run_program::"+shell);
  return system(shell.c_str());
}

std::string UI::sed_i(std::string input, std::string remove, std::string replace) {
  unsigned int xmlfix=0;
  unsigned int oldFind=0;
  unsigned int length=input.length();
  unsigned int removeLength=remove.length();
  std::string modinput=input;
  while(modinput.find(remove,oldFind)<length)
  {
    xmlfix = modinput.find(remove,oldFind);
    oldFind=xmlfix+replace.length();
    std::string tempPRE,tempPOST,temp;
    if(xmlfix<length)
    {
      temp=modinput;
      tempPOST=modinput;
      tempPRE = temp.erase(xmlfix,std::string::npos);
      tempPOST = modinput.erase(0,xmlfix+removeLength);
      modinput = tempPRE + replace + tempPOST;
      length=modinput.length();
    }
  }
  return modinput;
}

void UI::setup(int TYPE,bool YES) {
  type=TYPE;
  if(YES)
  {
    decide();
    exit(0);
  }
  make_window()->show();
  std::string TITLE="Shutdown";
  std::string ICON="system-shutdown";
  switch(TYPE)
  {
    case 1:
      TITLE="Suspend";
      ICON="system-suspend";
      break;
    case 2:
      TITLE="Hibernate";
      ICON="system-hibernate";
      break;
    case 3:
      TITLE="Logout";
      ICON="system-logout";
      break;
    default:
      break;
  }
  win->copy_label(TITLE.c_str());
  label->copy_label(TITLE.c_str());
  changeWidgetIcon(ICON,icon);
}

int UI::shutdown() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" poweroff";
    return run(test);
  }
  
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop";
    return run(test);
  }
  return -1;
}

std::vector<std::string> UI::sort_array(std::vector<std::string> vector_to_sort) {
  std::vector<std::string>::iterator it;
  std::sort (vector_to_sort.begin(), vector_to_sort.end());
  it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
  vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
  return vector_to_sort;
}

int UI::suspend() {
  std::string test=term_out("which systemctl");
  if(test.compare("")!=0)
  {
    test+=" suspend";
    return run(test);
  }
  
  test=term_out("which dbus-send");
  if(test.compare("")!=0)
  {
    test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend";
    return run(test);
  }
  return -1;
}

bool UI::test_dir(std::string dirToTest) {
  if(dirToTest.compare("")==0){return false;}
  DIR *dir = NULL;
  dir = opendir(dirToTest.c_str());
  if (dir!=NULL)
  {
    closedir(dir);
    return true;
  }
  return false;
}

bool UI::test_exec(std::string execToTest) {
  if(execToTest.compare("")==0){return false;}
  /** the list of directories it might check*/
  /** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
  std::string stringEXEC;
  std:: string testPATH, testExec;
  bool result = false;
  unsigned int numofpaths = items_in_path();
  for (unsigned int i = 1; i <= numofpaths; i++)
  {
    stringEXEC = execToTest;
    testPATH = current_path(i);
    stringEXEC = testPATH + "/" + stringEXEC;
    if(test_file(stringEXEC.c_str())){return true;}
  }
  return result;
}

bool UI::test_file(std::string fileWithFullPATH) {
  if(fileWithFullPATH.compare("")==0){return false;}
  std::string dir=get_directory_from_filename(fileWithFullPATH);
  if(dir.compare("")==0){return false;}
  DIR *mydir=NULL;
  struct dirent *entryPointer=NULL;
  mydir=opendir(dir.c_str());
  if(mydir!=NULL)
  {
    while ((entryPointer=readdir(mydir))!=NULL)
    {
      if(entryPointer->d_type == DT_REG)
      {
        std::string fullpath=entryPointer->d_name;
        if(dir.rfind('/')!=dir.length()-1){dir+="/";}
        fullpath=dir+fullpath;
        if(fullpath.compare(fileWithFullPATH)==0)
        {
          closedir(mydir);
          return true;
        }
      }
    }
    closedir(mydir);
  }
  else{trace("could not open directory to search for "+fileWithFullPATH);}
  return false;
}

std::string UI::test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check) {
  if(fileWithNOPATH.compare("")==0){return "";}
  std::string filePathRemoved=fileWithNOPATH;
  unsigned int found=filePathRemoved.rfind('/');
  trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
  if(found<filePathRemoved.length())
  {
    unsigned int len=filePathRemoved.length()-found;
    filePathRemoved=filePathRemoved.erase(0,len);
  }
  for( std::vector<std::string>::iterator it = directories_to_check.begin();
    it!=directories_to_check.end();
    ++it)
  {
    std::string dirToOpen=*it;
    std::string result=dirToOpen;
    unsigned int finder=dirToOpen.rfind('/');
    if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
    else
    {
      result+="/";
      result+=filePathRemoved;
    }
    if(test_file(result))
    {
      trace("test_file_in_vector_path::FOUND="+result);
      return result;
    }
    else
    {
      std::string tmp=result;
      tmp=get_symlinkpath(tmp);
      if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
    }
  }
  return "";
}

std::string UI::term_out(std::string terminal_Command_You_Want_Output_From) {
  if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
  /** set a locale so this works well */
  const char* LANG=getenv("LANG");
  std::string LOCALE;
  if(LANG==NULL)
  {
    LANG=getenv("LANGUAGE");
    if(LANG!=NULL){
    std::string tmp=LANG;
    unsigned int find=tmp.find(".UTF-8");
    if(find>tmp.length()){tmp+=".UTF-8";}
    LOCALE=tmp;
    }
  }
  else
  {
    LOCALE=LANG;
  }
  if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
  std::string result="";
  const int max_buffer = 1024;
  char buffer[max_buffer];
  FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
  if (command_p)
  {
    while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
    pclose(command_p);
  }
  else{ return "";}
  if (result.compare("")==0){return "";}
  int end = result.length();
  if((end-1) == 0){return "";}
  if((end) == 0){return "";}
  return result.erase(end-1,1);
}

int main(int argc, char *argv[]) {
  std::string command;
  Fl::visual(FL_RGB);
  unsigned int TYPE=0;
  bool YES=false;
  UI* ui = new UI();
  try
  {
    if(argc>0)
    {
      for (int i = 1;i<argc;++i)
      {
        command=argv[i];
        for (int i=0;i<argc;i++)
        {
          if (command.compare("--shutdown")==0)
            TYPE=0;
          else if (command.compare("--suspend")==0)
            TYPE=1;
          else if (command.compare("--hibernate")==0)
            TYPE=2;
          else if (command.compare("--exit")==0)
            TYPE=3;
          else if ( (command.compare("--yes")==0) ||
                    (command.compare("-y")==0) ||
                    (command.compare("-f")==0) ||
                    (command.compare("--force")==0)
                  )
           YES=true;
          else
          {
            return usage(argv[0]);
          }
        }
      }
      ui->setup(TYPE,YES);
    }
    return Fl::run();
  }
  catch (const std::exception& e)
  {
    std::cerr << "Unhandled exception:\n" << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (...)
  {
    std::cerr << "Unknown exception!" << std::endl;
    return EXIT_FAILURE;
  }
  return -1;
}

void trace(std::string msg) {
  //std::cout<<msg<<std::endl;
}

int usage(char* name) {
  std::cout<<name<<std::endl<<
  "USAGE:"<<std::endl<<
  "[--shutdown|--suspend|--hibernate|--exit|-y|--yes|-f|--force]"<<std::endl<<
  "  --shutdown shutdown computer"<<std::endl<<
  "  --suspend suspend computer"<<std::endl<<
  "  --hibernate hibernate computer"<<std::endl<<
  "  --exit exit JWM\n"<<std::endl<<
  "  --yes | -y | -f | --force Do not show dialog"<<std::endl;
}
