# data file for the Fltk User Interface Designer (fluid)
version 1.0304
i18n_type 1
i18n_include <libintl.h>
i18n_function gettext
header_name {.h}
code_name {.cxx}
decl {\#include "../include/single.h"} {public global
}

decl {\#include "../include/toolbar_icons.h"} {public global
}

decl {\#include <FL/Fl_JPEG_Image.H>
\#include <FL/Fl_PNG_Image.H>
\#include <FL/Fl_XBM_Image.H>
\#include <FL/Fl_XPM_Image.H>
\#include <FL/Fl_GIF_Image.H>} {public global
}

decl {\#define NANOSVG_ALL_COLOR_KEYWORDS
\#define NANOSVG_IMPLEMENTATION
\#include "../include/nanosvg.h"
\#define NANOSVGRAST_IMPLEMENTATION
\#include "../include/nanosvgrast.h"} {private local
}

decl {\#include <stdexcept>
\#include <string>
\#include <iostream>
\#include <fstream>
\#include <vector>
\#include <sys/stat.h>
\#include <sys/types.h>
\#include <fcntl.h>
\#include <sys/sendfile.h>  // sendfile
\#include <algorithm>
\#include <float.h>
\#include <sstream>
\#include <float.h>
\#include <dirent.h>
\#include <sys/stat.h>
\#include <langinfo.h>
\#include <stdlib.h>
\#include <stdio.h>
\#include <cstdlib>
\#include <fstream>
\#include <sstream>
\#include <errno.h>
\#include <locale.h>
\#include <unistd.h>
\#include <signal.h>} {public global
}

class UI {open
} {
  decl {unsigned int type;} {protected local
  }
  decl {std::string SHUTDOWN_TEXT;} {protected local
  }
  decl {std::string REBOOT_TEXT;} {protected local
  }
  decl {std::string SUSPEND_TEXT;} {protected local
  }
  decl {std::string HIBERNATE_TEXT;} {protected local
  }
  decl {std::string LOGOUT_TEXT;} {protected local
  }
  Function {UI()} {open
  } {
    code {SHUTDOWN_TEXT  = gettext("Shutdown");
REBOOT_TEXT    = gettext("Reboot");
SUSPEND_TEXT   = gettext("Suspend");
HIBERNATE_TEXT = gettext("Hibernate");
LOGOUT_TEXT    = gettext("Log Out");
//  = gettext("")} {}
  }
  Function {make_window()} {open
  } {
    Fl_Window win {
      label Power open
      xywh {683 317 183 110} type Double resizable visible
    } {
      Fl_Button {} {
        label OK
        callback {decide();} selected
        xywh {95 70 65 30} box FLAT_BOX color 62 selection_color 60 labelcolor 7
      }
      Fl_Button {} {
        label Cancel
        callback {win->hide();}
        xywh {10 70 65 30} box FLAT_BOX color 80 selection_color 72 labelcolor 7
      }
      Fl_Box icon {
        xywh {15 7 48 48}
      }
      Fl_Box label {
        label Shutdown
        xywh {65 15 115 35}
        code0 {o->label(win->label());}
      }
    }
  }
  Function {decide()} {} {
    code {switch(type)
{
  case 0:
    shutdown();
    break;
  case 1:
    suspend();
    break;
  case 2:
    hibernate();
    break;
  case 3:
    leave();
    break;
  case 4:
    restart();
    break;
  default:
    exit(0);
}} {}
  }
  Function {get_directory_from_filename(std::string filename)} {return_type {std::string}
  } {
    code {unsigned int finder=filename.rfind("/");
if(finder<filename.length())
{
  filename=filename.erase(finder,std::string::npos);
}
else{return "";} /**return empty if there is no directory*/
return filename;} {}
  }
  Function {get_shell_for_C()} {return_type {std::string}
  } {
    code {std::string shell=term_out("which bash");
if(shell.compare("")==0){
  if(!test_exec(shell)){
  shell=term_out("which sh");
  if(!test_exec(shell)){return "";}
  //TODO make this work for others
  }
}
shell=shell+" -c '";
return shell;} {}
  }
  Function {hibernate()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" hibernate";
  return run(test);
}
test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Hibernate";
  return run(test);
}
return -1;} {}
  }
  Function {items_in_path()} {return_type {unsigned int}
  } {
    code {const char* path =getenv("PATH");
std::string::size_type pathPosition =0;
if(path==NULL){return 1;}
std::string stringPATH = path;
unsigned int howmany;
for(howmany=1;(pathPosition!=std::string::npos);howmany++)
{
  pathPosition=stringPATH.find(':', pathPosition+1);
}
return howmany;} {}
  }
  Function {leave()} {return_type int
  } {
    code {std::string LOGOUT = "loginctl terminate-session $XDG_SESSION_ID";
/*if(test_file("/etc/default/nodm"))
{
  std::string tmp=file_to_string("/etc/default/nodm");
  unsigned int finder=tmp.find("NODM_ENABLED=true");
  if(finder<tmp.length())
  {
    LOGOUT="jwm -reload";
  }
}*/
return run(LOGOUT);} {}
  }
  Function {run(std::string program)} {return_type int
  } {
    code {std::string shell=get_shell_for_C();
if(shell.compare("")!=0)
{
  shell+=program;
  shell+="'";
}
else{shell=program;}
trace("run_program::"+shell);
return system(shell.c_str());} {}
  }
  Function {setup(int TYPE,bool YES)} {open
  } {
    code {type=TYPE;
if(YES)
{
  decide();
  exit(0);
}
make_window()->show();
std::string TITLE=SHUTDOWN_TEXT;
switch(TYPE)
{
  case 0:
    icon->image(shutdown_icon);
    break;
  case 1:
    TITLE=SUSPEND_TEXT;
    icon->image(suspend_icon);
    break;
  case 2:
    TITLE=HIBERNATE_TEXT;
    icon->image(hibernate_icon);
    break;
  case 3:
    TITLE=LOGOUT_TEXT;
    icon->image(logout_icon);
    break;
  case 4:
    TITLE=REBOOT_TEXT;
    icon->image(restart_icon);
    break;
  default:
    break;
}
win->copy_label(TITLE.c_str());
label->copy_label(TITLE.c_str());} {}
  }
  Function {shutdown()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" poweroff";
  return run(test);
}

test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop";
  return run(test);
}
return -1;} {}
  }
  Function {restart()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" reboot";
  return run(test);
}

test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Restart";
  return run(test);
}
return -1;} {}
  }
  Function {suspend()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" suspend";
  return run(test);
}

test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend";
  return run(test);
}
return -1;} {}
  }
  Function {test_dir(std::string dirToTest)} {return_type bool
  } {
    code {if(dirToTest.compare("")==0){return false;}
DIR *dir = NULL;
dir = opendir(dirToTest.c_str());
if (dir!=NULL)
{
  closedir(dir);
  return true;
}
return false;} {}
  }
  Function {test_exec(std::string execToTest)} {return_type bool
  } {
    code {if(execToTest.compare("")==0){return false;}
/** the list of directories it might check*/
/** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
std::string stringEXEC;
std:: string testPATH, testExec;
bool result = false;
unsigned int numofpaths = items_in_path();
for (unsigned int i = 1; i <= numofpaths; i++)
{
  stringEXEC = execToTest;
  testPATH = current_path(i);
  stringEXEC = testPATH + "/" + stringEXEC;
  if(test_file(stringEXEC.c_str())){return true;}
}
return result;} {}
  }
  Function {test_file(std::string fileWithFullPATH)} {return_type bool
  } {
    code {if(fileWithFullPATH.compare("")==0){return false;}
std::string dir=get_directory_from_filename(fileWithFullPATH);
if(dir.compare("")==0){return false;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      if(fullpath.compare(fileWithFullPATH)==0)
      {
        closedir(mydir);
        return true;
      }
    }
  }
  closedir(mydir);
}
else{trace("could not open directory to search for "+fileWithFullPATH);}
return false;} {}
  }
  Function {term_out(std::string terminal_Command_You_Want_Output_From)} {return_type {std::string}
  } {
    code {if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
/** set a locale so this works well */
const char* LANG=getenv("LANG");
std::string LOCALE;
if(LANG==NULL)
{
  LANG=getenv("LANGUAGE");
  if(LANG!=NULL){
  std::string tmp=LANG;
  unsigned int find=tmp.find(".UTF-8");
  if(find>tmp.length()){tmp+=".UTF-8";}
  LOCALE=tmp;
  }
}
else
{
  LOCALE=LANG;
}
if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
std::string result="";
const int max_buffer = 1024;
char buffer[max_buffer];
FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
if (command_p)
{
  while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
  pclose(command_p);
}
else{ return "";}
if (result.compare("")==0){return "";}
int end = result.length();
if((end-1) == 0){return "";}
if((end) == 0){return "";}
return result.erase(end-1,1);} {}
  }
  Function {current_path(int iter)} {open return_type {std::string}
  } {
    code {const char* path =getenv("PATH");
if(path==NULL){return "";}
std::string stringPATH = path;
std::string tmp = stringPATH;
unsigned int find=0;
unsigned int itera=0;
std::string howmany;
for(std::string::size_type pathPosition =0;(pathPosition!=std::string::npos);pathPosition=stringPATH.find(':', pathPosition+1))
{
  tmp = stringPATH.substr(pathPosition+1,std::string::npos);
  find=tmp.find(':');
  if(find<tmp.length())
  {  
     howmany = tmp;
     howmany = howmany.substr(0,find);
  }
}
return howmany;} {}
  }
}

Function {main(int argc, char *argv[])} {open return_type int
} {
  code {std::string command;
Fl::visual(FL_RGB);
unsigned int TYPE=0;
bool YES=false;

SingletonProcess singleton(7777);
if (!singleton())
{
  trace("already running");
  return 1;
}

UI* ui = new UI();
try
{
  if(argc>0)
  {
    for (int i = 1;i<argc;++i)
    {
      command=argv[i];
      for (int i=0;i<argc;i++)
      {
        if (command.compare("--shutdown")==0)
          TYPE=0;
        else if (command.compare("--suspend")==0)
          TYPE=1;
        else if (command.compare("--hibernate")==0)
          TYPE=2;
        else if (command.compare("--exit")==0)
          TYPE=3;
        else if (command.compare("--restart")==0)
          TYPE=4;
        else if ( (command.compare("--yes")==0) ||
                  (command.compare("-y")==0) ||
                  (command.compare("-f")==0) ||
                  (command.compare("--force")==0)
                )
         YES=true;
        else
        {
          return usage(argv[0]);
        }
      }
    }
    ui->setup(TYPE,YES);
  }
  return Fl::run();
}
catch (const std::exception& e)
{
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...)
{
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}
return -1;} {}
}

Function {trace(std::string msg)} {} {
  code {//std::cout<<msg<<std::endl;} {}
}

Function {usage(char* name)} {return_type int
} {
  code {std::cout<<name<<std::endl<<
"USAGE:"<<std::endl<<
"[--shutdown|--suspend|--hibernate|--restart|--exit|-y|--yes|-f|--force]"<<std::endl<<
"  --shutdown shutdown computer"<<std::endl<<
"  --suspend suspend computer"<<std::endl<<
"  --hibernate hibernate computer"<<std::endl<<
"  --restart restart computer"<<std::endl<<
"  --exit exit JWM\\n"<<std::endl<<
"  --yes | -y | -f | --force Do not show dialog"<<std::endl;} {}
}
