# data file for the Fltk User Interface Designer (fluid)
version 1.0303 
header_name {.h} 
code_name {.cxx}
decl {\#include <FL/Fl_JPEG_Image.H>
\#include <FL/Fl_PNG_Image.H>
\#include <FL/Fl_XBM_Image.H>
\#include <FL/Fl_XPM_Image.H>
\#include <FL/Fl_GIF_Image.H>} {public global
} 

decl {\#define NANOSVG_ALL_COLOR_KEYWORDS
\#define NANOSVG_IMPLEMENTATION
\#include "../include/nanosvg.h"
\#define NANOSVGRAST_IMPLEMENTATION
\#include "../include/nanosvgrast.h"} {private local
} 

decl {\#include <stdexcept>
\#include <string>
\#include <iostream>
\#include <fstream>
\#include <vector>
\#include <sys/stat.h>
\#include <sys/types.h>
\#include <fcntl.h>
\#include <sys/sendfile.h>  // sendfile
\#include <algorithm>
\#include <float.h>
\#include <sstream>
\#include <float.h>
\#include <dirent.h>
\#include <sys/stat.h>
\#include <langinfo.h>
\#include <stdlib.h>
\#include <stdio.h>
\#include <cstdlib>
\#include <fstream>
\#include <sstream>
\#include <errno.h>
\#include <locale.h>
\#include <unistd.h>
\#include <signal.h>} {public global
} 

class UI {open
} {
  decl {std::string OLD_ICON;} {private local
  }
  decl {std::vector<std::string> m_themesVector;} {protected local
  }
  decl {std::string m_gtk_theme;} {private local
  }
  decl {std::vector<std::string> m_ICON_PATHS;} {protected local
  }
  decl {unsigned int type;} {protected local
  }
  Function {make_window()} {} {
    Fl_Window win {
      label About open
      xywh {49 436 213 110} type Double hide resizable
    } {
      Fl_Button {} {
        label Cancel
        callback {win->hide();}
        xywh {45 70 65 30} box FLAT_BOX color 80 selection_color 72 labelcolor 7
      }
      Fl_Button {} {
        label OK
        callback {decide();}
        xywh {130 70 65 30} box FLAT_BOX color 62 selection_color 60 labelcolor 7
      }
      Fl_Box icon {
        xywh {10 7 48 48}
      }
      Fl_Box label {
        label Shutdown
        xywh {85 15 115 35}
        code0 {o->label(win->label());}
      }
    }
  }
  Function {changeWidgetIcon(std::string icon_file, Fl_Widget * widget,bool save=true)} {open return_type void
  } {
    code {if(save)
{
  if(OLD_ICON==icon_file)
    return;
  OLD_ICON=icon_file;
}
int h = widget->w();
int w = widget->h();
if(w>h)
  h=w;
int iconW=24;
if(icon_file.compare("")==0)
{
  trace("changeWidgetIcon::Icon file is empty");
  return;
}
widget->align(FL_ALIGN_CENTER);
widget->copy_label("");
widget->image(NULL);
widget->redraw();
widget->label(0L);
if(m_ICON_PATHS.empty())
  m_ICON_PATHS=IconPaths(iconW);
std::cout<<"changeWidgetIcon:: w="<<w<<" h="<<h<<std::endl;
if(!test_file(icon_file))
{
  std::string tmp=icon_file;
  unsigned int ext=icon_file.rfind(".");
  if(ext>icon_file.length())
  {
    tmp=icon_file+".svg";
    tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
    if(tmp.compare("")==0)
    {
      tmp=icon_file+".png";
      tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
      if(tmp.compare("")!=0)
      {
        trace("changeWidgetIcon::RESULT="+tmp);
        icon_file=tmp;
      }
    }
    else
    {
      trace("changeWidgetIcon::RESULT="+tmp);
      icon_file=tmp;
    }
  }
  else
  {
    tmp=test_file_in_vector_path(tmp,m_ICON_PATHS);
    if(tmp.compare("")==0)
    {
      trace("changeWidgetIcon::looking for icon file");
      tmp=look_for_icon_file(icon_file);
      
    }
    if(tmp.compare("")!=0)
    {
      icon_file=tmp;
      trace("changeWidgetIcon::RESULT="+tmp);
    }
  }
}
else
{
  trace("changeWidgetIcon::"+icon_file+" is a file!");
}

if(icon_file.compare("")==0)
{
  trace("changeWidgetIcon::Icon file is empty");
  return;
}

Fl_Image* image2=widget->image();//new Fl_Image(w,h,4);

if(has_file_extention_at_end(icon_file,".png"))
{
  Fl_Image* image = new Fl_PNG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xpm"))
{
  Fl_Image* image = new Fl_XPM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".xbm"))
{
  Fl_Image* image = new Fl_XBM_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".svg"))
{
  NSVGimage *svg_image = NULL;
  NSVGrasterizer *rast = NULL;
  unsigned char* img_data = NULL;
  int width;
  int height;
  const int depth = 4;
  svg_image = nsvgParseFromFile(icon_file.c_str(), "px", 96);
  if (svg_image == NULL)
  {
    trace("changeWidgetIcon::Could not open SVG image:"+icon_file);
    return;
  }
  width = (int)svg_image->width;
  height = (int)svg_image->height;
  rast = nsvgCreateRasterizer();
  if (rast == NULL)
  {
    trace("changeWidgetIcon::Could not init rasterizer.");
    return;
  }
  img_data = (unsigned char*)malloc(width * height * depth);
  if (img_data == NULL)
  {
    trace("changeWidgetIcon::Could not alloc image buffer.\\n");
    return;
  }
  nsvgRasterize(rast, svg_image, 0, 0, 1, img_data, width, height, (width * depth));
  Fl_Image* image  = new Fl_RGB_Image(img_data, width, height, 4);
  image2 = image->copy();
  delete(image);
  nsvgDeleteRasterizer(rast);
  nsvgDelete(svg_image);
}
else if((has_file_extention_at_end(icon_file,".jpg"))||
(has_file_extention_at_end(icon_file,".jpeg"))||
(has_file_extention_at_end(icon_file,".face")))
{
  Fl_Image* image = new Fl_JPEG_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else if(has_file_extention_at_end(icon_file,".gif"))
{
  Fl_Image* image = new Fl_GIF_Image(icon_file.c_str());
  image2 = image->copy(w,h);
  delete(image);
}
else{return;}

widget->image(image2->copy());
delete(image2);
widget->show();} {selected
    }
  }
  Function {comma_vector(std::string LINE,std::vector<std::string> Vector)} {return_type {std::vector<std::string>}
  } {
    code {std::string original,preComma,postComma;
original=LINE;
unsigned int found,finder;
finder=original.length();
for(found=original.find(",");found<finder;found=original.find(",")){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {convert_num_to_string(int num)} {return_type {std::string}
  } {
    code {std::string number;
std::stringstream out;
out << num;
number = out.str();
return number;} {}
  }
  Function {convert_string_to_number(std::string num)} {return_type {unsigned int}
  } {
    code {if(num.compare("")==0){return 0;}
std::stringstream out;
out << num;
unsigned int integer;
out >> integer;
return integer;} {}
  }
  Function {current_path(int whichPath)} {return_type {std::string}
  } {
    code {unsigned int lastPath = 0;
std::string result;
if (whichPath >=1){lastPath = whichPath - 1;}
else {lastPath = 0;}
const char* path =getenv("PATH");
std::string stringPATH;
if(path == NULL){stringPATH = "/usr/bin";}
else{stringPATH = path;}
std::string::size_type firstPosition = stringPATH.find(':');
if(firstPosition>stringPATH.length()){return stringPATH.c_str();}   
std::string::size_type position = firstPosition;
for (int i=1;i<=whichPath;i++){position = stringPATH.find(':',position+1);}
for (unsigned int j=1;j<=lastPath;j++){firstPosition = stringPATH.find(':',firstPosition+1);}
result = stringPATH.substr (firstPosition+1,((position-firstPosition)-1));
return result;} {}
  }
  Function {delimiter_vector_from_string(std::string string_to_become_vector,std::string delimiter)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> Vector;
std::string original,preComma,postComma;
original=string_to_become_vector;
unsigned int found,finder;
finder=original.length();
if(original.find(delimiter)>original.length()){
  Vector.push_back(original);
  return Vector;
}
for(found=original.find(delimiter);found<finder;found=original.find(delimiter)){
  preComma=original;
  postComma=original;
  preComma=preComma.erase(found,std::string::npos);
  if(preComma.compare("")!=0){Vector.push_back(preComma);}
  postComma=postComma.erase(0,found+1);
  original=postComma;
  finder=original.length();
}
if(postComma.compare("")!=0){Vector.push_back(postComma);}
return Vector;} {}
  }
  Function {decide()} {} {
    code {switch(type)
{
  case 0:
    shutdown();
    break;
  case 1:
    suspend();
    break;
  case 2:
    hibernate();
    break;
  case 3:
    leave();
    break;
  default:
    exit(0);
}} {}
  }
  Function {desktop_dirs()} {return_type {std::vector<std::string>}
  } {
    code {std::string envVar ="XDG_DATA_DIRS";
std::string incasenothingexists="/usr/local/share/:/usr/share/";
std::vector<std::string> thisPath;
std::vector<std::string>::iterator it;
std::string thisXDG;
const char* datadirs=getenv(envVar.c_str());
if (datadirs == NULL)
{
  thisXDG=incasenothingexists;
}
else
{
  thisXDG=datadirs;
}
unsigned int numberOfPaths;
std::string tempXDG = thisXDG;
unsigned int tryer=0;
unsigned int xdgLen=0;
xdgLen=thisXDG.length();
for (numberOfPaths=0;tryer<xdgLen;)
{
  tryer = tempXDG.find(":");
  tempXDG=tempXDG.erase(0,tryer+1);
  xdgLen=tempXDG.length();
  numberOfPaths++;
}
unsigned int lastPath = 0;
std::string result;
for (unsigned int whichPath=1;whichPath<=numberOfPaths;whichPath++)
{
  if (whichPath >=1){lastPath = whichPath - 1;}
  else {lastPath = 0;}
  std::string::size_type firstPosition = thisXDG.find_first_of(':');
  std::string::size_type position = thisXDG.find(':');
  for (unsigned int i=1;i<=whichPath;i++){position = thisXDG.find(':',position+1);}
  for (unsigned int j=1;j<=lastPath;j++){firstPosition = thisXDG.find(':',firstPosition+1);}
  result = thisXDG.substr (firstPosition+1,((position-firstPosition)-1));
  thisPath.push_back(result);    
}
std::sort (thisPath.begin(), thisPath.end());
it = std::unique (thisPath.begin(), thisPath.end());
thisPath.resize( std::distance(thisPath.begin(),it) );
return thisPath;} {}
  }
  Function {file_to_string(std::string filename)} {return_type {std::string}
  } {
    code {if(filename.compare("")==0){return "";}
/** make sure it is actually a file */
if(!test_file(filename)){trace("No file sent in: "+filename);}
std::string thisLine;
std::string fullString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(fullString.compare("")==0){fullString=thisLine;}
    else{fullString=fullString+"\\n"+thisLine;}
  }
}
return fullString;} {}
  }
  Function {find_xdg_data_dir_subdir(std::string subdir)} {return_type {std::string}
  } {
    code {std::vector<std::string> xdgDataDirs = desktop_dirs();
std::string dirToOpen;
for( std::vector<std::string>::iterator it = xdgDataDirs.begin();
it!=xdgDataDirs.end();
++it)
{
  dirToOpen=*it;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){dirToOpen+=subdir;}
  else
  {
    dirToOpen+="/";
    dirToOpen+=subdir;
  }
  if(test_dir(dirToOpen))
  {
    if(finder+1==dirToOpen.length()){return dirToOpen;}
    else
    {
      dirToOpen+="/";
      return dirToOpen;
    }
  }
  else{trace(dirToOpen+" does not exist");}
}
return "";} {}
  }
  Function {get_directory_from_filename(std::string filename)} {return_type {std::string}
  } {
    code {unsigned int finder=filename.rfind("/");
if(finder<filename.length())
{
  filename=filename.erase(finder,std::string::npos);
}
else{return "";} /**return empty if there is no directory*/
return filename;} {}
  }
  Function {get_equal_value(std::string INTERNAL_LINE)} {return_type {std::string}
  } {
    code {std::string subString;
unsigned int found =INTERNAL_LINE.find("=");
if(found < INTERNAL_LINE.length())
{
 subString=INTERNAL_LINE.substr(found+1,std::string::npos);
 return subString;
}
return "";} {}
  }
  Function {get_file_vector(std::string DIRECTORY,std::string file)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> myVector;
if(!test_dir(DIRECTORY)){return myVector;}
if(DIRECTORY.compare("")==0){return myVector;}
if(file.compare("")==0){return myVector;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(DIRECTORY.c_str());
if(DIRECTORY.rfind('/')!=DIRECTORY.length()-1){DIRECTORY+="/";}
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if((entryPointer->d_type == DT_REG)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      unsigned int findIT = fullpath.find(file);
      if(findIT<=fullpath.length()){myVector.push_back(fullpath);}

    }
    if((entryPointer->d_type==DT_DIR)&&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      fullpath=DIRECTORY+fullpath;
      if(fullpath.rfind('/')!=fullpath.length()-1){fullpath+="/";}
      std::string thisAnswer=look_for_file_in_subdirs(file,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        std::string temp=fullpath+file;
        myVector.push_back(temp);
      }
    }
  }
}
myVector=sort_array(myVector);
return myVector;} {}
  }
  Function {get_gtk_icon_theme()} {return_type {std::string}
  } {
    code {if(m_gtk_theme.compare("")!=0)
  return m_gtk_theme;
std::string itemToGet="icon";
std::string defaultTheme="hicolor";
std::string gtkrc2_result, gtkrc3_result,gtk2;
if((itemToGet.compare("icon")!=0)&&(itemToGet.compare("")!=0))
{
  itemToGet="";
}
std::string item=itemToGet;
std::string GSETTINGS=term_out("which gsettings");
std::string GCONF2=term_out("which gconftool-2");
if(GSETTINGS.find("gsettings")<GSETTINGS.length())
{
  std::string temp=item;
  if(item.compare("")==0)temp="gtk";
  gtkrc3_result=term_out(GSETTINGS+" get org.gnome.desktop.interface "+temp+"-theme");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\'");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\'");
  m_gtk_theme = gtkrc3_result;
  return gtkrc3_result;
}
if(GCONF2.find("gconftool-2")<GCONF2.length())
{
  std::string temp="gtk";
  if(item.compare("")!=0)temp=item;
  gtk2=term_out(GCONF2+" --get /desktop/gnome/interface/"+temp+"_theme");
  m_gtk_theme = gtk2;
  return gtk2;
}
const char* home = getenv("HOME");
if(home==NULL){return defaultTheme;}
std::string HOME=home;
//CHECK/SET GTKRC FILES
std::string GTKRC2=HOME + "/.gtkrc-2.0";
const char* xdg_config_home=getenv("XDG_CONFIG_HOME");
std::string XDG_CONFIG_HOME;
if (xdg_config_home!=NULL)
{
  XDG_CONFIG_HOME=xdg_config_home;
}
else
{
  XDG_CONFIG_HOME=HOME +"/.config";
}
std::string GTKRC3=XDG_CONFIG_HOME + "/gtk-3.0/settings.ini";
if(test_file(GTKRC3.c_str()))
{
  std::string temp;
  if(item.compare("")!=0)temp=item+"-";
  temp="gtk"+temp+"-theme-name=";
  gtkrc3_result=get_line_with_equal(GTKRC3,temp);
  gtkrc3_result=remove_cruft(gtkrc3_result,temp);
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\"");
  gtkrc3_result=remove_cruft(gtkrc3_result,"\\"");
  m_gtk_theme = gtkrc3_result;
  return gtkrc3_result;
}
if(test_file(GTKRC2.c_str()))
{
  std::string temp;
  if(item.compare("")!=0)temp=item+"-";
  temp="gtk"+temp+"-theme-name=";
  gtkrc2_result=get_line_with_equal(GTKRC2,temp);
  gtkrc2_result=remove_cruft(gtkrc2_result,"\\"");
  gtkrc2_result=remove_cruft(gtkrc2_result,"\\"");
  m_gtk_theme = gtkrc2_result;
  return gtkrc2_result;
}
return defaultTheme;} {}
  }
  Function {get_line_with_delim(std::string filename, std::string line,std::string delim)} {return_type {std::string}
  } {
    code {if(line.compare("")==0){return "";}
if(filename.compare("")==0){return "";}
if(!test_file(filename)){trace("get_line_with_delim::No file sent in\\n"+filename+","+line);}
std::string thisLine;
std::string subString;
std::ifstream inputFileStream(filename.c_str(), std::ifstream::in);
std::string hash="\#";
std::string itemToFind=line+delim;
unsigned int len=itemToFind.length();
if(inputFileStream.is_open())
{
  while (getline(inputFileStream,thisLine))
  {
    if(thisLine.find(hash)<=1){}
    else
    {
      unsigned int found=thisLine.find(itemToFind);
      if(found<thisLine.length())
      {
        found+=len;
        subString=thisLine.substr(found,std::string::npos);
        return subString;
      }
    }
  }
}
return "";} {}
  }
  Function {get_line_with_equal(std::string filename, std::string line)} {return_type {std::string}
  } {
    code {return get_line_with_delim(filename,line,"=");} {}
  }
  Function {get_shell_for_C()} {return_type {std::string}
  } {
    code {std::string shell=term_out("which bash");
if(shell.compare("")==0){
  if(!test_exec(shell)){
  shell=term_out("which sh");
  if(!test_exec(shell)){return "";}
  //TODO make this work for others
  }
}
shell=shell+" -c '";
return shell;} {}
  }
  Function {get_symlinkpath(std::string symlink)} {return_type {std::string}
  } {
    code {struct stat statinfo;
if((lstat(symlink.c_str(), &statinfo)>0)){return symlink;}
if ((!S_ISLNK (statinfo.st_mode) && statinfo.st_nlink > 1)||(S_ISLNK (statinfo.st_mode)))
{
  std::vector<char> buf(400);
  size_t len;
  do
  {
    buf.resize(buf.size() + 100);
    len = ::readlink(symlink.c_str(), &(buf[0]), buf.size());
  }
  while(buf.size() == len);
  if (len > 0)
  {
    buf[len] = '\\0';
    return (std::string(&(buf[0])));
  }
}
else
{
  return symlink;
}
return symlink;} {}
  }
  Function {has_file_extention_at_end(std::string filename,std::string extention)} {return_type bool
  } {
    code {std::string extention_check;
std::transform(filename.begin(), filename.end(), filename.begin(), ::tolower);
std::transform(extention.begin(), extention.end(), extention.begin(), ::tolower);
unsigned int found=filename.find(extention);
unsigned int ext_len=extention.length();
unsigned int file_len=filename.length();
if(found<file_len)
{
  if(found==(file_len-ext_len))
  {
    return true;
  }
}
return false;} {}
  }
  Function {hibernate()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" hibernate";
  return run(test);
}
test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Hibernate";
  return run(test);
}
return -1;} {}
  }
  Function {items_in_path()} {return_type {unsigned int}
  } {
    code {const char* path =getenv("PATH");
std::string::size_type pathPosition =0;
if(path==NULL){return 1;}
std::string stringPATH = path;
unsigned int howmany;
for(howmany=1;(pathPosition!=std::string::npos);howmany++)
{
  pathPosition=stringPATH.find(':', pathPosition+1);
}
return howmany;} {}
  }
  Function {IconPaths(int size_to_use=32)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ret;
if(m_themesVector.empty())
  m_themesVector=icon_themefiles_vector();

std::string gtk_theme=get_gtk_icon_theme();
gtk_theme=sed_i(gtk_theme,"-"," ");

trace("IconPaths::Look for this="+gtk_theme);
if(m_themesVector.empty())
{
  trace("IconPaths::Didn't find any Icon themes");
  return ret;
}
return IconPathsForTheme(gtk_theme,size_to_use);} {}
  }
  Function {IconPathsForTheme(std::string theme,int size_to_use=32)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ret;
std::string themefile;
for( std::vector<std::string>::iterator it = m_themesVector.begin();
it!=m_themesVector.end();
++it)
{
  std::string THEME=*it;
  std::string theme_name=get_line_with_equal(THEME,"Name");
  if(theme_name.compare(theme)==0)
  {
    trace("IconPathsForTheme::File="+THEME);
    ret=join_string_vectors(ret,list_icon_dirs_in_themefile(THEME,size_to_use));
    //std::reverse(ret.begin(),ret.end());
    std::string inherits=get_line_with_equal(THEME,"Inherits");
    std::vector<std::string> inheritsVec = delimiter_vector_from_string(inherits,",");

    for( std::vector<std::string>::iterator iter = inheritsVec.begin();
      iter!=inheritsVec.end();
      ++iter)
    {
      std::string item = *iter;
      ret=join_string_vectors(ret,IconPathsForTheme(item,size_to_use));
    }
  }
}
//std::reverse(ret.begin(),ret.end());
return ret;} {}
  }
  Function {icon_themefiles_vector()} {return_type {std::vector<std::string>}
  } {
    code {std::string DIRECTORY=find_xdg_data_dir_subdir("icons");
std::vector<std::string> thisISmyVector;
if(DIRECTORY.compare("")==0){trace("Icon directory NOT found");}
else{thisISmyVector=get_file_vector(DIRECTORY,"index.theme");}
if(thisISmyVector.empty()){trace("Didn't find and Icon themes");}
return thisISmyVector;} {}
  }
  Function {join_string_vectors(std::vector<std::string> vectorA,std::vector<std::string> vectorB)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> bothVectors;
bothVectors.reserve(vectorA.size()+vectorB.size());
bothVectors.insert(bothVectors.end(),vectorA.begin(),vectorA.end());
bothVectors.insert(bothVectors.end(),vectorB.begin(),vectorB.end());
return bothVectors;} {}
  }
  Function {leave()} {open return_type int
  } {
    code {std::string LOGOUT = "loginctl terminate-session $XDG_SESSION_ID";
if(test_file("/etc/default/nodm"))
{
  std::string tmp=file_to_string("/etc/default/nodm");
  unsigned int finder=tmp.find("NODM_ENABLED=true");
  if(finder<tmp.length())
  {
    LOGOUT="jwm -reload";
  }
}
return run(LOGOUT);} {}
  }
  Function {list_icon_dirs_in_themefile(std::string themefile,int size_to_use)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string> ListOfIconDirs;
std::string SIZE_TO_USE=convert_num_to_string(size_to_use);
std::string INTERNAL_LINE;
std::string subString;
std::string basedir=get_directory_from_filename(themefile);
std::string THEME_DIR=basedir;
if(!test_file(themefile))
     return ListOfIconDirs;
std::ifstream inputFileStrem (themefile.c_str(), std::ifstream::in);
std::string INHERITS;
std::string tmpDIRi="/usr/share/pixmaps/";
if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);

tmpDIRi="/usr/share/icons/hicolor/48x48/apps/";

if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);

tmpDIRi="/usr/share/icons/hicolor/scalable/apps/";

if(test_dir(tmpDIRi))
  ListOfIconDirs.push_back(tmpDIRi);
if(inputFileStrem.is_open())
{
  std::string DIRS,MIN,MAX,SIZE,TYPE,THRESH,CONTEXT,HEADER;
  int size=0;
  int tresh=0;
  int max=0;
  int min=0;
  std::string LINE=get_equal_value(INTERNAL_LINE);
  while (getline(inputFileStrem,INTERNAL_LINE))
  {
       if(INTERNAL_LINE.find('[')<INTERNAL_LINE.length())
       {
         HEADER=INTERNAL_LINE;
         HEADER=remove_cruft(HEADER,"[");
         HEADER=remove_cruft(HEADER,"]");
         HEADER="/"+HEADER;
       }
       else if(INTERNAL_LINE.find("Inherits=")<INTERNAL_LINE.length())
       {
         INHERITS=LINE;
       }
       else if(INTERNAL_LINE.find("Directories=")<INTERNAL_LINE.length())
       {
         DIRS=LINE;
       }
       else if(INTERNAL_LINE.find("MinSize=")<INTERNAL_LINE.length())
       {
         MIN=LINE;
         min=convert_string_to_number(MIN);
       }
       else if(INTERNAL_LINE.find("MaxSize=")<INTERNAL_LINE.length())
       {
         MAX=LINE;
         max=convert_string_to_number(MAX);
       }
       else if(INTERNAL_LINE.find("Size=")<INTERNAL_LINE.length())
       {
         SIZE=LINE;
         size=convert_string_to_number(SIZE);
       }
       else if(INTERNAL_LINE.find("Type=")<INTERNAL_LINE.length())
       {
         TYPE=LINE;
       }
       else if(INTERNAL_LINE.find("Threshold=")<INTERNAL_LINE.length())
       {
         THRESH=LINE;
         tresh=convert_string_to_number(THRESH);
       }
       else if(INTERNAL_LINE.find("Context=")<INTERNAL_LINE.length())
       {
         CONTEXT=LINE;
       }
       if((CONTEXT.compare("Animations")!=0)
       &&(CONTEXT.compare("Stock")!=0)
       &&(CONTEXT.compare("Status")!=0)
       &&(CONTEXT.compare("Emblems")!=0)
       &&(CONTEXT.compare("Emotes")!=0)
       &&(CONTEXT.compare("International")!=0) )
       {
         if((SIZE.compare(SIZE_TO_USE))||
         ((tresh-size)==(size_to_use))||
         ((tresh+size)==(size_to_use)) )
         {
            if(HEADER.find(SIZE)<HEADER.length())
            {
              std::string testDIR=THEME_DIR+HEADER;
              if(test_dir(testDIR))
              {
                if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                  ListOfIconDirs.push_back(testDIR);
              }
            }
       }
       else{
            if(TYPE.compare("Scalable")==0)
            {
              if((max>=size)&&(min<=size))
              {
                std::string testDIR=THEME_DIR+HEADER;
                if(test_dir(testDIR))
                {
                     if(!look_for_string_in_vector(ListOfIconDirs,testDIR))
                       ListOfIconDirs.push_back(testDIR);
                }
              }
            }
       }
       }
     }
}
trace("list_icon_dirs_in_themefile::Done parsing themefile "+themefile);
if(INHERITS.compare("")!=0)
{
  std::string inheritThemeFileDIR=find_xdg_data_dir_subdir("icons");
  std::string inheritThemeFile=inheritThemeFileDIR;
  if(INHERITS.find(",")<INHERITS.length())
  {
    std::vector<std::string> InheritFileVector=comma_vector(INHERITS,InheritFileVector);
    std::vector<std::string> IconFileVector=list_icon_dirs_in_themefile( themefile, size_to_use);
    for( std::vector<std::string>::iterator it = InheritFileVector.begin();
       it!=InheritFileVector.end();
       ++it)
    {
       std::string thisTheme=*it;
       inheritThemeFile+=thisTheme;
       std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
       if(temp.compare("")==0)
       {
            trace("list_icon_dirs_in_themefile::Couldn't find theme file in:"+inheritThemeFile);
       }
       else{
            std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
            if(!ListOfInheritIconDirs.empty())
            {
              ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
            }
       }
       }
     }
     else
     {
       inheritThemeFile+=INHERITS;
       std::string temp=look_for_file_in_subdirs("index.theme",inheritThemeFile);
       if(temp.compare("")==0)
       {
         trace("list_icon_dirs_in_themefileCouldn't find theme file in:"+inheritThemeFile);
       }
       else{
         std::vector<std::string> ListOfInheritIconDirs=list_icon_dirs_in_themefile(temp,size_to_use);
         if(!ListOfInheritIconDirs.empty())
         {
            ListOfIconDirs=join_string_vectors(ListOfInheritIconDirs,ListOfIconDirs);
         }
       }
     }
}
return ListOfIconDirs;} {}
  }
  Function {look_for_icon_file(std::string fileWITHOUTpath)} {return_type {std::string}
  } {
    code {std::string dir=find_xdg_data_dir_subdir("icons");
trace("std::string look_for_icon_file(std::string "+fileWITHOUTpath+")");
std::string gtktheme=get_gtk_icon_theme();

if(dir.rfind('/')!=dir.length()-1){dir+="/";}

std::string testingDIR=dir+gtktheme;

if(testingDIR.rfind('/')!=testingDIR.length()-1){testingDIR+="/";}
if(test_dir(testingDIR)){dir=testingDIR;}

if(fileWITHOUTpath.compare("")==0)
{
  trace("look_for_icon_file::(std::string "+fileWITHOUTpath+") requires non empty variables to work\\nMUST EXIT");
  return "";
}
trace("look_for_icon_file::GTKtheme="+gtktheme+"\\nDir="+dir);
if(!test_dir(dir))
{
  trace("look_for_icon_file::"+dir+" is not a directory\\nTrying to look in icons directories");
  dir=find_xdg_data_dir_subdir("icons");
  if(!test_dir(dir))
  {
    trace("look_for_icon_file::"+dir+" is not a directory\\nMUST EXIT");
    return "";
  }
  return look_for_first_file_in_subdirs(fileWITHOUTpath,dir);
}

std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
std::string finalAnswer;

if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string fullpath=entryPointer->d_name;

    if(dir.rfind('/')!=dir.length()-1){dir+="/";}

    fullpath=dir+fullpath;

    if((entryPointer->d_type == DT_REG)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string tempFINDER="/"+fileWITHOUTpath;
      unsigned int findIT = fullpath.find(tempFINDER);
      if(findIT<=fullpath.length())
      {
        closedir(mydir);
        finalAnswer=fullpath;
        return fullpath;
      }
    }

    if((entryPointer->d_type==DT_DIR)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(test_file(thisAnswer))
        {
          closedir(mydir);
          finalAnswer=thisAnswer;
          return thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
}
else
{
  trace("look_for_icon_file::"+dir+" cannot be opened\\nMUST EXIT");
}

if(finalAnswer.compare("")!=0)
  trace("look_for_icon_file::Final Answer="+finalAnswer);

return finalAnswer;} {}
  }
  Function {look_for_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
  return "";

/** if it is not a directory return empty */
if(!test_dir(dir))
  return "";

/** remove the preceding path*/
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}

std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());

/** open the directory */
if(mydir!=NULL){
  while ((entryPointer=readdir(mydir))!=NULL)
  {
  /** find out if it is a symlink or regular file that is not hidden*/
    if(((entryPointer->d_type == DT_LNK)
    ||(entryPointer->d_type == DT_REG))
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      unsigned int findIT = fullpath.find(fileWITHOUTpath);
      if(findIT<=fullpath.length())
      {
    /** add a comma at the end if there isn't one already*/
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)ANSWERS+=",";
        ANSWERS+=fullpath;
      }
    }
    /** find out if it is a directory that is not hidden*/
    if((entryPointer->d_type==DT_DIR)
    &&(entryPointer->d_name[0]!='.'))
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      std::string thisAnswer=look_for_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(ANSWERS.rfind(",")!=ANSWERS.length()-1)
        {
          ANSWERS+=",";
        }
        ANSWERS+=thisAnswer;
      }
    }
  }
}
closedir(mydir);
if(ANSWERS.compare("")!=0)
{
  return ANSWERS;
}
return "";} {}
  }
  Function {look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir)} {return_type {std::string}
  } {
    code {if((dir.compare("")==0)
||(fileWITHOUTpath.compare("")==0))
{
  trace("std::string look_for_first_file_in_subdirs(std::string fileWITHOUTpath,std::string dir) requires non empty variables to work\\nMUST EXIT");
  return "";
}
if(!test_dir(dir))
{
  trace("look_for_first_file_in_subdirs::"+dir+" is not a directory\\nMUST EXIT");
  return "";
}
unsigned int found=fileWITHOUTpath.rfind('/');
if(found<fileWITHOUTpath.length())
{
  unsigned int len=fileWITHOUTpath.length()-found;
  fileWITHOUTpath=fileWITHOUTpath.erase(0,len);
}
std::string ANSWERS;
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
std::string finalAnswer;
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    std::string fullpath=entryPointer->d_name;
    if(dir.rfind('/')!=dir.length()-1){dir+="/";}
    fullpath=dir+fullpath;
  /** if it is a symlink or file check it */
    if(((entryPointer->d_type == DT_LNK)
      ||(entryPointer->d_type == DT_REG))
      &&(entryPointer->d_name[0]!='.'))
    {
      std::string tempFINDER="/"+fileWITHOUTpath;
      trace("look_for_first_file_in_subdirs::FINDER:"+tempFINDER+"\\nfullpath="+fullpath);
      unsigned int findIT = fullpath.find(tempFINDER);
      if(findIT<=fullpath.length())
      {
        if(entryPointer->d_type == DT_LNK)
        {
    /** if it is a symlink get the actual file */
          std::string temporary=get_symlinkpath(fullpath);
          trace("look_for_first_file_in_subdirs::SYMLINK="+fullpath+"\\nFile="+temporary);
          if(temporary.compare("")!=0)
          {
            closedir(mydir);
            if(temporary.find("/")>temporary.length()){temporary=dir+temporary;}
            trace("look_for_first_file_in_subdirs::Symlink="+temporary);
            finalAnswer=temporary;
            return temporary;
          }
        }
        else
        {
          closedir(mydir);
          finalAnswer=fullpath;
          return fullpath;
        }
      }
    }
  /** if it is a directory look inside recursively */
    if((entryPointer->d_type==DT_DIR)
     &&(entryPointer->d_name[0]!='.'))
    {
      std::string thisAnswer=look_for_first_file_in_subdirs(fileWITHOUTpath,fullpath);
      if(thisAnswer.compare("")!=0)
      {
        if(test_file(thisAnswer))
        {
          closedir(mydir);
          finalAnswer=thisAnswer;
          return thisAnswer;
        }
      }
    }
  }
  closedir(mydir);
}
else{trace("look_for_first_file_in_subdirs::"+dir+" cannot be opened\\nMUST EXIT");}
trace("look_for_first_file_in_subdirs::Final Answer="+finalAnswer);
return finalAnswer;} {}
  }
  Function {look_for_string_in_vector(std::vector<std::string> vector_to_check,std::string item_to_find)} {return_type bool
  } {
    code {for( std::vector<std::string>::iterator it = vector_to_check.begin();
it!=vector_to_check.end();
++it){
  std::string tmp=*it;
  if(tmp.compare(item_to_find)==0){return true;}
}
return false;} {}
  }
  Function {remove_cruft(std::string StringInput, std::string CruftToRemove)} {return_type {std::string}
  } {
    code {if((StringInput.compare("")==0)||(CruftToRemove.compare("")==0)){return StringInput;}
unsigned int found=0;
unsigned int cruftLength=CruftToRemove.length();
found=StringInput.find(CruftToRemove);
if(found>StringInput.length()){return StringInput;}
std::string temp=StringInput;
temp=temp.erase(0,found+cruftLength);
if(temp.compare("")!=0){return temp;}
std::string temp2=StringInput;
temp2=temp2.erase(found,std::string::npos);
if(temp2.compare("")!=0){return temp2;}
trace("remove_cruft::There was a problem removing the cruft.... Giving you back your string");
return StringInput;} {}
  }
  Function {run(std::string program)} {return_type int
  } {
    code {std::string shell=get_shell_for_C();
if(shell.compare("")!=0)
{
  shell+=program;
  shell+="'";
}
else{shell=program;}
trace("run_program::"+shell);
return system(shell.c_str());} {}
  }
  Function {sed_i(std::string input, std::string remove, std::string replace)} {return_type {std::string}
  } {
    code {unsigned int xmlfix=0;
unsigned int oldFind=0;
unsigned int length=input.length();
unsigned int removeLength=remove.length();
std::string modinput=input;
while(modinput.find(remove,oldFind)<length)
{
  xmlfix = modinput.find(remove,oldFind);
  oldFind=xmlfix+replace.length();
  std::string tempPRE,tempPOST,temp;
  if(xmlfix<length)
  {
    temp=modinput;
    tempPOST=modinput;
    tempPRE = temp.erase(xmlfix,std::string::npos);
    tempPOST = modinput.erase(0,xmlfix+removeLength);
    modinput = tempPRE + replace + tempPOST;
    length=modinput.length();
  }
}
return modinput;} {}
  }
  Function {setup(int TYPE,bool YES)} {open
  } {
    code {type=TYPE;
if(YES)
{
  decide();
  exit(0);
}
make_window()->show();
std::string TITLE="Shutdown";
std::string ICON="system-shutdown";
switch(TYPE)
{
  case 1:
    TITLE="Suspend";
    ICON="system-suspend";
    break;
  case 2:
    TITLE="Hibernate";
    ICON="system-hibernate";
    break;
  case 3:
    TITLE="Logout";
    ICON="system-logout";
    break;
  default:
    break;
}
win->copy_label(TITLE.c_str());
label->copy_label(TITLE.c_str());
changeWidgetIcon(ICON,icon);} {}
  }
  Function {shutdown()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" poweroff";
  return run(test);
}

test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.ConsoleKit /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop";
  return run(test);
}
return -1;} {}
  }
  Function {sort_array(std::vector<std::string> vector_to_sort)} {return_type {std::vector<std::string>}
  } {
    code {std::vector<std::string>::iterator it;
std::sort (vector_to_sort.begin(), vector_to_sort.end());
it = std::unique (vector_to_sort.begin(), vector_to_sort.end());
vector_to_sort.resize( std::distance(vector_to_sort.begin(),it) );
return vector_to_sort;} {}
  }
  Function {suspend()} {return_type int
  } {
    code {std::string test=term_out("which systemctl");
if(test.compare("")!=0)
{
  test+=" suspend";
  return run(test);
}

test=term_out("which dbus-send");
if(test.compare("")!=0)
{
  test+=" --system --print-reply --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend";
  return run(test);
}
return -1;} {}
  }
  Function {test_dir(std::string dirToTest)} {return_type bool
  } {
    code {if(dirToTest.compare("")==0){return false;}
DIR *dir = NULL;
dir = opendir(dirToTest.c_str());
if (dir!=NULL)
{
  closedir(dir);
  return true;
}
return false;} {}
  }
  Function {test_exec(std::string execToTest)} {return_type bool
  } {
    code {if(execToTest.compare("")==0){return false;}
/** the list of directories it might check*/
/** /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games*/
std::string stringEXEC;
std:: string testPATH, testExec;
bool result = false;
unsigned int numofpaths = items_in_path();
for (unsigned int i = 1; i <= numofpaths; i++)
{
  stringEXEC = execToTest;
  testPATH = current_path(i);
  stringEXEC = testPATH + "/" + stringEXEC;
  if(test_file(stringEXEC.c_str())){return true;}
}
return result;} {}
  }
  Function {test_file(std::string fileWithFullPATH)} {return_type bool
  } {
    code {if(fileWithFullPATH.compare("")==0){return false;}
std::string dir=get_directory_from_filename(fileWithFullPATH);
if(dir.compare("")==0){return false;}
DIR *mydir=NULL;
struct dirent *entryPointer=NULL;
mydir=opendir(dir.c_str());
if(mydir!=NULL)
{
  while ((entryPointer=readdir(mydir))!=NULL)
  {
    if(entryPointer->d_type == DT_REG)
    {
      std::string fullpath=entryPointer->d_name;
      if(dir.rfind('/')!=dir.length()-1){dir+="/";}
      fullpath=dir+fullpath;
      if(fullpath.compare(fileWithFullPATH)==0)
      {
        closedir(mydir);
        return true;
      }
    }
  }
  closedir(mydir);
}
else{trace("could not open directory to search for "+fileWithFullPATH);}
return false;} {}
  }
  Function {test_file_in_vector_path(std::string fileWithNOPATH,std::vector<std::string> directories_to_check)} {return_type {std::string}
  } {
    code {if(fileWithNOPATH.compare("")==0){return "";}
std::string filePathRemoved=fileWithNOPATH;
unsigned int found=filePathRemoved.rfind('/');
trace("test_file_in_vector_path::Looking for:"+fileWithNOPATH);
if(found<filePathRemoved.length())
{
  unsigned int len=filePathRemoved.length()-found;
  filePathRemoved=filePathRemoved.erase(0,len);
}
for( std::vector<std::string>::iterator it = directories_to_check.begin();
  it!=directories_to_check.end();
  ++it)
{
  std::string dirToOpen=*it;
  std::string result=dirToOpen;
  unsigned int finder=dirToOpen.rfind('/');
  if(finder+1==dirToOpen.length()){result+=filePathRemoved;}
  else
  {
    result+="/";
    result+=filePathRemoved;
  }
  if(test_file(result))
  {
    trace("test_file_in_vector_path::FOUND="+result);
    return result;
  }
  else
  {
    std::string tmp=result;
    tmp=get_symlinkpath(tmp);
    if(tmp.compare("")!=0){return test_file_in_vector_path(tmp,directories_to_check);}
  }
}
return "";} {}
  }
  Function {term_out(std::string terminal_Command_You_Want_Output_From)} {return_type {std::string}
  } {
    code {if(terminal_Command_You_Want_Output_From.compare("")==0){return "";}
/** set a locale so this works well */
const char* LANG=getenv("LANG");
std::string LOCALE;
if(LANG==NULL)
{
  LANG=getenv("LANGUAGE");
  if(LANG!=NULL){
  std::string tmp=LANG;
  unsigned int find=tmp.find(".UTF-8");
  if(find>tmp.length()){tmp+=".UTF-8";}
  LOCALE=tmp;
  }
}
else
{
  LOCALE=LANG;
}
if(LOCALE.compare("")!=0){setlocale(LC_ALL, LOCALE.c_str());}
std::string result="";
const int max_buffer = 1024;
char buffer[max_buffer];
FILE *command_p = popen(terminal_Command_You_Want_Output_From.c_str(), "r");
if (command_p)
{
  while( fgets(buffer, sizeof(buffer), command_p) !=NULL){result.append(buffer);}
  pclose(command_p);
}
else{ return "";}
if (result.compare("")==0){return "";}
int end = result.length();
if((end-1) == 0){return "";}
if((end) == 0){return "";}
return result.erase(end-1,1);} {}
  }
} 

Function {main(int argc, char *argv[])} {open return_type int
} {
  code {std::string command;
Fl::visual(FL_RGB);
unsigned int TYPE=0;
bool YES=false;
UI* ui = new UI();
try
{
  if(argc>0)
  {
    for (int i = 1;i<argc;++i)
    {
      command=argv[i];
      for (int i=0;i<argc;i++)
      {
        if (command.compare("--shutdown")==0)
          TYPE=0;
        else if (command.compare("--suspend")==0)
          TYPE=1;
        else if (command.compare("--hibernate")==0)
          TYPE=2;
        else if (command.compare("--exit")==0)
          TYPE=3;
        else if ( (command.compare("--yes")==0) ||
                  (command.compare("-y")==0) ||
                  (command.compare("-f")==0) ||
                  (command.compare("--force")==0)
                )
         YES=true;
        else
        {
          return usage(argv[0]);
        }
      }
    }
    ui->setup(TYPE,YES);
  }
  return Fl::run();
}
catch (const std::exception& e)
{
  std::cerr << "Unhandled exception:\\n" << e.what() << std::endl;
  return EXIT_FAILURE;
}
catch (...)
{
  std::cerr << "Unknown exception!" << std::endl;
  return EXIT_FAILURE;
}
return -1;} {}
} 

Function {trace(std::string msg)} {open
} {
  code {//std::cout<<msg<<std::endl;} {}
} 

Function {usage(char* name)} {open return_type int
} {
  code {std::cout<<name<<std::endl<<
"USAGE:"<<std::endl<<
"[--shutdown|--suspend|--hibernate|--exit|-y|--yes|-f|--force]"<<std::endl<<
"  --shutdown shutdown computer"<<std::endl<<
"  --suspend suspend computer"<<std::endl<<
"  --hibernate hibernate computer"<<std::endl<<
"  --exit exit JWM\\n"<<std::endl<<
"  --yes | -y | -f | --force Do not show dialog"<<std::endl;} {}
} 
